From 7f89b11f6b4c138c3232d5f25f6bf20705c471ed Mon Sep 17 00:00:00 2001
From: methylDragon <methylDragon@gmail.com>
Date: Sat, 28 May 2022 18:02:44 -0700
Subject: [PATCH] ign -> gz Namespace Migration : gz-rendering (#629)

* Update header guards

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate namespaces

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Add migration line

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Implement deprecation trick

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Add deprecation test

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Include config.hh

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Use pragma deprecation message instead

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Ticktock config macros

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Mention gz headers in migration and fix migration

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate inline namespaces

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate includes to gz

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Update config.hh

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate Export.hh macros and deprecated test

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate github links

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate user-facing Ignition to Gazebo

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate gz-common logging calls

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Include config.hh in recursive directories and <lib>.hh

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Include config.hh in .h and .hpp redirection headers

Signed-off-by: methylDragon <methylDragon@gmail.com>

* `Gazebo Robotics` -> `Gazebo`

Signed-off-by: methylDragon <methylDragon@gmail.com>

* `ignitionrobotics` -> `gazebosim`

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Revert `gazebosim/gz-` to `ignitionrobotics/ign-` for `osrf-migration`

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Tick-tock GZ_RENDERING_PLUGIN_PATH

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Fix variables and add migration note

Signed-off-by: Louise Poubel <louise@openrobotics.org>

* Tick-tock GZ_RENDERING_RESOURCE_PATH

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate Ignition's -> Gazebo's

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Wording changes

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Migrate  `igndbg` -> `gzdbg`

Signed-off-by: methylDragon <methylDragon@gmail.com>

* Revert GZ_SIM_ env vars to IGNITION_GAZEBO_

Signed-off-by: methylDragon <methylDragon@gmail.com>

Co-authored-by: Louise Poubel <louise@openrobotics.org>
---
 CMakeLists.txt                                |  10 +-
 CONTRIBUTING.md                               |   2 +-
 Changelog.md                                  | 662 +++++++++---------
 Migration.md                                  |  26 +-
 NEWS                                          |   2 +-
 README.md                                     |  24 +-
 api.md.in                                     |   4 +-
 examples/actor_animation/GlutWindow.cc        |  14 +-
 examples/actor_animation/GlutWindow.hh        |   4 +-
 examples/actor_animation/Main.cc              |  14 +-
 examples/camera_tracking/GlutWindow.cc        |  24 +-
 examples/camera_tracking/GlutWindow.hh        |   2 +-
 examples/camera_tracking/Main.cc              |   2 +-
 examples/custom_scene_viewer/DemoWindow.cc    |   2 +-
 examples/custom_scene_viewer/DemoWindow.hh    |   2 +-
 .../custom_scene_viewer/ManualSceneDemo.cc    |   2 +-
 .../custom_scene_viewer/ManualSceneDemo.hh    |   2 +-
 examples/custom_scene_viewer/SceneBuilder.cc  |   2 +-
 examples/custom_scene_viewer/SceneBuilder.hh  |   2 +-
 examples/custom_scene_viewer/TestTypes.hh     |   2 +-
 examples/custom_shaders/custom_shaders.cc     |  60 +-
 .../custom_shaders_uniforms/GlutWindow.cc     |   2 +-
 .../custom_shaders_uniforms/GlutWindow.hh     |   2 +-
 examples/custom_shaders_uniforms/Main.cc      |  10 +-
 examples/depth_camera/GlutWindow.cc           |   8 +-
 examples/depth_camera/GlutWindow.hh           |   2 +-
 examples/depth_camera/Main.cc                 |   4 +-
 examples/gazebo_scene_viewer/CameraWindow.cc  |   4 +-
 examples/gazebo_scene_viewer/CameraWindow.hh  |   2 +-
 examples/gazebo_scene_viewer/GazeboDemo.cc    |   2 +-
 .../gazebo_scene_viewer/GazeboWorldDemo.cc    |   4 +-
 examples/gazebo_scene_viewer/SceneManager.cc  |  20 +-
 examples/gazebo_scene_viewer/SceneManager.hh  |   2 +-
 .../SceneManagerPrivate.hh                    |   2 +-
 examples/heightmap/GlutWindow.cc              |   8 +-
 examples/heightmap/GlutWindow.hh              |   2 +-
 examples/heightmap/Main.cc                    |   4 +-
 .../hello_world_plugin/HelloWorldPlugin.cc    |  16 +-
 examples/hello_world_plugin/README.md         |   4 +-
 examples/lidar_visual/GlutWindow.cc           |  18 +-
 examples/lidar_visual/GlutWindow.hh           |   4 +-
 examples/lidar_visual/Main.cc                 |  20 +-
 examples/mesh_viewer/GlutWindow.cc            |   8 +-
 examples/mesh_viewer/GlutWindow.hh            |   2 +-
 examples/mesh_viewer/Main.cc                  |   4 +-
 examples/mouse_picking/GlutWindow.cc          |   4 +-
 examples/mouse_picking/GlutWindow.hh          |   2 +-
 examples/mouse_picking/Main.cc                |   2 +-
 examples/ogre2_demo/GlutWindow.cc             |  10 +-
 examples/ogre2_demo/GlutWindow.hh             |   2 +-
 examples/ogre2_demo/Main.cc                   |   2 +-
 examples/particles_demo/GlutWindow.cc         |   8 +-
 examples/particles_demo/GlutWindow.hh         |   2 +-
 examples/particles_demo/Main.cc               |   4 +-
 examples/render_pass/GlutWindow.cc            |   2 +-
 examples/render_pass/GlutWindow.hh            |   2 +-
 examples/render_pass/Main.cc                  |   2 +-
 examples/segmentation_camera/GlutWindow.cc    |  12 +-
 examples/segmentation_camera/GlutWindow.hh    |   2 +-
 examples/segmentation_camera/Main.cc          |   4 +-
 examples/simple_demo/GlutWindow.cc            |   2 +-
 examples/simple_demo/GlutWindow.hh            |   2 +-
 examples/simple_demo/Main.cc                  |   2 +-
 examples/simple_demo_qml/IgnitionRenderer.cc  |  12 +-
 examples/simple_demo_qml/IgnitionRenderer.hh  |   4 +-
 examples/simple_demo_qml/ThreadRenderer.cpp   |  32 +-
 examples/simple_demo_qml/ThreadRenderer.h     |   2 +-
 examples/text_geom/GlutWindow.cc              |   2 +-
 examples/text_geom/GlutWindow.hh              |   2 +-
 examples/text_geom/Main.cc                    |   2 +-
 examples/thermal_camera/GlutWindow.cc         |  14 +-
 examples/thermal_camera/GlutWindow.hh         |   2 +-
 examples/thermal_camera/Main.cc               |   4 +-
 examples/transform_control/GlutWindow.cc      |  26 +-
 examples/transform_control/GlutWindow.hh      |   2 +-
 examples/transform_control/Main.cc            |   4 +-
 examples/view_control/GlutWindow.cc           |   8 +-
 examples/view_control/GlutWindow.hh           |   4 +-
 examples/view_control/Main.cc                 |   2 +-
 examples/visualization_demo/GlutWindow.cc     |   2 +-
 examples/visualization_demo/GlutWindow.hh     |   2 +-
 examples/visualization_demo/Main.cc           |  18 +-
 examples/waves/GlutWindow.cc                  |  14 +-
 examples/waves/GlutWindow.hh                  |   2 +-
 examples/waves/Main.cc                        |  12 +-
 examples/wide_angle_camera/GlutWindow.cc      |   4 +-
 examples/wide_angle_camera/GlutWindow.hh      |   2 +-
 examples/wide_angle_camera/Main.cc            |   4 +-
 include/gz/rendering/ArrowVisual.hh           |   6 +-
 include/gz/rendering/AxisVisual.hh            |   6 +-
 include/gz/rendering/BoundingBox.hh           |   6 +-
 include/gz/rendering/BoundingBoxCamera.hh     |   8 +-
 include/gz/rendering/COMVisual.hh             |  10 +-
 include/gz/rendering/Camera.hh                |  10 +-
 include/gz/rendering/CameraLens.hh            |  10 +-
 include/gz/rendering/Capsule.hh               |   6 +-
 include/gz/rendering/CompositeVisual.hh       |   6 +-
 include/gz/rendering/DepthCamera.hh           |  10 +-
 include/gz/rendering/DistortionPass.hh        |   6 +-
 include/gz/rendering/GaussianNoisePass.hh     |   6 +-
 include/gz/rendering/Geometry.hh              |   6 +-
 include/gz/rendering/GizmoVisual.hh           |   6 +-
 include/gz/rendering/GpuRays.hh               |  14 +-
 include/gz/rendering/GraphicsAPI.hh           |   8 +-
 include/gz/rendering/Grid.hh                  |   6 +-
 include/gz/rendering/Heightmap.hh             |   4 +-
 include/gz/rendering/HeightmapDescriptor.hh   |  18 +-
 include/gz/rendering/Image.hh                 |   6 +-
 include/gz/rendering/InertiaVisual.hh         |  12 +-
 include/gz/rendering/JointVisual.hh           |  20 +-
 include/gz/rendering/LidarVisual.hh           |  14 +-
 include/gz/rendering/Light.hh                 |  12 +-
 include/gz/rendering/LightVisual.hh           |   8 +-
 include/gz/rendering/Marker.hh                |  20 +-
 include/gz/rendering/Material.hh              |   8 +-
 include/gz/rendering/Mesh.hh                  |   8 +-
 include/gz/rendering/MeshDescriptor.hh        |   8 +-
 include/gz/rendering/MoveToHelper.hh          |   6 +-
 include/gz/rendering/Node.hh                  |   6 +-
 include/gz/rendering/Object.hh                |   6 +-
 include/gz/rendering/OrbitViewController.hh   |   6 +-
 include/gz/rendering/OrthoViewController.hh   |   6 +-
 include/gz/rendering/ParticleEmitter.hh       |  24 +-
 include/gz/rendering/PixelFormat.hh           |   8 +-
 include/gz/rendering/RayQuery.hh              |   8 +-
 include/gz/rendering/RenderEngine.hh          |   6 +-
 include/gz/rendering/RenderEngineManager.hh   |   8 +-
 include/gz/rendering/RenderEnginePlugin.hh    |   6 +-
 include/gz/rendering/RenderPass.hh            |   6 +-
 include/gz/rendering/RenderPassSystem.hh      |  12 +-
 include/gz/rendering/RenderTarget.hh          |  10 +-
 include/gz/rendering/RenderTypes.hh           |   4 +-
 include/gz/rendering/RenderingIface.hh        |  36 +-
 include/gz/rendering/Scene.hh                 |   6 +-
 include/gz/rendering/SegmentationCamera.hh    |   8 +-
 include/gz/rendering/Sensor.hh                |   6 +-
 include/gz/rendering/ShaderParam.hh           |   6 +-
 include/gz/rendering/ShaderParams.hh          |   8 +-
 include/gz/rendering/ShaderType.hh            |   8 +-
 include/gz/rendering/Storage.hh               |  14 +-
 include/gz/rendering/Text.hh                  |  12 +-
 include/gz/rendering/ThermalCamera.hh         |   8 +-
 include/gz/rendering/TransformController.hh   |  10 +-
 include/gz/rendering/TransformType.hh         |  10 +-
 include/gz/rendering/Utils.hh                 |  20 +-
 include/gz/rendering/ViewController.hh        |   6 +-
 include/gz/rendering/Visual.hh                |  10 +-
 include/gz/rendering/WideAngleCamera.hh       |   6 +-
 include/gz/rendering/WireBox.hh               |  10 +-
 include/gz/rendering/base/BaseArrowVisual.hh  |   4 +-
 include/gz/rendering/base/BaseAxisVisual.hh   |   4 +-
 .../rendering/base/BaseBoundingBoxCamera.hh   |   6 +-
 include/gz/rendering/base/BaseCOMVisual.hh    |  20 +-
 include/gz/rendering/base/BaseCamera.hh       |  20 +-
 include/gz/rendering/base/BaseCapsule.hh      |   6 +-
 include/gz/rendering/base/BaseDepthCamera.hh  |  12 +-
 .../gz/rendering/base/BaseDistortionPass.hh   |   4 +-
 .../rendering/base/BaseGaussianNoisePass.hh   |   8 +-
 include/gz/rendering/base/BaseGeometry.hh     |   6 +-
 include/gz/rendering/base/BaseGizmoVisual.hh  |   4 +-
 include/gz/rendering/base/BaseGpuRays.hh      |  30 +-
 include/gz/rendering/base/BaseGrid.hh         |   4 +-
 include/gz/rendering/base/BaseHeightmap.hh    |   4 +-
 .../gz/rendering/base/BaseInertiaVisual.hh    |  26 +-
 include/gz/rendering/base/BaseJointVisual.hh  |  72 +-
 include/gz/rendering/base/BaseLidarVisual.hh  |  22 +-
 include/gz/rendering/base/BaseLight.hh        |   4 +-
 include/gz/rendering/base/BaseLightVisual.hh  | 114 +--
 include/gz/rendering/base/BaseMarker.hh       |  24 +-
 include/gz/rendering/base/BaseMaterial.hh     |   4 +-
 include/gz/rendering/base/BaseMesh.hh         |  12 +-
 include/gz/rendering/base/BaseNode.hh         |  12 +-
 include/gz/rendering/base/BaseObject.hh       |   6 +-
 .../gz/rendering/base/BaseParticleEmitter.hh  |  50 +-
 include/gz/rendering/base/BaseRayQuery.hh     |  10 +-
 include/gz/rendering/base/BaseRenderEngine.hh |   6 +-
 include/gz/rendering/base/BaseRenderPass.hh   |   4 +-
 include/gz/rendering/base/BaseRenderTarget.hh |   6 +-
 include/gz/rendering/base/BaseRenderTypes.hh  |   4 +-
 include/gz/rendering/base/BaseScene.hh        |  22 +-
 .../rendering/base/BaseSegmentationCamera.hh  |   8 +-
 include/gz/rendering/base/BaseSensor.hh       |   4 +-
 include/gz/rendering/base/BaseStorage.hh      |  38 +-
 include/gz/rendering/base/BaseText.hh         |  18 +-
 .../gz/rendering/base/BaseThermalCamera.hh    |  10 +-
 include/gz/rendering/base/BaseVisual.hh       |  56 +-
 .../gz/rendering/base/BaseWideAngleCamera.hh  |   6 +-
 include/gz/rendering/base/BaseWireBox.hh      |  14 +-
 include/gz/rendering/config.hh.in             |  43 +-
 include/ignition/rendering.hh                 |   1 +
 include/ignition/rendering/ArrowVisual.hh     |   1 +
 include/ignition/rendering/AxisVisual.hh      |   1 +
 include/ignition/rendering/BoundingBox.hh     |   1 +
 .../ignition/rendering/BoundingBoxCamera.hh   |   1 +
 include/ignition/rendering/COMVisual.hh       |   1 +
 include/ignition/rendering/Camera.hh          |   1 +
 include/ignition/rendering/CameraLens.hh      |   1 +
 include/ignition/rendering/Capsule.hh         |   1 +
 include/ignition/rendering/CompositeVisual.hh |   1 +
 include/ignition/rendering/DepthCamera.hh     |   1 +
 include/ignition/rendering/DistortionPass.hh  |   1 +
 include/ignition/rendering/Export.hh          |   1 +
 .../ignition/rendering/GaussianNoisePass.hh   |   1 +
 include/ignition/rendering/Geometry.hh        |   1 +
 include/ignition/rendering/GizmoVisual.hh     |   1 +
 include/ignition/rendering/GpuRays.hh         |   1 +
 include/ignition/rendering/GraphicsAPI.hh     |   1 +
 include/ignition/rendering/Grid.hh            |   1 +
 include/ignition/rendering/Heightmap.hh       |   1 +
 .../ignition/rendering/HeightmapDescriptor.hh |   1 +
 include/ignition/rendering/Image.hh           |   1 +
 include/ignition/rendering/InertiaVisual.hh   |   1 +
 include/ignition/rendering/JointVisual.hh     |   1 +
 include/ignition/rendering/LidarVisual.hh     |   1 +
 include/ignition/rendering/Light.hh           |   1 +
 include/ignition/rendering/LightVisual.hh     |   1 +
 include/ignition/rendering/Marker.hh          |   1 +
 include/ignition/rendering/Material.hh        |   1 +
 include/ignition/rendering/Mesh.hh            |   1 +
 include/ignition/rendering/MeshDescriptor.hh  |   1 +
 include/ignition/rendering/MoveToHelper.hh    |   1 +
 include/ignition/rendering/Node.hh            |   1 +
 include/ignition/rendering/Object.hh          |   1 +
 .../ignition/rendering/OrbitViewController.hh |   1 +
 .../ignition/rendering/OrthoViewController.hh |   1 +
 include/ignition/rendering/ParticleEmitter.hh |   1 +
 include/ignition/rendering/PixelFormat.hh     |   1 +
 include/ignition/rendering/RayQuery.hh        |   1 +
 include/ignition/rendering/RenderEngine.hh    |   1 +
 .../ignition/rendering/RenderEngineManager.hh |   1 +
 .../ignition/rendering/RenderEnginePlugin.hh  |   1 +
 include/ignition/rendering/RenderPass.hh      |   1 +
 .../ignition/rendering/RenderPassSystem.hh    |   1 +
 include/ignition/rendering/RenderTarget.hh    |   1 +
 include/ignition/rendering/RenderTypes.hh     |   1 +
 include/ignition/rendering/RenderingIface.hh  |   1 +
 include/ignition/rendering/Scene.hh           |   1 +
 .../ignition/rendering/SegmentationCamera.hh  |   1 +
 include/ignition/rendering/Sensor.hh          |   1 +
 include/ignition/rendering/ShaderParam.hh     |   1 +
 include/ignition/rendering/ShaderParams.hh    |   1 +
 include/ignition/rendering/ShaderType.hh      |   1 +
 include/ignition/rendering/Storage.hh         |   1 +
 include/ignition/rendering/Text.hh            |   1 +
 include/ignition/rendering/ThermalCamera.hh   |   1 +
 .../ignition/rendering/TransformController.hh |   1 +
 include/ignition/rendering/TransformType.hh   |   1 +
 include/ignition/rendering/Utils.hh           |   1 +
 include/ignition/rendering/ViewController.hh  |   1 +
 include/ignition/rendering/Visual.hh          |   1 +
 include/ignition/rendering/WideAngleCamera.hh |   1 +
 include/ignition/rendering/WireBox.hh         |   1 +
 .../rendering/base/BaseArrowVisual.hh         |   1 +
 .../ignition/rendering/base/BaseAxisVisual.hh |   1 +
 .../rendering/base/BaseBoundingBoxCamera.hh   |   1 +
 .../ignition/rendering/base/BaseCOMVisual.hh  |   1 +
 include/ignition/rendering/base/BaseCamera.hh |   1 +
 .../ignition/rendering/base/BaseCapsule.hh    |   1 +
 .../rendering/base/BaseDepthCamera.hh         |   1 +
 .../rendering/base/BaseDistortionPass.hh      |   1 +
 .../rendering/base/BaseGaussianNoisePass.hh   |   1 +
 .../ignition/rendering/base/BaseGeometry.hh   |   1 +
 .../rendering/base/BaseGizmoVisual.hh         |   1 +
 .../ignition/rendering/base/BaseGpuRays.hh    |   1 +
 include/ignition/rendering/base/BaseGrid.hh   |   1 +
 .../ignition/rendering/base/BaseHeightmap.hh  |   1 +
 .../rendering/base/BaseInertiaVisual.hh       |   1 +
 .../rendering/base/BaseJointVisual.hh         |   1 +
 .../rendering/base/BaseLidarVisual.hh         |   1 +
 include/ignition/rendering/base/BaseLight.hh  |   1 +
 .../rendering/base/BaseLightVisual.hh         |   1 +
 include/ignition/rendering/base/BaseMarker.hh |   1 +
 .../ignition/rendering/base/BaseMaterial.hh   |   1 +
 include/ignition/rendering/base/BaseMesh.hh   |   1 +
 include/ignition/rendering/base/BaseNode.hh   |   1 +
 include/ignition/rendering/base/BaseObject.hh |   1 +
 .../rendering/base/BaseParticleEmitter.hh     |   1 +
 .../ignition/rendering/base/BaseRayQuery.hh   |   1 +
 .../rendering/base/BaseRenderEngine.hh        |   1 +
 .../ignition/rendering/base/BaseRenderPass.hh |   1 +
 .../rendering/base/BaseRenderTarget.hh        |   1 +
 .../rendering/base/BaseRenderTypes.hh         |   1 +
 include/ignition/rendering/base/BaseScene.hh  |   1 +
 .../rendering/base/BaseSegmentationCamera.hh  |   1 +
 include/ignition/rendering/base/BaseSensor.hh |   1 +
 .../ignition/rendering/base/BaseStorage.hh    |   1 +
 include/ignition/rendering/base/BaseText.hh   |   1 +
 .../rendering/base/BaseThermalCamera.hh       |   1 +
 include/ignition/rendering/base/BaseVisual.hh |   1 +
 .../rendering/base/BaseWideAngleCamera.hh     |   1 +
 .../ignition/rendering/base/BaseWireBox.hh    |   1 +
 include/ignition/rendering/config.hh          |  32 +
 .../gz/rendering/ogre/OgreArrowVisual.hh      |   6 +-
 .../gz/rendering/ogre/OgreAxisVisual.hh       |   6 +-
 .../gz/rendering/ogre/OgreCOMVisual.hh        |   6 +-
 ogre/include/gz/rendering/ogre/OgreCamera.hh  |   8 +-
 ogre/include/gz/rendering/ogre/OgreCapsule.hh |   6 +-
 .../gz/rendering/ogre/OgreConversions.hh      |   6 +-
 .../gz/rendering/ogre/OgreDepthCamera.hh      |  10 +-
 .../gz/rendering/ogre/OgreDistortionPass.hh   |  14 +-
 .../gz/rendering/ogre/OgreDynamicLines.hh     |  34 +-
 .../rendering/ogre/OgreDynamicRenderable.hh   |   6 +-
 .../rendering/ogre/OgreGaussianNoisePass.hh   |   6 +-
 .../include/gz/rendering/ogre/OgreGeometry.hh |   6 +-
 .../gz/rendering/ogre/OgreGizmoVisual.hh      |   6 +-
 ogre/include/gz/rendering/ogre/OgreGpuRays.hh |   6 +-
 ogre/include/gz/rendering/ogre/OgreGrid.hh    |   6 +-
 .../gz/rendering/ogre/OgreHeightmap.hh        |   8 +-
 .../gz/rendering/ogre/OgreInertiaVisual.hh    |  10 +-
 .../gz/rendering/ogre/OgreJointVisual.hh      |   6 +-
 .../gz/rendering/ogre/OgreLidarVisual.hh      |   8 +-
 ogre/include/gz/rendering/ogre/OgreLight.hh   |  12 +-
 .../gz/rendering/ogre/OgreLightVisual.hh      |   6 +-
 ogre/include/gz/rendering/ogre/OgreMarker.hh  |  12 +-
 .../include/gz/rendering/ogre/OgreMaterial.hh |   6 +-
 .../gz/rendering/ogre/OgreMaterialSwitcher.hh |  10 +-
 ogre/include/gz/rendering/ogre/OgreMesh.hh    |   8 +-
 .../gz/rendering/ogre/OgreMeshFactory.hh      |   8 +-
 ogre/include/gz/rendering/ogre/OgreNode.hh    |   6 +-
 ogre/include/gz/rendering/ogre/OgreObject.hh  |   6 +-
 .../gz/rendering/ogre/OgreObjectInterface.hh  |   6 +-
 .../gz/rendering/ogre/OgreParticleEmitter.hh  |   6 +-
 .../gz/rendering/ogre/OgreRTShaderSystem.hh   |   6 +-
 .../include/gz/rendering/ogre/OgreRayQuery.hh |   6 +-
 .../gz/rendering/ogre/OgreRenderEngine.hh     |   8 +-
 .../gz/rendering/ogre/OgreRenderPass.hh       |   6 +-
 .../gz/rendering/ogre/OgreRenderTarget.hh     |  10 +-
 .../ogre/OgreRenderTargetMaterial.hh          |   6 +-
 .../gz/rendering/ogre/OgreRenderTypes.hh      |   4 +-
 ogre/include/gz/rendering/ogre/OgreScene.hh   |   6 +-
 .../gz/rendering/ogre/OgreSelectionBuffer.hh  |   6 +-
 ogre/include/gz/rendering/ogre/OgreSensor.hh  |   6 +-
 ogre/include/gz/rendering/ogre/OgreStorage.hh |   6 +-
 ogre/include/gz/rendering/ogre/OgreText.hh    |  10 +-
 .../gz/rendering/ogre/OgreThermalCamera.hh    |   8 +-
 ogre/include/gz/rendering/ogre/OgreVisual.hh  |  16 +-
 .../gz/rendering/ogre/OgreWideAngleCamera.hh  |   6 +-
 ogre/include/gz/rendering/ogre/OgreWireBox.hh |   6 +-
 ogre/include/ignition/rendering/ogre.hh       |   1 +
 .../include/ignition/rendering/ogre/Export.hh |   1 +
 .../rendering/ogre/OgreArrowVisual.hh         |   1 +
 .../ignition/rendering/ogre/OgreAxisVisual.hh |   1 +
 .../ignition/rendering/ogre/OgreCOMVisual.hh  |   1 +
 .../ignition/rendering/ogre/OgreCamera.hh     |   1 +
 .../ignition/rendering/ogre/OgreCapsule.hh    |   1 +
 .../rendering/ogre/OgreConversions.hh         |   1 +
 .../rendering/ogre/OgreDepthCamera.hh         |   1 +
 .../rendering/ogre/OgreDistortionPass.hh      |   1 +
 .../rendering/ogre/OgreDynamicLines.hh        |   1 +
 .../rendering/ogre/OgreDynamicRenderable.hh   |   1 +
 .../rendering/ogre/OgreGaussianNoisePass.hh   |   1 +
 .../ignition/rendering/ogre/OgreGeometry.hh   |   1 +
 .../rendering/ogre/OgreGizmoVisual.hh         |   1 +
 .../ignition/rendering/ogre/OgreGpuRays.hh    |   1 +
 .../ignition/rendering/ogre/OgreGrid.hh       |   1 +
 .../ignition/rendering/ogre/OgreHeightmap.hh  |   1 +
 .../ignition/rendering/ogre/OgreIncludes.hh   |   1 +
 .../rendering/ogre/OgreInertiaVisual.hh       |   1 +
 .../rendering/ogre/OgreJointVisual.hh         |   1 +
 .../rendering/ogre/OgreLidarVisual.hh         |   1 +
 .../ignition/rendering/ogre/OgreLight.hh      |   1 +
 .../rendering/ogre/OgreLightVisual.hh         |   1 +
 .../ignition/rendering/ogre/OgreMarker.hh     |   1 +
 .../ignition/rendering/ogre/OgreMaterial.hh   |   1 +
 .../rendering/ogre/OgreMaterialSwitcher.hh    |   1 +
 .../ignition/rendering/ogre/OgreMesh.hh       |   1 +
 .../rendering/ogre/OgreMeshFactory.hh         |   1 +
 .../ignition/rendering/ogre/OgreNode.hh       |   1 +
 .../ignition/rendering/ogre/OgreObject.hh     |   1 +
 .../rendering/ogre/OgreObjectInterface.hh     |   1 +
 .../rendering/ogre/OgreParticleEmitter.hh     |   1 +
 .../rendering/ogre/OgreRTShaderSystem.hh      |   1 +
 .../ignition/rendering/ogre/OgreRayQuery.hh   |   1 +
 .../rendering/ogre/OgreRenderEngine.hh        |   1 +
 .../ignition/rendering/ogre/OgreRenderPass.hh |   1 +
 .../rendering/ogre/OgreRenderTarget.hh        |   1 +
 .../ogre/OgreRenderTargetMaterial.hh          |   1 +
 .../rendering/ogre/OgreRenderTypes.hh         |   1 +
 .../ignition/rendering/ogre/OgreScene.hh      |   1 +
 .../rendering/ogre/OgreSelectionBuffer.hh     |   1 +
 .../ignition/rendering/ogre/OgreSensor.hh     |   1 +
 .../ignition/rendering/ogre/OgreStorage.hh    |   1 +
 .../ignition/rendering/ogre/OgreText.hh       |   1 +
 .../rendering/ogre/OgreThermalCamera.hh       |   1 +
 .../ignition/rendering/ogre/OgreVisual.hh     |   1 +
 .../rendering/ogre/OgreWideAngleCamera.hh     |   1 +
 .../ignition/rendering/ogre/OgreWireBox.hh    |   1 +
 ogre/src/CMakeLists.txt                       |  10 +-
 ogre/src/OgreArrowVisual.cc                   |   4 +-
 ogre/src/OgreAxisVisual.cc                    |   4 +-
 ogre/src/OgreCOMVisual.cc                     |  28 +-
 ogre/src/OgreCamera.cc                        |  32 +-
 ogre/src/OgreCapsule.cc                       |  22 +-
 ogre/src/OgreConversions.cc                   |   4 +-
 ogre/src/OgreDepthCamera.cc                   |  45 +-
 ogre/src/OgreDistortionPass.cc                | 104 +--
 ogre/src/OgreDynamicLines.cc                  |  38 +-
 ogre/src/OgreDynamicRenderable.cc             |   8 +-
 ogre/src/OgreGaussianNoisePass.cc             |  24 +-
 ogre/src/OgreGeometry.cc                      |   8 +-
 ogre/src/OgreGizmoVisual.cc                   |   4 +-
 ogre/src/OgreGpuRays.cc                       |  48 +-
 ogre/src/OgreGrid.cc                          |  14 +-
 ogre/src/OgreHeightmap.cc                     |  68 +-
 ogre/src/OgreInertiaVisual.cc                 |  28 +-
 ogre/src/OgreJointVisual.cc                   |   4 +-
 ogre/src/OgreLidarVisual.cc                   |  44 +-
 ogre/src/OgreLight.cc                         |  14 +-
 ogre/src/OgreLightVisual.cc                   |  14 +-
 ogre/src/OgreMarker.cc                        |  36 +-
 ogre/src/OgreMaterial.cc                      |  31 +-
 ogre/src/OgreMaterialSwitcher.cc              |  18 +-
 ogre/src/OgreMesh.cc                          |  32 +-
 ogre/src/OgreMeshFactory.cc                   |  52 +-
 ogre/src/OgreNode.cc                          |  24 +-
 ogre/src/OgreObject.cc                        |   6 +-
 ogre/src/OgreObjectInterface.cc               |   4 +-
 ogre/src/OgreParticleEmitter.cc               |   4 +-
 ogre/src/OgreRTShaderSystem.cc                |  47 +-
 ogre/src/OgreRayQuery.cc                      |  30 +-
 ogre/src/OgreRenderEngine.cc                  |  81 +--
 ogre/src/OgreRenderPass.cc                    |   4 +-
 ogre/src/OgreRenderTarget.cc                  |  42 +-
 ogre/src/OgreRenderTargetMaterial.cc          |   6 +-
 ogre/src/OgreScene.cc                         |  84 +--
 ogre/src/OgreSelectionBuffer.cc               |  28 +-
 ogre/src/OgreSensor.cc                        |   4 +-
 ogre/src/OgreText.cc                          |  42 +-
 ogre/src/OgreThermalCamera.cc                 |  38 +-
 ogre/src/OgreVisual.cc                        |  68 +-
 ogre/src/OgreWideAngleCamera.cc               |  42 +-
 ogre/src/OgreWireBox.cc                       |  20 +-
 ogre/src/media/fonts/CMakeLists.txt           |   4 +-
 .../media/materials/programs/CMakeLists.txt   |   2 +-
 .../media/materials/scripts/CMakeLists.txt    |   2 +-
 ogre/src/media/rtshaderlib150/CMakeLists.txt  |   2 +-
 .../gz/rendering/ogre2/Ogre2ArrowVisual.hh    |   6 +-
 .../gz/rendering/ogre2/Ogre2AxisVisual.hh     |   6 +-
 .../gz/rendering/ogre2/Ogre2COMVisual.hh      |   6 +-
 .../include/gz/rendering/ogre2/Ogre2Camera.hh |   8 +-
 .../gz/rendering/ogre2/Ogre2Capsule.hh        |   6 +-
 .../gz/rendering/ogre2/Ogre2Conversions.hh    |   6 +-
 .../gz/rendering/ogre2/Ogre2DepthCamera.hh    |  10 +-
 .../rendering/ogre2/Ogre2DynamicRenderable.hh |  26 +-
 .../rendering/ogre2/Ogre2GaussianNoisePass.hh |   6 +-
 .../gz/rendering/ogre2/Ogre2Geometry.hh       |   6 +-
 .../gz/rendering/ogre2/Ogre2GizmoVisual.hh    |   6 +-
 .../gz/rendering/ogre2/Ogre2GpuRays.hh        |   6 +-
 ogre2/include/gz/rendering/ogre2/Ogre2Grid.hh |   6 +-
 .../ogre2/Ogre2GzOgreRenderingMode.hh         |   6 +-
 .../gz/rendering/ogre2/Ogre2Heightmap.hh      |   8 +-
 .../gz/rendering/ogre2/Ogre2InertiaVisual.hh  |  10 +-
 .../gz/rendering/ogre2/Ogre2JointVisual.hh    |   6 +-
 .../gz/rendering/ogre2/Ogre2LidarVisual.hh    |   6 +-
 .../include/gz/rendering/ogre2/Ogre2Light.hh  |  12 +-
 .../gz/rendering/ogre2/Ogre2LightVisual.hh    |   6 +-
 .../include/gz/rendering/ogre2/Ogre2Marker.hh |  12 +-
 .../gz/rendering/ogre2/Ogre2Material.hh       |   6 +-
 .../rendering/ogre2/Ogre2MaterialSwitcher.hh  |  10 +-
 ogre2/include/gz/rendering/ogre2/Ogre2Mesh.hh |   8 +-
 .../gz/rendering/ogre2/Ogre2MeshFactory.hh    |   8 +-
 ogre2/include/gz/rendering/ogre2/Ogre2Node.hh |   6 +-
 .../include/gz/rendering/ogre2/Ogre2Object.hh |   6 +-
 .../rendering/ogre2/Ogre2ObjectInterface.hh   |   6 +-
 .../rendering/ogre2/Ogre2ParticleEmitter.hh   |  14 +-
 .../gz/rendering/ogre2/Ogre2RayQuery.hh       |   6 +-
 .../gz/rendering/ogre2/Ogre2RenderEngine.hh   |  10 +-
 .../gz/rendering/ogre2/Ogre2RenderPass.hh     |   6 +-
 .../gz/rendering/ogre2/Ogre2RenderTarget.hh   |  10 +-
 .../ogre2/Ogre2RenderTargetMaterial.hh        |   6 +-
 .../gz/rendering/ogre2/Ogre2RenderTypes.hh    |   4 +-
 .../include/gz/rendering/ogre2/Ogre2Scene.hh  |   6 +-
 .../ogre2/Ogre2SegmentationCamera.hh          |   8 +-
 .../rendering/ogre2/Ogre2SelectionBuffer.hh   |   6 +-
 .../include/gz/rendering/ogre2/Ogre2Sensor.hh |   6 +-
 .../gz/rendering/ogre2/Ogre2Storage.hh        |   6 +-
 .../gz/rendering/ogre2/Ogre2ThermalCamera.hh  |   8 +-
 .../include/gz/rendering/ogre2/Ogre2Visual.hh |  16 +-
 .../gz/rendering/ogre2/Ogre2WireBox.hh        |   6 +-
 ogre2/include/ignition/rendering/ogre2.hh     |   1 +
 .../ignition/rendering/ogre2/Export.hh        |   1 +
 .../rendering/ogre2/Ogre2ArrowVisual.hh       |   1 +
 .../rendering/ogre2/Ogre2AxisVisual.hh        |   1 +
 .../rendering/ogre2/Ogre2COMVisual.hh         |   1 +
 .../ignition/rendering/ogre2/Ogre2Camera.hh   |   1 +
 .../ignition/rendering/ogre2/Ogre2Capsule.hh  |   1 +
 .../rendering/ogre2/Ogre2Conversions.hh       |   1 +
 .../rendering/ogre2/Ogre2DepthCamera.hh       |   1 +
 .../rendering/ogre2/Ogre2DynamicRenderable.hh |   1 +
 .../rendering/ogre2/Ogre2GaussianNoisePass.hh |   1 +
 .../ignition/rendering/ogre2/Ogre2Geometry.hh |   1 +
 .../rendering/ogre2/Ogre2GizmoVisual.hh       |   1 +
 .../ignition/rendering/ogre2/Ogre2GpuRays.hh  |   1 +
 .../ignition/rendering/ogre2/Ogre2Grid.hh     |   1 +
 .../rendering/ogre2/Ogre2Heightmap.hh         |   1 +
 .../ogre2/Ogre2IgnOgreRenderingMode.hh        |   1 +
 .../ignition/rendering/ogre2/Ogre2Includes.hh |   1 +
 .../rendering/ogre2/Ogre2InertiaVisual.hh     |   1 +
 .../rendering/ogre2/Ogre2JointVisual.hh       |   1 +
 .../rendering/ogre2/Ogre2LidarVisual.hh       |   1 +
 .../ignition/rendering/ogre2/Ogre2Light.hh    |   1 +
 .../rendering/ogre2/Ogre2LightVisual.hh       |   1 +
 .../ignition/rendering/ogre2/Ogre2Marker.hh   |   1 +
 .../ignition/rendering/ogre2/Ogre2Material.hh |   1 +
 .../rendering/ogre2/Ogre2MaterialSwitcher.hh  |   1 +
 .../ignition/rendering/ogre2/Ogre2Mesh.hh     |   1 +
 .../rendering/ogre2/Ogre2MeshFactory.hh       |   1 +
 .../ignition/rendering/ogre2/Ogre2Node.hh     |   1 +
 .../ignition/rendering/ogre2/Ogre2Object.hh   |   1 +
 .../rendering/ogre2/Ogre2ObjectInterface.hh   |   1 +
 .../rendering/ogre2/Ogre2ParticleEmitter.hh   |   1 +
 .../ignition/rendering/ogre2/Ogre2RayQuery.hh |   1 +
 .../rendering/ogre2/Ogre2RenderEngine.hh      |   1 +
 .../rendering/ogre2/Ogre2RenderPass.hh        |   1 +
 .../rendering/ogre2/Ogre2RenderTarget.hh      |   1 +
 .../ogre2/Ogre2RenderTargetMaterial.hh        |   1 +
 .../rendering/ogre2/Ogre2RenderTypes.hh       |   1 +
 .../ignition/rendering/ogre2/Ogre2Scene.hh    |   1 +
 .../ogre2/Ogre2SegmentationCamera.hh          |   1 +
 .../rendering/ogre2/Ogre2SelectionBuffer.hh   |   1 +
 .../ignition/rendering/ogre2/Ogre2Sensor.hh   |   1 +
 .../ignition/rendering/ogre2/Ogre2Storage.hh  |   1 +
 .../rendering/ogre2/Ogre2ThermalCamera.hh     |   1 +
 .../ignition/rendering/ogre2/Ogre2Visual.hh   |   1 +
 .../ignition/rendering/ogre2/Ogre2WireBox.hh  |   1 +
 .../ignition/rendering/ogre2/detail/Export.hh |   1 +
 ogre2/src/CMakeLists.txt                      |  12 +-
 ogre2/src/Ogre2ArrowVisual.cc                 |   4 +-
 ogre2/src/Ogre2AxisVisual.cc                  |   4 +-
 ogre2/src/Ogre2COMVisual.cc                   |  28 +-
 ogre2/src/Ogre2Camera.cc                      |  24 +-
 ogre2/src/Ogre2Capsule.cc                     |  22 +-
 ogre2/src/Ogre2Conversions.cc                 |   4 +-
 ogre2/src/Ogre2DepthCamera.cc                 |  82 +--
 ogre2/src/Ogre2DynamicRenderable.cc           |  50 +-
 ogre2/src/Ogre2GaussianNoisePass.cc           |  20 +-
 ogre2/src/Ogre2Geometry.cc                    |   6 +-
 ogre2/src/Ogre2GizmoVisual.cc                 |   4 +-
 ogre2/src/Ogre2GpuRays.cc                     |  72 +-
 ogre2/src/Ogre2Grid.cc                        |  16 +-
 ogre2/src/Ogre2GzHlmsPbsPrivate.cc            |  12 +-
 ogre2/src/Ogre2GzHlmsPbsPrivate.hh            |  14 +-
 ogre2/src/Ogre2GzHlmsSharedPrivate.cc         |   6 +-
 ogre2/src/Ogre2GzHlmsSharedPrivate.hh         |  18 +-
 .../Ogre2GzHlmsSphericalClipMinDistance.cc    |   4 +-
 .../Ogre2GzHlmsSphericalClipMinDistance.hh    |  16 +-
 ogre2/src/Ogre2GzHlmsTerraPrivate.cc          |  16 +-
 ogre2/src/Ogre2GzHlmsTerraPrivate.hh          |  14 +-
 ogre2/src/Ogre2GzHlmsUnlitPrivate.cc          |  12 +-
 ogre2/src/Ogre2GzHlmsUnlitPrivate.hh          |  14 +-
 ogre2/src/Ogre2Heightmap.cc                   |  36 +-
 ogre2/src/Ogre2InertiaVisual.cc               |  28 +-
 ogre2/src/Ogre2JointVisual.cc                 |   4 +-
 ogre2/src/Ogre2LidarVisual.cc                 |  40 +-
 ogre2/src/Ogre2Light.cc                       |  12 +-
 ogre2/src/Ogre2LightVisual.cc                 |  14 +-
 ogre2/src/Ogre2Marker.cc                      |  52 +-
 ogre2/src/Ogre2Material.cc                    |  50 +-
 ogre2/src/Ogre2MaterialSwitcher.cc            |  22 +-
 ogre2/src/Ogre2Mesh.cc                        |  24 +-
 ogre2/src/Ogre2MeshFactory.cc                 |  56 +-
 ogre2/src/Ogre2Node.cc                        |  24 +-
 ogre2/src/Ogre2Object.cc                      |   8 +-
 ogre2/src/Ogre2ObjectInterface.cc             |   4 +-
 ogre2/src/Ogre2ParticleEmitter.cc             |  54 +-
 ogre2/src/Ogre2ParticleNoiseListener.cc       |  18 +-
 ogre2/src/Ogre2ParticleNoiseListener.hh       |   8 +-
 ogre2/src/Ogre2RayQuery.cc                    |  40 +-
 ogre2/src/Ogre2RenderEngine.cc                |  84 +--
 ogre2/src/Ogre2RenderPass.cc                  |   6 +-
 ogre2/src/Ogre2RenderTarget.cc                |  32 +-
 ogre2/src/Ogre2RenderTargetMaterial.cc        |   4 +-
 ogre2/src/Ogre2Scene.cc                       |  76 +-
 ogre2/src/Ogre2SegmentationCamera.cc          |  42 +-
 .../src/Ogre2SegmentationMaterialSwitcher.cc  |  18 +-
 .../src/Ogre2SegmentationMaterialSwitcher.hh  |  26 +-
 ogre2/src/Ogre2SelectionBuffer.cc             |  26 +-
 ogre2/src/Ogre2Sensor.cc                      |   4 +-
 ogre2/src/Ogre2ThermalCamera.cc               |  74 +-
 ogre2/src/Ogre2Visual.cc                      |  74 +-
 ogre2/src/Ogre2WireBox.cc                     |  20 +-
 .../programs/GLSL/depth_camera_final_fs.glsl  |   2 +-
 .../Metal/depth_camera_final_fs.metal         |   2 +-
 .../gz/rendering/optix/OptixArrowVisual.hh    |   6 +-
 .../gz/rendering/optix/OptixAxisVisual.hh     |   6 +-
 optix/include/gz/rendering/optix/OptixBox.hh  |   6 +-
 .../include/gz/rendering/optix/OptixCamera.hh |   6 +-
 optix/include/gz/rendering/optix/OptixCone.hh |   6 +-
 .../gz/rendering/optix/OptixConversions.hh    |   6 +-
 .../gz/rendering/optix/OptixCylinder.hh       |   6 +-
 .../gz/rendering/optix/OptixGeometry.hh       |   6 +-
 optix/include/gz/rendering/optix/OptixGrid.hh |   6 +-
 .../include/gz/rendering/optix/OptixLight.hh  |  36 +-
 .../gz/rendering/optix/OptixLightManager.hh   |   6 +-
 .../gz/rendering/optix/OptixLightTypes.hh     |   4 +-
 .../gz/rendering/optix/OptixMaterial.hh       |   6 +-
 optix/include/gz/rendering/optix/OptixMesh.hh |   8 +-
 .../gz/rendering/optix/OptixMeshFactory.hh    |  10 +-
 optix/include/gz/rendering/optix/OptixNode.hh |   6 +-
 .../include/gz/rendering/optix/OptixObject.hh |   6 +-
 .../gz/rendering/optix/OptixPrimitive.hh      |   6 +-
 .../gz/rendering/optix/OptixRayTypes.hh       |   4 +-
 .../gz/rendering/optix/OptixRenderEngine.hh   |   8 +-
 .../gz/rendering/optix/OptixRenderTarget.hh   |  10 +-
 .../gz/rendering/optix/OptixRenderTypes.hh    |   4 +-
 .../include/gz/rendering/optix/OptixScene.hh  |   6 +-
 .../include/gz/rendering/optix/OptixSensor.hh |   6 +-
 .../include/gz/rendering/optix/OptixSphere.hh |   6 +-
 .../gz/rendering/optix/OptixStorage.hh        |   4 +-
 .../gz/rendering/optix/OptixTextureFactory.hh |   6 +-
 .../include/gz/rendering/optix/OptixVisual.hh |   6 +-
 optix/include/ignition/optix.hh               |   1 +
 .../ignition/rendering/optix/Export.hh        |   1 +
 .../rendering/optix/OptixArrowVisual.hh       |   1 +
 .../rendering/optix/OptixAxisVisual.hh        |   1 +
 .../ignition/rendering/optix/OptixBox.hh      |   1 +
 .../ignition/rendering/optix/OptixCamera.hh   |   1 +
 .../ignition/rendering/optix/OptixCone.hh     |   1 +
 .../rendering/optix/OptixConversions.hh       |   1 +
 .../ignition/rendering/optix/OptixCylinder.hh |   1 +
 .../ignition/rendering/optix/OptixGeometry.hh |   1 +
 .../ignition/rendering/optix/OptixGrid.hh     |   1 +
 .../ignition/rendering/optix/OptixIncludes.hh |   1 +
 .../ignition/rendering/optix/OptixLight.hh    |   1 +
 .../rendering/optix/OptixLightManager.hh      |   1 +
 .../rendering/optix/OptixLightTypes.hh        |   1 +
 .../ignition/rendering/optix/OptixMaterial.hh |   1 +
 .../ignition/rendering/optix/OptixMesh.hh     |   1 +
 .../rendering/optix/OptixMeshFactory.hh       |   1 +
 .../ignition/rendering/optix/OptixNode.hh     |   1 +
 .../ignition/rendering/optix/OptixObject.hh   |   1 +
 .../rendering/optix/OptixPrimitive.hh         |   1 +
 .../ignition/rendering/optix/OptixRayTypes.hh |   1 +
 .../rendering/optix/OptixRenderEngine.hh      |   1 +
 .../rendering/optix/OptixRenderTarget.hh      |   1 +
 .../rendering/optix/OptixRenderTypes.hh       |   1 +
 .../ignition/rendering/optix/OptixScene.hh    |   1 +
 .../ignition/rendering/optix/OptixSensor.hh   |   1 +
 .../ignition/rendering/optix/OptixSphere.hh   |   1 +
 .../ignition/rendering/optix/OptixStorage.hh  |   1 +
 .../rendering/optix/OptixTextureFactory.hh    |   1 +
 .../ignition/rendering/optix/OptixVisual.hh   |   1 +
 .../ignition/rendering/optix/detail/Export.hh |   1 +
 .../include/ignition/rendering/optix/optix.hh |   1 +
 optix/src/CMakeLists.txt                      |  12 +-
 optix/src/OptixArrowVisual.cc                 |   4 +-
 optix/src/OptixAxisVisual.cc                  |   4 +-
 optix/src/OptixBox.cc                         |   4 +-
 optix/src/OptixCamera.cc                      |  12 +-
 optix/src/OptixCamera.cu                      |   2 +-
 optix/src/OptixCone.cc                        |   4 +-
 optix/src/OptixConversions.cc                 |   4 +-
 optix/src/OptixCylinder.cc                    |   4 +-
 optix/src/OptixGeometry.cc                    |   8 +-
 optix/src/OptixGrid.cc                        |   8 +-
 optix/src/OptixLight.cc                       |  12 +-
 optix/src/OptixLightManager.cc                |  10 +-
 optix/src/OptixMaterial.cc                    |  16 +-
 optix/src/OptixMaterial.cu                    |   4 +-
 optix/src/OptixMesh.cc                        |  14 +-
 optix/src/OptixMeshFactory.cc                 |  12 +-
 optix/src/OptixMissProgram.cu                 |   2 +-
 optix/src/OptixNode.cc                        |  14 +-
 optix/src/OptixObject.cc                      |   6 +-
 optix/src/OptixPrimitive.cc                   |  14 +-
 optix/src/OptixRenderEngine.cc                |  23 +-
 optix/src/OptixRenderTarget.cc                |  12 +-
 optix/src/OptixScene.cc                       |  48 +-
 optix/src/OptixSensor.cc                      |   4 +-
 optix/src/OptixSphere.cc                      |   4 +-
 optix/src/OptixTextureFactory.cc              |  14 +-
 optix/src/OptixVisual.cc                      |  14 +-
 src/ArrowVisual_TEST.cc                       |  18 +-
 src/AxisVisual_TEST.cc                        |  20 +-
 src/BoundingBox.cc                            |   6 +-
 src/BoundingBox_TEST.cc                       |   4 +-
 src/CMakeLists.txt                            |   2 +-
 src/COMVisual_TEST.cc                         |  26 +-
 src/CameraLens.cc                             |  20 +-
 src/Camera_TEST.cc                            |  32 +-
 src/Capsule_TEST.cc                           |  18 +-
 src/DistortionPass.cc                         |   4 +-
 src/GaussianNoisePass.cc                      |   4 +-
 src/GaussianNoisePass_TEST.cc                 |  18 +-
 src/GizmoVisual_TEST.cc                       |  18 +-
 src/GraphicsAPI.cc                            |   8 +-
 src/Grid_TEST.cc                              |  18 +-
 src/HeightmapDescriptor.cc                    |  10 +-
 src/Heightmap_TEST.cc                         |  40 +-
 src/Image.cc                                  |   4 +-
 src/InertiaVisual_TEST.cc                     |  22 +-
 src/JointVisual_TEST.cc                       |  16 +-
 src/LidarVisual.cc                            |   4 +-
 src/LidarVisual_TEST.cc                       |  20 +-
 src/LightVisual_TEST.cc                       |  16 +-
 src/Light_TEST.cc                             |  16 +-
 src/Marker.cc                                 |   4 +-
 src/Marker_TEST.cc                            |  18 +-
 src/Material_TEST.cc                          |  26 +-
 src/MeshDescriptor.cc                         |  14 +-
 src/MeshDescriptor_TEST.cc                    |  20 +-
 src/Mesh_TEST.cc                              |  30 +-
 src/MoveToHelper.cc                           |  18 +-
 src/MoveToHelper_TEST.cc                      |  16 +-
 src/Node_TEST.cc                              |  18 +-
 src/OrbitViewController.cc                    |  20 +-
 src/OrbitViewController_TEST.cc               |  20 +-
 src/OrthoViewController.cc                    |  20 +-
 src/OrthoViewController_TEST.cc               |  20 +-
 src/ParticleEmitter_TEST.cc                   |  28 +-
 src/PixelFormat.cc                            |   8 +-
 src/PixelFormat_TEST.cc                       |   4 +-
 src/RayQuery_TEST.cc                          |  20 +-
 src/RenderEngineManager.cc                    |  86 ++-
 src/RenderEnginePlugin.cc                     |   6 +-
 src/RenderEngine_TEST.cc                      |  14 +-
 src/RenderPassSystem.cc                       |  10 +-
 src/RenderPassSystem_TEST.cc                  |  18 +-
 src/RenderTarget_TEST.cc                      |  32 +-
 src/RenderingIface.cc                         |  32 +-
 src/RenderingIface_TEST.cc                    |  12 +-
 src/Scene_TEST.cc                             |  36 +-
 src/SegmentationCamera_TEST.cc                |  18 +-
 src/ShaderParam.cc                            |   6 +-
 src/ShaderParam_TEST.cc                       |   4 +-
 src/ShaderParams.cc                           |   8 +-
 src/ShaderParams_TEST.cc                      |   4 +-
 src/ShaderType.cc                             |   8 +-
 src/Text_TEST.cc                              |  18 +-
 src/ThermalCamera_TEST.cc                     |  16 +-
 src/TransformController.cc                    |  56 +-
 src/TransformController_TEST.cc               |  24 +-
 src/Utils.cc                                  |  50 +-
 src/Utils_TEST.cc                             |  28 +-
 src/Visual_TEST.cc                            |  50 +-
 src/WireBox.cc                                |   4 +-
 src/WireBox_TEST.cc                           |  22 +-
 src/base/BaseObject.cc                        |   4 +-
 src/base/BaseRenderEngine.cc                  |  22 +-
 src/base/BaseScene.cc                         |  81 +--
 .../media/materials/textures/CMakeLists.txt   |   2 +-
 .../all_symbols_have_version.bash.in          |   4 +-
 test/integration/camera.cc                    |  46 +-
 test/integration/deprecated_TEST.cc           |  32 +
 test/integration/depth_camera.cc              | 124 ++--
 test/integration/gpu_rays.cc                  | 148 ++--
 test/integration/lidar_visual.cc              |  82 +--
 test/integration/render_pass.cc               |  68 +-
 test/integration/scene.cc                     |  28 +-
 test/integration/segmentation_camera.cc       |  38 +-
 test/integration/shadows.cc                   |  24 +-
 test/integration/sky.cc                       |  26 +-
 test/integration/thermal_camera.cc            | 120 ++--
 test/integration/wide_angle_camera.cc         |  64 +-
 test/performance/scene_factory.cc             |  22 +-
 test/test_config.h.in                         |  12 +-
 tutorials/01_intro.md                         |  10 +-
 tutorials/02_install.md                       |  16 +-
 tutorials/03_rendering_plugins.md             |  22 +-
 tutorials/04_lightmap.md                      |   8 +-
 tutorials/10_actor_animation_tutorial.md      |   4 +-
 tutorials/11_gazebo_scene_viewer_tutorial.md  |   4 +-
 tutorials/12_mesh_viewer_tutorial.md          |   2 +-
 tutorials/13_custom_scene_viewer.md           |   4 +-
 tutorials/14_camera_tracking_tutorial.md      |   6 +-
 tutorials/15_custom_shaders_tutorial.md       |   2 +-
 tutorials/17_render_pass_tutorial.md          |   2 +-
 tutorials/18_simple_demo_tutorial.md          |   2 +-
 tutorials/19_text_geom_tutorial.md            |   2 +-
 tutorials/20_particles_tutorial.md            |   2 +-
 tutorials/21_heightmap.md                     |   2 +-
 tutorials/21_render_order.md                  |   2 +-
 tutorials/22_environment_map.md               |   2 +-
 tutorials/23_depth_camera_tutorial.md         |   4 +-
 774 files changed, 4711 insertions(+), 4367 deletions(-)
 create mode 100644 test/integration/deprecated_TEST.cc

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b0c7777d7..dc56d529b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -105,7 +105,7 @@ endif()
 #--------------------------------------
 # Find OGRE2: first try to find OGRE2 built with PlanarReflections support and
 # fallback to look for OGRE2 without it. Both seems to works for ign-rendering.
-# See https://github.com/ignitionrobotics/ign-rendering/issues/597
+# See https://github.com/gazebosim/gz-rendering/issues/597
 ign_find_package(IgnOGRE2 VERSION 2.2.0
     COMPONENTS HlmsPbs HlmsUnlit Overlay PlanarReflections
     PRIVATE_FOR ogre2
@@ -124,7 +124,7 @@ if (OGRE2_FOUND)
 endif()
 
 # Plugin install dirs
-set(IGNITION_RENDERING_ENGINE_INSTALL_DIR
+set(GZ_RENDERING_ENGINE_INSTALL_DIR
   ${CMAKE_INSTALL_PREFIX}/${IGN_LIB_INSTALL_DIR}/ign-${IGN_DESIGNATION}-${PROJECT_VERSION_MAJOR}/engine-plugins
 )
 
@@ -149,12 +149,12 @@ endif()
 #####################################
 # Define compile-time default variables
 if(MSVC)
-  set(IGN_RENDERING_PLUGIN_PATH ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR})
+  set(GZ_RENDERING_PLUGIN_PATH ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_BINDIR})
 else()
-  set(IGN_RENDERING_PLUGIN_PATH ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})
+  set(GZ_RENDERING_PLUGIN_PATH ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})
 endif()
 
-set(IGN_RENDERING_RESOURCE_PATH ${CMAKE_INSTALL_PREFIX}/${IGN_DATA_INSTALL_DIR})
+set(GZ_RENDERING_RESOURCE_PATH ${CMAKE_INSTALL_PREFIX}/${IGN_DATA_INSTALL_DIR})
 
 #============================================================================
 # Configure the build
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 147239ce5..a1c121ea4 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -1 +1 @@
-See the [Ignition Robotics contributing guide](https://ignitionrobotics.org/docs/all/contributing).
+See the [Gazebo contributing guide](https://gazebosim.org/docs/all/contributing).
diff --git a/Changelog.md b/Changelog.md
index e574e6287..a67a3c965 100644
--- a/Changelog.md
+++ b/Changelog.md
@@ -1,715 +1,715 @@
-## Ignition Rendering
+## Gazebo Rendering
 
-### Ignition Rendering 7.X
+### Gazebo Rendering 7.X
 
-### Ignition Rendering 7.0.0 (202X-XX-XX)
+### Gazebo Rendering 7.0.0 (202X-XX-XX)
 
-### Ignition Rendering 6.X
+### Gazebo Rendering 6.X
 
-### Ignition Rendering 6.3.1 (2022-04-13)
+### Gazebo Rendering 6.3.1 (2022-04-13)
 
 1.  Revert OGRE-Next custom support and back to use IgnOGRE2 module
-    * [Pull request #605](https://github.com/ignitionrobotics/ign-rendering/pull/605)
+    * [Pull request #605](https://github.com/gazebosim/gz-rendering/pull/605)
 
-### Ignition Rendering 6.3.0 (2022-04-06)
+### Gazebo Rendering 6.3.0 (2022-04-06)
 
 1. Flip heightmap's Y position on Ogre 2 and add sanity checks for NaN
-    * [Pull request #585](https://github.com/ignitionrobotics/ign-rendering/pull/585)
+    * [Pull request #585](https://github.com/gazebosim/gz-rendering/pull/585)
 
 1. Use custom simulation time variants for Ogre
-    * [Pull request #584](https://github.com/ignitionrobotics/ign-rendering/pull/584)
+    * [Pull request #584](https://github.com/gazebosim/gz-rendering/pull/584)
 
 1. Add Ubuntu Jammy CI
-    * [Pull request #577](https://github.com/ignitionrobotics/ign-rendering/pull/577)
+    * [Pull request #577](https://github.com/gazebosim/gz-rendering/pull/577)
 
 1. Fix shaders for other sensors that require material switching (ogre2)
-    * [Pull request #579](https://github.com/ignitionrobotics/ign-rendering/pull/579)
+    * [Pull request #579](https://github.com/gazebosim/gz-rendering/pull/579)
 
 1. fix render pass demo
-    * [Pull request #576](https://github.com/ignitionrobotics/ign-rendering/pull/576)
+    * [Pull request #576](https://github.com/gazebosim/gz-rendering/pull/576)
 
 1. Fix objects using shaders when there is a lidar in the scene (ogre2)
-    * [Pull request #575](https://github.com/ignitionrobotics/ign-rendering/pull/575)
+    * [Pull request #575](https://github.com/gazebosim/gz-rendering/pull/575)
 
 1. Do not set shader constants for textures on non-OpenGL graphics API
-    * [Pull request #574](https://github.com/ignitionrobotics/ign-rendering/pull/574)
+    * [Pull request #574](https://github.com/gazebosim/gz-rendering/pull/574)
 
 1. Use pose multiplication instead of addition
-    * [Pull request #573](https://github.com/ignitionrobotics/ign-rendering/pull/573)
+    * [Pull request #573](https://github.com/gazebosim/gz-rendering/pull/573)
 
 1. Fix sky background compositor setup
-    * [Pull request #571](https://github.com/ignitionrobotics/ign-rendering/pull/571)
+    * [Pull request #571](https://github.com/gazebosim/gz-rendering/pull/571)
 
 1. Backport OgreRTShaderSystem segfault fix
-    * [Pull request #570](https://github.com/ignitionrobotics/ign-rendering/pull/570)
+    * [Pull request #570](https://github.com/gazebosim/gz-rendering/pull/570)
 
 1. Remove unnecessary error message when headless rendering is enabled
-    * [Pull request #569](https://github.com/ignitionrobotics/ign-rendering/pull/569)
+    * [Pull request #569](https://github.com/gazebosim/gz-rendering/pull/569)
 
-### Ignition Rendering 6.2.1 (2022-02-24)
+### Gazebo Rendering 6.2.1 (2022-02-24)
 
 1. Restore format conversion in Ogre2RenderTarget::Copy
-    * [Pull request #564](https://github.com/ignitionrobotics/ign-rendering/pull/564)
+    * [Pull request #564](https://github.com/gazebosim/gz-rendering/pull/564)
 
 1. Increase particle emitter quota
-    * [Pull request #562](https://github.com/ignitionrobotics/ign-rendering/pull/562)
+    * [Pull request #562](https://github.com/gazebosim/gz-rendering/pull/562)
 
 1. Make sure shader param exists before setting its value
-    * [Pull request #558](https://github.com/ignitionrobotics/ign-rendering/pull/558)
+    * [Pull request #558](https://github.com/gazebosim/gz-rendering/pull/558)
 
 1. Backport wave changes
-    * [Pull request #557](https://github.com/ignitionrobotics/ign-rendering/pull/557)
+    * [Pull request #557](https://github.com/gazebosim/gz-rendering/pull/557)
 
-### Ignition Rendering 6.2.0 (2022-01-28)
+### Gazebo Rendering 6.2.0 (2022-01-28)
 
 1. Fix missing terrain shadows casted on objects
-    * [Pull request #547](https://github.com/ignitionrobotics/ign-rendering/pull/547)
+    * [Pull request #547](https://github.com/gazebosim/gz-rendering/pull/547)
 
 1. Add waves
-    * [Pull request #541](https://github.com/ignitionrobotics/ign-rendering/pull/541)
+    * [Pull request #541](https://github.com/gazebosim/gz-rendering/pull/541)
 
 1. Fix crash when hovering the cursor in heightmap.sdf
-    * [Pull request #536](https://github.com/ignitionrobotics/ign-rendering/pull/536)
+    * [Pull request #536](https://github.com/gazebosim/gz-rendering/pull/536)
 
 1. Fix material switching for objects using shaders (ogre2)
-    * [Pull request #533](https://github.com/ignitionrobotics/ign-rendering/pull/533)
+    * [Pull request #533](https://github.com/gazebosim/gz-rendering/pull/533)
 
 1. [Metal] Fix depth camera
-    * [Pull request #535](https://github.com/ignitionrobotics/ign-rendering/pull/535)
+    * [Pull request #535](https://github.com/gazebosim/gz-rendering/pull/535)
     * A contribution from Rhys Mainwaring <rhys.mainwaring@me.com>
 
 1. Bind shader uniforms to constants from ogre
-    * [Pull request #531](https://github.com/ignitionrobotics/ign-rendering/pull/531)
+    * [Pull request #531](https://github.com/gazebosim/gz-rendering/pull/531)
 
 1. Silence CMake policy CMP0072
-    * [Pull request #528](https://github.com/ignitionrobotics/ign-rendering/pull/528)
+    * [Pull request #528](https://github.com/gazebosim/gz-rendering/pull/528)
 
 1. Fix various issues with Ogre2GpuRays
-    * [Pull request #522](https://github.com/ignitionrobotics/ign-rendering/pull/522)
-    * [Pull request #527](https://github.com/ignitionrobotics/ign-rendering/pull/527)
+    * [Pull request #522](https://github.com/gazebosim/gz-rendering/pull/522)
+    * [Pull request #527](https://github.com/gazebosim/gz-rendering/pull/527)
 
 1. Fix Ogre2ThermalCamera using garbage depth data
-    * [Pull request #523](https://github.com/ignitionrobotics/ign-rendering/pull/523)
+    * [Pull request #523](https://github.com/gazebosim/gz-rendering/pull/523)
 
 1. Performance optimization by avoiding unnecessary passes
-    * [Pull request #524](https://github.com/ignitionrobotics/ign-rendering/pull/524)
+    * [Pull request #524](https://github.com/gazebosim/gz-rendering/pull/524)
 
 1. Support using custom shader materials and updating uniform variables (ogre2)
-    * [Pull request #520](https://github.com/ignitionrobotics/ign-rendering/pull/520)
+    * [Pull request #520](https://github.com/gazebosim/gz-rendering/pull/520)
 
 1. Port Camera Distortion effect from gazebo11
-    * [Pull request #502](https://github.com/ignitionrobotics/ign-rendering/pull/502)
+    * [Pull request #502](https://github.com/gazebosim/gz-rendering/pull/502)
 
 1. Fix sky background in RGBD camera
-    * [Pull request #515](https://github.com/ignitionrobotics/ign-rendering/pull/515)
+    * [Pull request #515](https://github.com/gazebosim/gz-rendering/pull/515)
 
 1. RenderOrder is in different scale in Reverse Z
-    * [Pull request #514](https://github.com/ignitionrobotics/ign-rendering/pull/514)
+    * [Pull request #514](https://github.com/gazebosim/gz-rendering/pull/514)
 
-### Ignition Rendering 6.1.0 (2021-12-09)
+### Gazebo Rendering 6.1.0 (2021-12-09)
 
 1. Check for OpenGL backend before calling GL APIs
-    * [Pull request #509](https://github.com/ignitionrobotics/ign-rendering/pull/509)
+    * [Pull request #509](https://github.com/gazebosim/gz-rendering/pull/509)
 
 1. Fix loading grayscale emissive map
-    * [Pull request #503](https://github.com/ignitionrobotics/ign-rendering/pull/503)
-    * [Pull request #501](https://github.com/ignitionrobotics/ign-rendering/pull/501)
+    * [Pull request #503](https://github.com/gazebosim/gz-rendering/pull/503)
+    * [Pull request #501](https://github.com/gazebosim/gz-rendering/pull/501)
 
 1. Fixes to selection buffer
-    * [Pull request #446](https://github.com/ignitionrobotics/ign-rendering/pull/446)
-    * [Pull request #510](https://github.com/ignitionrobotics/ign-rendering/pull/510)
-    * [Pull request #498](https://github.com/ignitionrobotics/ign-rendering/pull/498)
+    * [Pull request #446](https://github.com/gazebosim/gz-rendering/pull/446)
+    * [Pull request #510](https://github.com/gazebosim/gz-rendering/pull/510)
+    * [Pull request #498](https://github.com/gazebosim/gz-rendering/pull/498)
 
 1. Add Metal support for the Ogre2 Render Engine
-    * [Pull request #463](https://github.com/ignitionrobotics/ign-rendering/pull/463)
+    * [Pull request #463](https://github.com/gazebosim/gz-rendering/pull/463)
 
 1. Add a depth camera example
-    * [Pull request #467](https://github.com/ignitionrobotics/ign-rendering/pull/467)
+    * [Pull request #467](https://github.com/gazebosim/gz-rendering/pull/467)
 
 1. More nullptr checking on visuals and base axis
-    * [Pull request #486](https://github.com/ignitionrobotics/ign-rendering/pull/486)
+    * [Pull request #486](https://github.com/gazebosim/gz-rendering/pull/486)
 
 1. Fix Utils unit test
-    * [Pull request #481](https://github.com/ignitionrobotics/ign-rendering/pull/481)
+    * [Pull request #481](https://github.com/gazebosim/gz-rendering/pull/481)
 
 1. Fix context attributes of glXCreateContextAttribsARB.
-    * [Pull request #460](https://github.com/ignitionrobotics/ign-rendering/pull/460)
+    * [Pull request #460](https://github.com/gazebosim/gz-rendering/pull/460)
 
 1. [Ogre2] fix invalid anti-aliasing level warning
-    * [Pull request #470](https://github.com/ignitionrobotics/ign-rendering/pull/470)
+    * [Pull request #470](https://github.com/gazebosim/gz-rendering/pull/470)
 
 1. Avoid symbol redefinition to fix armel builds
-    * [Pull request #457](https://github.com/ignitionrobotics/ign-rendering/pull/457)
+    * [Pull request #457](https://github.com/gazebosim/gz-rendering/pull/457)
 
 1. fix grayscale albedo map
-    * [Pull request #466](https://github.com/ignitionrobotics/ign-rendering/pull/466)
+    * [Pull request #466](https://github.com/gazebosim/gz-rendering/pull/466)
 
 1. Fix selection buffer material script
-    * [Pull request #456](https://github.com/ignitionrobotics/ign-rendering/pull/456)
+    * [Pull request #456](https://github.com/gazebosim/gz-rendering/pull/456)
 
 1. [macOS] modify definition of bufferFetch1 to work when GL_ARB_texture_buffer_range is not available
-    * [Pull request #462](https://github.com/ignitionrobotics/ign-rendering/pull/462)
+    * [Pull request #462](https://github.com/gazebosim/gz-rendering/pull/462)
 
 1. Fix compilation against Ogre 1.10.12
-    * [Pull request #390](https://github.com/ignitionrobotics/ign-rendering/pull/390)
+    * [Pull request #390](https://github.com/gazebosim/gz-rendering/pull/390)
 
 1. Fix logic on warning for ogre versions different than 1.9.x
-    * [Pull request #465](https://github.com/ignitionrobotics/ign-rendering/pull/465)
+    * [Pull request #465](https://github.com/gazebosim/gz-rendering/pull/465)
 
 1. Fix point cloud material syntax error
-    * [Pull request #433](https://github.com/ignitionrobotics/ign-rendering/pull/433)
+    * [Pull request #433](https://github.com/gazebosim/gz-rendering/pull/433)
 
 1. Run ogre2 particles by default
-    * [Pull request #430](https://github.com/ignitionrobotics/ign-rendering/pull/430)
+    * [Pull request #430](https://github.com/gazebosim/gz-rendering/pull/430)
 
 1. Ogre: Do not assume that ogre plugins have lib prefix on macOS
-    * [Pull request #454](https://github.com/ignitionrobotics/ign-rendering/pull/454)
+    * [Pull request #454](https://github.com/gazebosim/gz-rendering/pull/454)
 
 1. Fix heightmap crash if only shadow casting spotlights are one scene
-    * [Pull request #451](https://github.com/ignitionrobotics/ign-rendering/pull/451)
+    * [Pull request #451](https://github.com/gazebosim/gz-rendering/pull/451)
 
 1. Added macOS instructions
-    * [Pull request #448](https://github.com/ignitionrobotics/ign-rendering/pull/448)
+    * [Pull request #448](https://github.com/gazebosim/gz-rendering/pull/448)
 
 1. Ogre: Add missing required Paging component
-    * [Pull request #452](https://github.com/ignitionrobotics/ign-rendering/pull/452)
+    * [Pull request #452](https://github.com/gazebosim/gz-rendering/pull/452)
 
 1. Fix ray query distance calculation
-    * [Pull request #438](https://github.com/ignitionrobotics/ign-rendering/pull/438)
+    * [Pull request #438](https://github.com/gazebosim/gz-rendering/pull/438)
 
-### Ignition Rendering 6.0.1 (2021-10-01)
+### Gazebo Rendering 6.0.1 (2021-10-01)
 
 1. Disable using selection buffer for ray queries
-    * [Pull request #447](https://github.com/ignitionrobotics/ign-rendering/pull/447)
+    * [Pull request #447](https://github.com/gazebosim/gz-rendering/pull/447)
 
-### Ignition Rendering 6.0.0 (2021-09-30)
+### Gazebo Rendering 6.0.0 (2021-09-30)
 
 1. Avoid configure warning when checking ogre-1.10
-    * [Pull request #411](https://github.com/ignitionrobotics/ign-rendering/pull/411)
-    * [Pull request #413](https://github.com/ignitionrobotics/ign-rendering/pull/413)
+    * [Pull request #411](https://github.com/gazebosim/gz-rendering/pull/411)
+    * [Pull request #413](https://github.com/gazebosim/gz-rendering/pull/413)
 
 1. Use selection buffer in ray queries (ogre2)
-    * [Pull request #378](https://github.com/ignitionrobotics/ign-rendering/pull/378)
+    * [Pull request #378](https://github.com/gazebosim/gz-rendering/pull/378)
 
 1. Fix particle effect randomness
-    * [Pull request #388](https://github.com/ignitionrobotics/ign-rendering/pull/388)
+    * [Pull request #388](https://github.com/gazebosim/gz-rendering/pull/388)
 
 1. Update test config to run ogre 1.x tests in ign-rendering6 on macOS
-    * [Pull request #407](https://github.com/ignitionrobotics/ign-rendering/pull/407)
-    * [Pull request #409](https://github.com/ignitionrobotics/ign-rendering/pull/409)
-    * [Pull request #409](https://github.com/ignitionrobotics/ign-rendering/pull/409)
+    * [Pull request #407](https://github.com/gazebosim/gz-rendering/pull/407)
+    * [Pull request #409](https://github.com/gazebosim/gz-rendering/pull/409)
+    * [Pull request #409](https://github.com/gazebosim/gz-rendering/pull/409)
 
 1. Clone visuals and geometries
-    * [Pull request #397](https://github.com/ignitionrobotics/ign-rendering/pull/397)
-    * [Pull request #434](https://github.com/ignitionrobotics/ign-rendering/pull/434)
+    * [Pull request #397](https://github.com/gazebosim/gz-rendering/pull/397)
+    * [Pull request #434](https://github.com/gazebosim/gz-rendering/pull/434)
 
 1. Add SetSize API for LidarVisual and markers
-    * [Pull request #392](https://github.com/ignitionrobotics/ign-rendering/pull/392)
+    * [Pull request #392](https://github.com/gazebosim/gz-rendering/pull/392)
 
 1. Add Ogre2Heightmap functionality
-    * [Pull request #386](https://github.com/ignitionrobotics/ign-rendering/pull/386)
-    * [Pull request #416](https://github.com/ignitionrobotics/ign-rendering/pull/416)
+    * [Pull request #386](https://github.com/gazebosim/gz-rendering/pull/386)
+    * [Pull request #416](https://github.com/gazebosim/gz-rendering/pull/416)
 
 1. Prevent default-constructed variants from holding a type
-    * [Pull request #371](https://github.com/ignitionrobotics/ign-rendering/pull/371)
-    * [Pull request #396](https://github.com/ignitionrobotics/ign-rendering/pull/396)
+    * [Pull request #371](https://github.com/gazebosim/gz-rendering/pull/371)
+    * [Pull request #396](https://github.com/gazebosim/gz-rendering/pull/396)
 
 1. Temporarily set number of camera pass count per flush to 0 in ogre2 to prevent downstream build failures
-    * [Pull request #367](https://github.com/ignitionrobotics/ign-rendering/pull/367)
+    * [Pull request #367](https://github.com/gazebosim/gz-rendering/pull/367)
 
 1. New visuals
     1. Joint visual
-        * [Pull request #366](https://github.com/ignitionrobotics/ign-rendering/pull/366)
-        * [Pull request #387](https://github.com/ignitionrobotics/ign-rendering/pull/387)
+        * [Pull request #366](https://github.com/gazebosim/gz-rendering/pull/366)
+        * [Pull request #387](https://github.com/gazebosim/gz-rendering/pull/387)
 
     1. Center of mass visual
-        * [Pull request #345](https://github.com/ignitionrobotics/ign-rendering/pull/345)
+        * [Pull request #345](https://github.com/gazebosim/gz-rendering/pull/345)
 
     1. Inertia visual
-        * [Pull request #326](https://github.com/ignitionrobotics/ign-rendering/pull/326)
+        * [Pull request #326](https://github.com/gazebosim/gz-rendering/pull/326)
 
 1. UserData methods moved from Visual to Node
-    * [Pull request #358](https://github.com/ignitionrobotics/ign-rendering/pull/358)
+    * [Pull request #358](https://github.com/gazebosim/gz-rendering/pull/358)
 
 1. Replace renderOneFrame for per-workspace update calls
-    * [Pull request #353](https://github.com/ignitionrobotics/ign-rendering/pull/353)
+    * [Pull request #353](https://github.com/gazebosim/gz-rendering/pull/353)
 
 1. Segmentation Camera
-    * [Pull request #329](https://github.com/ignitionrobotics/ign-rendering/pull/329)
-    * [Pull request #419](https://github.com/ignitionrobotics/ign-rendering/pull/419)
-    * [Pull request #443](https://github.com/ignitionrobotics/ign-rendering/pull/443)
+    * [Pull request #329](https://github.com/gazebosim/gz-rendering/pull/329)
+    * [Pull request #419](https://github.com/gazebosim/gz-rendering/pull/419)
+    * [Pull request #443](https://github.com/gazebosim/gz-rendering/pull/443)
 
 1. Stub bounding box camera APIs
-    * [Pull request #420](https://github.com/ignitionrobotics/ign-rendering/pull/420)
+    * [Pull request #420](https://github.com/gazebosim/gz-rendering/pull/420)
 
 1. Changed calculation for range clipping
-    * [Pull request #325](https://github.com/ignitionrobotics/ign-rendering/pull/325)
+    * [Pull request #325](https://github.com/gazebosim/gz-rendering/pull/325)
 
 1. Destroy material when a mesh is deleted
-    * [Pull request #324](https://github.com/ignitionrobotics/ign-rendering/pull/324)
+    * [Pull request #324](https://github.com/gazebosim/gz-rendering/pull/324)
 
 1. Add orthographic view controller
-    * [Pull request #322](https://github.com/ignitionrobotics/ign-rendering/pull/322)
-    * [Pull request #361](https://github.com/ignitionrobotics/ign-rendering/pull/361)
+    * [Pull request #322](https://github.com/gazebosim/gz-rendering/pull/322)
+    * [Pull request #361](https://github.com/gazebosim/gz-rendering/pull/361)
 
 1. Visualize wireframes
-    * [Pull request #314](https://github.com/ignitionrobotics/ign-rendering/pull/314)
+    * [Pull request #314](https://github.com/gazebosim/gz-rendering/pull/314)
 
 1. Add environment map tutorial
-    * [Pull request #295](https://github.com/ignitionrobotics/ign-rendering/pull/295)
+    * [Pull request #295](https://github.com/gazebosim/gz-rendering/pull/295)
 
 1. From Ogre 2.1 to Ogre 2.2
-    * [Pull request #272](https://github.com/ignitionrobotics/ign-rendering/pull/272)
-    * [Pull request #393](https://github.com/ignitionrobotics/ign-rendering/pull/393)
-    * [Pull request #436](https://github.com/ignitionrobotics/ign-rendering/pull/436)
-    * [Pull request #426](https://github.com/ignitionrobotics/ign-rendering/pull/426)
-    * [Pull request #440](https://github.com/ignitionrobotics/ign-rendering/pull/440)
+    * [Pull request #272](https://github.com/gazebosim/gz-rendering/pull/272)
+    * [Pull request #393](https://github.com/gazebosim/gz-rendering/pull/393)
+    * [Pull request #436](https://github.com/gazebosim/gz-rendering/pull/436)
+    * [Pull request #426](https://github.com/gazebosim/gz-rendering/pull/426)
+    * [Pull request #440](https://github.com/gazebosim/gz-rendering/pull/440)
 
 1. Documentation updates
-    * [Pull request #425](https://github.com/ignitionrobotics/ign-rendering/pull/425)
-    * [Pull request #431](https://github.com/ignitionrobotics/ign-rendering/pull/431)
+    * [Pull request #425](https://github.com/gazebosim/gz-rendering/pull/425)
+    * [Pull request #431](https://github.com/gazebosim/gz-rendering/pull/431)
 
 1. Infrastructure
-    * [Pull request #318](https://github.com/ignitionrobotics/ign-rendering/pull/318)
+    * [Pull request #318](https://github.com/gazebosim/gz-rendering/pull/318)
 
-### Ignition Rendering 5.2.1 (2022-03-35)
+### Gazebo Rendering 5.2.1 (2022-03-35)
 
 1. Silence CMake policy CMP0072
-    * [Pull request #528](https://github.com/ignitionrobotics/ign-rendering/pull/528)
+    * [Pull request #528](https://github.com/gazebosim/gz-rendering/pull/528)
 
-### Ignition Rendering 5.2.0 (2021-11-02)
+### Gazebo Rendering 5.2.0 (2021-11-02)
 
 1. Fix context attributes of glXCreateContextAttribsARB.
-    * [Pull request #460](https://github.com/ignitionrobotics/ign-rendering/pull/460)
+    * [Pull request #460](https://github.com/gazebosim/gz-rendering/pull/460)
 
 1. Fix logic on warning for ogre versions different than 1.9.x
-    * [Pull request #465](https://github.com/ignitionrobotics/ign-rendering/pull/465)
+    * [Pull request #465](https://github.com/gazebosim/gz-rendering/pull/465)
 
 1. Avoid symbol redefition to fix armel builds
-    * [Pull request #457](https://github.com/ignitionrobotics/ign-rendering/pull/457)
+    * [Pull request #457](https://github.com/gazebosim/gz-rendering/pull/457)
 
 1. Fix selection buffer material script
-    * [Pull request #456](https://github.com/ignitionrobotics/ign-rendering/pull/456)
+    * [Pull request #456](https://github.com/gazebosim/gz-rendering/pull/456)
 
 1. Fix compilation against Ogre 1.10.12
-    * [Pull request #390](https://github.com/ignitionrobotics/ign-rendering/pull/390)
+    * [Pull request #390](https://github.com/gazebosim/gz-rendering/pull/390)
 
 1. ogre: Do not assume that ogre plugins have lib prefix on macOS
-    * [Pull request #454](https://github.com/ignitionrobotics/ign-rendering/pull/454)
+    * [Pull request #454](https://github.com/gazebosim/gz-rendering/pull/454)
 
 1. ogre: Add missing required Paging component
-    * [Pull request #452](https://github.com/ignitionrobotics/ign-rendering/pull/452)
+    * [Pull request #452](https://github.com/gazebosim/gz-rendering/pull/452)
 
 1. Fix ray query distance calculation
-    * [Pull request #438](https://github.com/ignitionrobotics/ign-rendering/pull/438)
+    * [Pull request #438](https://github.com/gazebosim/gz-rendering/pull/438)
 
 1. Fix the spelling of USE_UNOFFICIAL_OGRE_VERSIONS flag
-    * [Pull request #413](https://github.com/ignitionrobotics/ign-rendering/pull/413)
+    * [Pull request #413](https://github.com/gazebosim/gz-rendering/pull/413)
 
 1. Avoid configure warning when checking ogre-1.10
-    * [Pull request #411](https://github.com/ignitionrobotics/ign-rendering/pull/411)
+    * [Pull request #411](https://github.com/gazebosim/gz-rendering/pull/411)
 
 1. Use selection buffer in ray queries (ogre2)
-    * [Pull request #378](https://github.com/ignitionrobotics/ign-rendering/pull/378)
+    * [Pull request #378](https://github.com/gazebosim/gz-rendering/pull/378)
 
 1. Fix particle effect randomness
-    * [Pull request #388](https://github.com/ignitionrobotics/ign-rendering/pull/388)
+    * [Pull request #388](https://github.com/gazebosim/gz-rendering/pull/388)
 
 1. Update simple_demo_qml coding style
-    * [Pull request #404](https://github.com/ignitionrobotics/ign-rendering/pull/404)
+    * [Pull request #404](https://github.com/gazebosim/gz-rendering/pull/404)
 
 1. Disabling flaky depth and thermal camera tests on mac
-    * [Pull request #405](https://github.com/ignitionrobotics/ign-rendering/pull/405)
+    * [Pull request #405](https://github.com/gazebosim/gz-rendering/pull/405)
 
 1. [macOS] add a QML version of simple_demo
-    * [Pull request #373](https://github.com/ignitionrobotics/ign-rendering/pull/373)
+    * [Pull request #373](https://github.com/gazebosim/gz-rendering/pull/373)
 
 1. Fix single ray gpu lidar
-    * [Pull request #384](https://github.com/ignitionrobotics/ign-rendering/pull/384)
+    * [Pull request #384](https://github.com/gazebosim/gz-rendering/pull/384)
 
 1. Warn about non-existent submesh
-    * [Pull request #391](https://github.com/ignitionrobotics/ign-rendering/pull/391)
+    * [Pull request #391](https://github.com/gazebosim/gz-rendering/pull/391)
 
 1. Improved doxygen
-    * [Pull request #398](https://github.com/ignitionrobotics/ign-rendering/pull/398)
-    * [Pull request #389](https://github.com/ignitionrobotics/ign-rendering/pull/389)
+    * [Pull request #398](https://github.com/gazebosim/gz-rendering/pull/398)
+    * [Pull request #389](https://github.com/gazebosim/gz-rendering/pull/389)
 
 1. Set OGRE minimal version to 1.8. Warn on versions not supported (ign-rendering3)
-    * [Pull request #376](https://github.com/ignitionrobotics/ign-rendering/pull/376)
+    * [Pull request #376](https://github.com/gazebosim/gz-rendering/pull/376)
 
 1. 👩‍🌾 Remove bitbucket-pipelines.yml
-    * [Pull request #385](https://github.com/ignitionrobotics/ign-rendering/pull/385)
+    * [Pull request #385](https://github.com/gazebosim/gz-rendering/pull/385)
 
 1. [macOS] support OpenGL < 4.2 in PBS shader
-    * [Pull request #377](https://github.com/ignitionrobotics/ign-rendering/pull/377)
+    * [Pull request #377](https://github.com/gazebosim/gz-rendering/pull/377)
 
 1. Moved ScreenToPlane and ScreenToScene from ign-gui to ign-rendering
-    * [Pull request #363](https://github.com/ignitionrobotics/ign-rendering/pull/363)
-    * [Pull request #368](https://github.com/ignitionrobotics/ign-rendering/pull/368)
+    * [Pull request #363](https://github.com/gazebosim/gz-rendering/pull/363)
+    * [Pull request #368](https://github.com/gazebosim/gz-rendering/pull/368)
 
 1. More nullptr checking on Node classes
-    * [Pull request #364](https://github.com/ignitionrobotics/ign-rendering/pull/364)
+    * [Pull request #364](https://github.com/gazebosim/gz-rendering/pull/364)
 
-### Ignition Rendering 5.1.0 (2021-06-22)
+### Gazebo Rendering 5.1.0 (2021-06-22)
 
 1. add ifdef for apple in integration test
-    * [Pull request #349](https://github.com/ignitionrobotics/ign-rendering/pull/349)
+    * [Pull request #349](https://github.com/gazebosim/gz-rendering/pull/349)
 
 1. Update light map tutorial
-    * [Pull request #346](https://github.com/ignitionrobotics/ign-rendering/pull/346)
+    * [Pull request #346](https://github.com/gazebosim/gz-rendering/pull/346)
 
 1. relax gaussian test tolerance
-    * [Pull request #344](https://github.com/ignitionrobotics/ign-rendering/pull/344)
+    * [Pull request #344](https://github.com/gazebosim/gz-rendering/pull/344)
 
 1. Fix custom shaders uniforms ign version number
-    * [Pull request #343](https://github.com/ignitionrobotics/ign-rendering/pull/343)
+    * [Pull request #343](https://github.com/gazebosim/gz-rendering/pull/343)
 
 1. recreate node only when needed
-    * [Pull request #342](https://github.com/ignitionrobotics/ign-rendering/pull/342)
+    * [Pull request #342](https://github.com/gazebosim/gz-rendering/pull/342)
 
 1. Backport memory fixes found by ASAN
-    * [Pull request #340](https://github.com/ignitionrobotics/ign-rendering/pull/340)
+    * [Pull request #340](https://github.com/gazebosim/gz-rendering/pull/340)
 
 1. Fix FSAA in UI and lower VRAM consumption
-    * [Pull request #313](https://github.com/ignitionrobotics/ign-rendering/pull/313)
+    * [Pull request #313](https://github.com/gazebosim/gz-rendering/pull/313)
 
 1. Fix depth alpha
-    * [Pull request #316](https://github.com/ignitionrobotics/ign-rendering/pull/316)
+    * [Pull request #316](https://github.com/gazebosim/gz-rendering/pull/316)
 
 1. Fix floating point precision bug handling alpha channel (#332)
-    * [Pull request #333](https://github.com/ignitionrobotics/ign-rendering/pull/333)
+    * [Pull request #333](https://github.com/gazebosim/gz-rendering/pull/333)
 
 1. Fix heap overflow when reading
-    * [Pull request #337](https://github.com/ignitionrobotics/ign-rendering/pull/337)
+    * [Pull request #337](https://github.com/gazebosim/gz-rendering/pull/337)
 
 1. Fix new [] / delete mismatch
-    * [Pull request #338](https://github.com/ignitionrobotics/ign-rendering/pull/338)
+    * [Pull request #338](https://github.com/gazebosim/gz-rendering/pull/338)
 
 1. Test re-enabling depth camera integration test on mac
-    * [Pull request #335](https://github.com/ignitionrobotics/ign-rendering/pull/335)
+    * [Pull request #335](https://github.com/gazebosim/gz-rendering/pull/335)
 
 1. Include MoveTo Helper class to ign-rendering
-    * [Pull request #311](https://github.com/ignitionrobotics/ign-rendering/pull/311)
+    * [Pull request #311](https://github.com/gazebosim/gz-rendering/pull/311)
 
 1. Remove `tools/code_check` and update codecov
-    * [Pull request #321](https://github.com/ignitionrobotics/ign-rendering/pull/321)
+    * [Pull request #321](https://github.com/gazebosim/gz-rendering/pull/321)
 
 1. [OGRE 1.x] Uniform buffer shader support
-    * [Pull request #294](https://github.com/ignitionrobotics/ign-rendering/pull/294)
+    * [Pull request #294](https://github.com/gazebosim/gz-rendering/pull/294)
 
 1. Helper function to get a scene
-    * [Pull request #320](https://github.com/ignitionrobotics/ign-rendering/pull/320)
+    * [Pull request #320](https://github.com/gazebosim/gz-rendering/pull/320)
 
 1. fix capsule mouse picking
-    * [Pull request #319](https://github.com/ignitionrobotics/ign-rendering/pull/319)
+    * [Pull request #319](https://github.com/gazebosim/gz-rendering/pull/319)
 
 1. Fix depth alpha
-    * [Pull request #316](https://github.com/ignitionrobotics/ign-rendering/pull/316)
+    * [Pull request #316](https://github.com/gazebosim/gz-rendering/pull/316)
 
 1. Add shadows to Ogre2DepthCamera without crashing
-    * [Pull request #303](https://github.com/ignitionrobotics/ign-rendering/pull/303)
+    * [Pull request #303](https://github.com/gazebosim/gz-rendering/pull/303)
 
 1. Reduce lidar data discretization
-    * [Pull request #296](https://github.com/ignitionrobotics/ign-rendering/pull/296)
+    * [Pull request #296](https://github.com/gazebosim/gz-rendering/pull/296)
 
 1. update light visual size
-    * [Pull request #306](https://github.com/ignitionrobotics/ign-rendering/pull/306)
+    * [Pull request #306](https://github.com/gazebosim/gz-rendering/pull/306)
 
 1. Improve build times by reducing included headers
-    * [Pull request #299](https://github.com/ignitionrobotics/ign-rendering/pull/299)
+    * [Pull request #299](https://github.com/gazebosim/gz-rendering/pull/299)
 
 1. Add light map tutorial
-    * [Pull request #302](https://github.com/ignitionrobotics/ign-rendering/pull/302)
+    * [Pull request #302](https://github.com/gazebosim/gz-rendering/pull/302)
 
 1. Prevent console warnings when multiple texture coordinates are present
-    * [Pull request #301](https://github.com/ignitionrobotics/ign-rendering/pull/301)
+    * [Pull request #301](https://github.com/gazebosim/gz-rendering/pull/301)
 
 1. Fix gazebo scene viewer build
-    * [Pull request #289](https://github.com/ignitionrobotics/ign-rendering/pull/289)
+    * [Pull request #289](https://github.com/gazebosim/gz-rendering/pull/289)
 
 1. Silence noisy sky error
-    * [Pull request #282](https://github.com/ignitionrobotics/ign-rendering/pull/282)
+    * [Pull request #282](https://github.com/gazebosim/gz-rendering/pull/282)
 
 1. Added command line argument to pick version of Ogre
-    * [Pull request #277](https://github.com/ignitionrobotics/ign-rendering/pull/277)
+    * [Pull request #277](https://github.com/gazebosim/gz-rendering/pull/277)
 
-### Ignition Rendering 5.0.0 (2021-03-30)
+### Gazebo Rendering 5.0.0 (2021-03-30)
 
 1. Add ogre2 skybox support
-    * [Pull request #168](https://github.com/ignitionrobotics/ign-rendering/pull/168)
+    * [Pull request #168](https://github.com/gazebosim/gz-rendering/pull/168)
 
 1. Add light visual support
-    * [Pull request #202](https://github.com/ignitionrobotics/ign-rendering/pull/202)
-    * [Pull request #228](https://github.com/ignitionrobotics/ign-rendering/pull/228)
+    * [Pull request #202](https://github.com/gazebosim/gz-rendering/pull/202)
+    * [Pull request #228](https://github.com/gazebosim/gz-rendering/pull/228)
 
 1. Add API for particle emitter scatter ratio
-    * [Pull request #275](https://github.com/ignitionrobotics/ign-rendering/pull/275)
+    * [Pull request #275](https://github.com/gazebosim/gz-rendering/pull/275)
 
 1. Added capsule geometry
-    * [Pull request #200](https://github.com/ignitionrobotics/ign-rendering/pull/200)
-    * [Pull request #278](https://github.com/ignitionrobotics/ign-rendering/pull/278)
+    * [Pull request #200](https://github.com/gazebosim/gz-rendering/pull/200)
+    * [Pull request #278](https://github.com/gazebosim/gz-rendering/pull/278)
 
 1. Added ellipsoid Geometry
-    * [Pull request #203](https://github.com/ignitionrobotics/ign-rendering/pull/203)
+    * [Pull request #203](https://github.com/gazebosim/gz-rendering/pull/203)
 
 1. ogre2: explicitly request OpenGL 3.3 core profile context.
-    * [Pull request #244](https://github.com/ignitionrobotics/ign-rendering/pull/244)
+    * [Pull request #244](https://github.com/gazebosim/gz-rendering/pull/244)
 
 1. Bump in edifice: ign-common4
-    * [Pull request #209](https://github.com/ignitionrobotics/ign-rendering/pull/209)
+    * [Pull request #209](https://github.com/gazebosim/gz-rendering/pull/209)
 
 1. Support setting horizontal and vertical resolution for GpuRays
-    * [Pull request #229](https://github.com/ignitionrobotics/ign-rendering/pull/229)
+    * [Pull request #229](https://github.com/gazebosim/gz-rendering/pull/229)
 
 1. Added Light Intensity
-    * [Pull request #233](https://github.com/ignitionrobotics/ign-rendering/pull/233)
-    * [Pull request #284](https://github.com/ignitionrobotics/ign-rendering/pull/284)
+    * [Pull request #233](https://github.com/gazebosim/gz-rendering/pull/233)
+    * [Pull request #284](https://github.com/gazebosim/gz-rendering/pull/284)
 
 1. Heightmap for Ogre 1
-    * [Pull request #180](https://github.com/ignitionrobotics/ign-rendering/pull/180)
+    * [Pull request #180](https://github.com/gazebosim/gz-rendering/pull/180)
 
 1. Added render order to material
-    * [Pull request #188](https://github.com/ignitionrobotics/ign-rendering/pull/188)
+    * [Pull request #188](https://github.com/gazebosim/gz-rendering/pull/188)
 
 1. Add support for lightmaps in ogre2
-    * [Pull request #182](https://github.com/ignitionrobotics/ign-rendering/pull/182)
+    * [Pull request #182](https://github.com/gazebosim/gz-rendering/pull/182)
 
 1. Documentation updates
-    * [Pull request #288](https://github.com/ignitionrobotics/ign-rendering/pull/288)
-    * [Pull request #287](https://github.com/ignitionrobotics/ign-rendering/pull/287)
-    * [Pull request #286](https://github.com/ignitionrobotics/ign-rendering/pull/286)
+    * [Pull request #288](https://github.com/gazebosim/gz-rendering/pull/288)
+    * [Pull request #287](https://github.com/gazebosim/gz-rendering/pull/287)
+    * [Pull request #286](https://github.com/gazebosim/gz-rendering/pull/286)
 
-### Ignition Rendering 4.X
+### Gazebo Rendering 4.X
 
-### Ignition Rendering 4.9.0 (2021-09-15)
+### Gazebo Rendering 4.9.0 (2021-09-15)
 
 1. Output warning message if a mesh with zero submeshes is created
-    * [Pull request #391](https://github.com/ignitionrobotics/ign-rendering/pull/391)
+    * [Pull request #391](https://github.com/gazebosim/gz-rendering/pull/391)
 
 1. Fix particle effect randomness
-    * [Pull request #388](https://github.com/ignitionrobotics/ign-rendering/pull/388)
+    * [Pull request #388](https://github.com/gazebosim/gz-rendering/pull/388)
 
 1. Fix single ray gpu lidar
-    * [Pull request #384](https://github.com/ignitionrobotics/ign-rendering/pull/384)
+    * [Pull request #384](https://github.com/gazebosim/gz-rendering/pull/384)
 
 1. Use selection buffer in ray queries (ogre2)
-    * [Pull request #378](https://github.com/ignitionrobotics/ign-rendering/pull/378)
-    * [Pull request #383](https://github.com/ignitionrobotics/ign-rendering/pull/383)
+    * [Pull request #378](https://github.com/gazebosim/gz-rendering/pull/378)
+    * [Pull request #383](https://github.com/gazebosim/gz-rendering/pull/383)
 
 1. All changes merged forward from ign-rendering3
-    * [Pull request #382](https://github.com/ignitionrobotics/ign-rendering/pull/382)
-    * [Pull request #398](https://github.com/ignitionrobotics/ign-rendering/pull/398)
+    * [Pull request #382](https://github.com/gazebosim/gz-rendering/pull/382)
+    * [Pull request #398](https://github.com/gazebosim/gz-rendering/pull/398)
 
-### Ignition Rendering 4.8.0 (2021-06-18)
+### Gazebo Rendering 4.8.0 (2021-06-18)
 
 1. relax gaussian test tolerance
-    * [Pull request #344](https://github.com/ignitionrobotics/ign-rendering/pull/344)
+    * [Pull request #344](https://github.com/gazebosim/gz-rendering/pull/344)
 
 1. recreate node only when needed
-    * [Pull request #342](https://github.com/ignitionrobotics/ign-rendering/pull/342)
+    * [Pull request #342](https://github.com/gazebosim/gz-rendering/pull/342)
 
 1. Backport memory fixes found by ASAN
-    * [Pull request #340](https://github.com/ignitionrobotics/ign-rendering/pull/340)
+    * [Pull request #340](https://github.com/gazebosim/gz-rendering/pull/340)
 
 1. Re-enable part of depth camera test on macOS
-    * [Pull request #335](https://github.com/ignitionrobotics/ign-rendering/pull/335)
-    * [Pull request #347](https://github.com/ignitionrobotics/ign-rendering/pull/347)
+    * [Pull request #335](https://github.com/gazebosim/gz-rendering/pull/335)
+    * [Pull request #347](https://github.com/gazebosim/gz-rendering/pull/347)
 
 1. Fix depth alpha
-    * [Pull request #316](https://github.com/ignitionrobotics/ign-rendering/pull/316)
+    * [Pull request #316](https://github.com/gazebosim/gz-rendering/pull/316)
 
 1. Fix floating point precision bug handling alpha channel (#332)
-    * [Pull request #333](https://github.com/ignitionrobotics/ign-rendering/pull/333)
+    * [Pull request #333](https://github.com/gazebosim/gz-rendering/pull/333)
 
 1. Include MoveTo Helper class to ign-rendering
-    * [Pull request #311](https://github.com/ignitionrobotics/ign-rendering/pull/311)
+    * [Pull request #311](https://github.com/gazebosim/gz-rendering/pull/311)
 
 1. Remove `tools/code_check` and update codecov
-    * [Pull request #321](https://github.com/ignitionrobotics/ign-rendering/pull/321)
+    * [Pull request #321](https://github.com/gazebosim/gz-rendering/pull/321)
 
 1. [OGRE 1.x] Uniform buffer shader support
-    * [Pull request #294](https://github.com/ignitionrobotics/ign-rendering/pull/294)
+    * [Pull request #294](https://github.com/gazebosim/gz-rendering/pull/294)
 
 1. Helper function to get a scene
-    * [Pull request #320](https://github.com/ignitionrobotics/ign-rendering/pull/320)
+    * [Pull request #320](https://github.com/gazebosim/gz-rendering/pull/320)
 
 1. Reduce lidar data discretization
-    * [Pull request #296](https://github.com/ignitionrobotics/ign-rendering/pull/296)
+    * [Pull request #296](https://github.com/gazebosim/gz-rendering/pull/296)
 
 1. Prevent console warnings when multiple texture coordinates are present
-    * [Pull request #301](https://github.com/ignitionrobotics/ign-rendering/pull/301)
+    * [Pull request #301](https://github.com/gazebosim/gz-rendering/pull/301)
 
 1. Added command line argument to pick version of Ogre
-    * [Pull request #277](https://github.com/ignitionrobotics/ign-rendering/pull/277)
+    * [Pull request #277](https://github.com/gazebosim/gz-rendering/pull/277)
 
-### Ignition Rendering 4.7.0 (2021-03-17)
+### Gazebo Rendering 4.7.0 (2021-03-17)
 
 1. Enable depth write in particles example
-    * [Pull Request #217](https://github.com/ignitionrobotics/ign-rendering/pull/217)
+    * [Pull Request #217](https://github.com/gazebosim/gz-rendering/pull/217)
 
 1. Fix gazebo_scene_viewer for macOS and ensure clean exit
-    * [Pull Request #259](https://github.com/ignitionrobotics/ign-rendering/pull/259)
+    * [Pull Request #259](https://github.com/gazebosim/gz-rendering/pull/259)
 
 1. Master branch updates
-    * [Pull Request #268](https://github.com/ignitionrobotics/ign-rendering/pull/268)
+    * [Pull Request #268](https://github.com/gazebosim/gz-rendering/pull/268)
 
 1. Expose particle scatter ratio parameter
-    * [Pull Request #269](https://github.com/ignitionrobotics/ign-rendering/pull/269)
+    * [Pull Request #269](https://github.com/gazebosim/gz-rendering/pull/269)
 
 1. Fix overriding blend mode
-    * [Pull Request #266](https://github.com/ignitionrobotics/ign-rendering/pull/266)
+    * [Pull Request #266](https://github.com/gazebosim/gz-rendering/pull/266)
 
 1. Fix DepthGaussianNoise test
-    * [Pull Request #271](https://github.com/ignitionrobotics/ign-rendering/pull/271)
+    * [Pull Request #271](https://github.com/gazebosim/gz-rendering/pull/271)
 
 1. Handle non-positive object temperatures
-    * [Pull Request #243](https://github.com/ignitionrobotics/ign-rendering/pull/243)
+    * [Pull Request #243](https://github.com/gazebosim/gz-rendering/pull/243)
 
-### Ignition Rendering 4.6.0 (2021-03-01)
+### Gazebo Rendering 4.6.0 (2021-03-01)
 
 1. Improve particle scattering noise
-    * [Pull Request #261](https://github.com/ignitionrobotics/ign-rendering/pull/261)
+    * [Pull Request #261](https://github.com/gazebosim/gz-rendering/pull/261)
 
 1. Fix custom_scene_viewer for macOS
-    * [Pull Request #256](https://github.com/ignitionrobotics/ign-rendering/pull/256)
+    * [Pull Request #256](https://github.com/gazebosim/gz-rendering/pull/256)
 
-### Ignition Rendering 4.5.0 (2021-02-17)
+### Gazebo Rendering 4.5.0 (2021-02-17)
 
 1. More verbose messages when failing to load render engines
-    * [Pull Request #236](https://github.com/ignitionrobotics/ign-rendering/pull/236)
+    * [Pull Request #236](https://github.com/gazebosim/gz-rendering/pull/236)
 
 1. Fixed OBJ textures with the same name
-    * [Pull Request #239](https://github.com/ignitionrobotics/ign-rendering/pull/239)
+    * [Pull Request #239](https://github.com/gazebosim/gz-rendering/pull/239)
 
 1. Fix setting particle size
-    * [Pull Request #241](https://github.com/ignitionrobotics/ign-rendering/pull/241)
+    * [Pull Request #241](https://github.com/gazebosim/gz-rendering/pull/241)
 
 1. Make particle emitter invisible in thermal camera image
-    * [Pull Request #240](https://github.com/ignitionrobotics/ign-rendering/pull/240)
+    * [Pull Request #240](https://github.com/gazebosim/gz-rendering/pull/240)
 
 1. Apply particle scattering effect to depth cameras
-    * [Pull Request #251](https://github.com/ignitionrobotics/ign-rendering/pull/251)
+    * [Pull Request #251](https://github.com/gazebosim/gz-rendering/pull/251)
 
-### Ignition Rendering 4.4.0 (2021-02-11)
+### Gazebo Rendering 4.4.0 (2021-02-11)
 
 1. Add support for 8 bit thermal camera image format
-    * [Pull Request #235](https://github.com/ignitionrobotics/ign-rendering/pull/235)
+    * [Pull Request #235](https://github.com/gazebosim/gz-rendering/pull/235)
 
 1. All changes up to version 3.4.0
 
-### Ignition Rendering 4.3.1 (2021-02-03)
+### Gazebo Rendering 4.3.1 (2021-02-03)
 
 1. Fix converting Pbs to Unlit material conversion (#230)
-    * [Pull Request #230](https://github.com/ignitionrobotics/ign-rendering/pull/230)
+    * [Pull Request #230](https://github.com/gazebosim/gz-rendering/pull/230)
 
-### Ignition Rendering 4.3.0 (2021-02-02)
+### Gazebo Rendering 4.3.0 (2021-02-02)
 
 1. Tutorial: Transform FBX to Collada and change its origin
-    * [Pull request #195](https://github.com/ignitionrobotics/ign-rendering/pull/195)
+    * [Pull request #195](https://github.com/gazebosim/gz-rendering/pull/195)
 
 1. Remove Windows Warnings
-    * [Pull request #206](https://github.com/ignitionrobotics/ign-rendering/pull/206)
-    * [Pull request #213](https://github.com/ignitionrobotics/ign-rendering/pull/213)
-    * [Pull request #215](https://github.com/ignitionrobotics/ign-rendering/pull/215)
+    * [Pull request #206](https://github.com/gazebosim/gz-rendering/pull/206)
+    * [Pull request #213](https://github.com/gazebosim/gz-rendering/pull/213)
+    * [Pull request #215](https://github.com/gazebosim/gz-rendering/pull/215)
 
 1. Fix spelling Desconstructor -> Destructor
-    * [Pull request #220](https://github.com/ignitionrobotics/ign-rendering/pull/220)
+    * [Pull request #220](https://github.com/gazebosim/gz-rendering/pull/220)
 
 1. Thermal Camera: Visualize objects with a heat signature
-    * [Pull request #189](https://github.com/ignitionrobotics/ign-rendering/pull/189)
+    * [Pull request #189](https://github.com/gazebosim/gz-rendering/pull/189)
 
 1. Add laser retro support in Ogre2
-    * [Pull request #194](https://github.com/ignitionrobotics/ign-rendering/pull/194)
+    * [Pull request #194](https://github.com/gazebosim/gz-rendering/pull/194)
 
-### Ignition Rendering 4.2.0 (2021-01-22)
+### Gazebo Rendering 4.2.0 (2021-01-22)
 
 1. Remove some windows warnings.
-    * [Pull request #183](https://github.com/ignitionrobotics/ign-rendering/pull/183)
+    * [Pull request #183](https://github.com/gazebosim/gz-rendering/pull/183)
 
 1. Fix transparency issue for textures without alpha channel.
-    * [Pull request #186](https://github.com/ignitionrobotics/ign-rendering/pull/186)
+    * [Pull request #186](https://github.com/gazebosim/gz-rendering/pull/186)
 
 1. Call XCloseDisplay in screenScalingFactor.
-    * [Pull request #204](https://github.com/ignitionrobotics/ign-rendering/pull/204)
+    * [Pull request #204](https://github.com/gazebosim/gz-rendering/pull/204)
 
 1. All changes up to version 3.3.0.
 
-### Ignition Rendering 4.1.0 (2020-11-04)
+### Gazebo Rendering 4.1.0 (2020-11-04)
 
 1. Improve fork experience
-    * [Pull request #165](https://github.com/ignitionrobotics/ign-rendering/pull/165)
+    * [Pull request #165](https://github.com/gazebosim/gz-rendering/pull/165)
 
 1. Add Custom Render Engine support
-    * [Pull request 161](https://github.com/ignitionrobotics/ign-rendering/pull/161)
-    * [Pull request 154](https://github.com/ignitionrobotics/ign-rendering/pull/154)
-    * [Pull request 142](https://github.com/ignitionrobotics/ign-rendering/pull/142)
-    * [Pull request 141](https://github.com/ignitionrobotics/ign-rendering/pull/141)
+    * [Pull request 161](https://github.com/gazebosim/gz-rendering/pull/161)
+    * [Pull request 154](https://github.com/gazebosim/gz-rendering/pull/154)
+    * [Pull request 142](https://github.com/gazebosim/gz-rendering/pull/142)
+    * [Pull request 141](https://github.com/gazebosim/gz-rendering/pull/141)
 
 1. Update tutorials
-    * [Pull request #159](https://github.com/ignitionrobotics/ign-rendering/pull/159)
-    * [Pull request #153](https://github.com/ignitionrobotics/ign-rendering/pull/153)
+    * [Pull request #159](https://github.com/gazebosim/gz-rendering/pull/159)
+    * [Pull request #153](https://github.com/gazebosim/gz-rendering/pull/153)
 
 1. Limit number of shadow casting lights in ogre2
-    * [Pull Request 155](https://github.com/ignitionrobotics/ign-rendering/pull/155)
+    * [Pull Request 155](https://github.com/gazebosim/gz-rendering/pull/155)
 
 1. Ogre2 depth camera fix
-    * [Pull Request 138](https://github.com/ignitionrobotics/ign-rendering/pull/138)
+    * [Pull Request 138](https://github.com/gazebosim/gz-rendering/pull/138)
 
 1. Add support for Gaussian noise render pass in Ogre2DepthCamera
-    * [Pull Request 122](https://github.com/ignitionrobotics/ign-rendering/pull/122)
+    * [Pull Request 122](https://github.com/gazebosim/gz-rendering/pull/122)
 
-### Ignition Rendering 4.0.0 (2020-09-29)
+### Gazebo Rendering 4.0.0 (2020-09-29)
 
 1. Update tutorials
-    * [Pull request #151](https://github.com/ignitionrobotics/ign-rendering/pull/151)
-    * [Pull request #150](https://github.com/ignitionrobotics/ign-rendering/pull/150)
-    * [Pull request #149](https://github.com/ignitionrobotics/ign-rendering/pull/149)
-    * [Pull request #148](https://github.com/ignitionrobotics/ign-rendering/pull/148)
-    * [Pull request #147](https://github.com/ignitionrobotics/ign-rendering/pull/147)
-    * [Pull request #146](https://github.com/ignitionrobotics/ign-rendering/pull/146)
-    * [Pull request #145](https://github.com/ignitionrobotics/ign-rendering/pull/145)
-    * [Pull request #144](https://github.com/ignitionrobotics/ign-rendering/pull/144)
-    * [Pull request #143](https://github.com/ignitionrobotics/ign-rendering/pull/143)
-    * [Pull request #125](https://github.com/ignitionrobotics/ign-rendering/pull/125)
+    * [Pull request #151](https://github.com/gazebosim/gz-rendering/pull/151)
+    * [Pull request #150](https://github.com/gazebosim/gz-rendering/pull/150)
+    * [Pull request #149](https://github.com/gazebosim/gz-rendering/pull/149)
+    * [Pull request #148](https://github.com/gazebosim/gz-rendering/pull/148)
+    * [Pull request #147](https://github.com/gazebosim/gz-rendering/pull/147)
+    * [Pull request #146](https://github.com/gazebosim/gz-rendering/pull/146)
+    * [Pull request #145](https://github.com/gazebosim/gz-rendering/pull/145)
+    * [Pull request #144](https://github.com/gazebosim/gz-rendering/pull/144)
+    * [Pull request #143](https://github.com/gazebosim/gz-rendering/pull/143)
+    * [Pull request #125](https://github.com/gazebosim/gz-rendering/pull/125)
 
 1. Pimpl'ize ogre2 classes
-    * [Pull request #137](https://github.com/ignitionrobotics/ign-rendering/pull/137)
+    * [Pull request #137](https://github.com/gazebosim/gz-rendering/pull/137)
 
 1. Replace common::Time with std::chrono
-    * [Pull request #135](https://github.com/ignitionrobotics/ign-rendering/pull/135)
+    * [Pull request #135](https://github.com/gazebosim/gz-rendering/pull/135)
 
 1. Add Ogre2 particle system
-    * [Pull request #126](https://github.com/ignitionrobotics/ign-rendering/pull/126)
-    * [Pull request #117](https://github.com/ignitionrobotics/ign-rendering/pull/117)
-    * [Pull request #113](https://github.com/ignitionrobotics/ign-rendering/pull/113)
-    * [Pull request #107](https://github.com/ignitionrobotics/ign-rendering/pull/107)
+    * [Pull request #126](https://github.com/gazebosim/gz-rendering/pull/126)
+    * [Pull request #117](https://github.com/gazebosim/gz-rendering/pull/117)
+    * [Pull request #113](https://github.com/gazebosim/gz-rendering/pull/113)
+    * [Pull request #107](https://github.com/gazebosim/gz-rendering/pull/107)
 
 1. Add LidarVisual point colors for Ogre1
-    * [Pull request #124](https://github.com/ignitionrobotics/ign-rendering/pull/124)
+    * [Pull request #124](https://github.com/gazebosim/gz-rendering/pull/124)
 
 1. Added Lidar Visual for Ogre2
-    * [Pull request #116](https://github.com/ignitionrobotics/ign-rendering/pull/116)
+    * [Pull request #116](https://github.com/gazebosim/gz-rendering/pull/116)
 
 1. Added Lidar Visual Types for Ogre1
-    * [Pull request #114](https://github.com/ignitionrobotics/ign-rendering/pull/114)
+    * [Pull request #114](https://github.com/gazebosim/gz-rendering/pull/114)
 
 1. Added Lidar Visualisation for Ogre1
-    * [Pull request #103](https://github.com/ignitionrobotics/ign-rendering/pull/103)
+    * [Pull request #103](https://github.com/gazebosim/gz-rendering/pull/103)
 
 1. Add environment variables to locate plugins
-    * [Pull request #104](https://github.com/ignitionrobotics/ign-rendering/pull/104)
+    * [Pull request #104](https://github.com/gazebosim/gz-rendering/pull/104)
 
 1. Added a method to show the head on arrows and axis
-    * [Pull request #95](https://github.com/ignitionrobotics/ign-rendering/pull/95)
+    * [Pull request #95](https://github.com/gazebosim/gz-rendering/pull/95)
 
 1. Complete Shaft and Head methods in BaseArrowVisual
-    * [Pull request #95](https://github.com/ignitionrobotics/ign-rendering/pull/94)
+    * [Pull request #95](https://github.com/gazebosim/gz-rendering/pull/94)
 
 1. Scale BaseAxis properly
-    * [Pull request #88](https://github.com/ignitionrobotics/ign-rendering/pull/88)
+    * [Pull request #88](https://github.com/gazebosim/gz-rendering/pull/88)
 
 1. Add ogre2 AxisVisual and ArrowVisual
-    * [Pull request 87](https://github.com/ignitionrobotics/ign-rendering/pull/87)
+    * [Pull request 87](https://github.com/gazebosim/gz-rendering/pull/87)
 
 1. Support setting skeleton node weights
     * [BitBucket pull request 256](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/256)
@@ -729,101 +729,101 @@
 1. Add support for transparency based on textures alpha channel for ogre1 and ogre2
     * [BitBucket pull request 229](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/229)
 
-### Ignition Rendering 3.6.0 (2021-10-15)
+### Gazebo Rendering 3.6.0 (2021-10-15)
 
 1. Avoid symbol redefition to fix armel builds
-    * [Pull request 457](https://github.com/ignitionrobotics/ign-rendering/pull/457)
+    * [Pull request 457](https://github.com/gazebosim/gz-rendering/pull/457)
 
 1. Fix floating point precision bug handling alpha channel
-    * [Pull request 322](https://github.com/ignitionrobotics/ign-rendering/pull/322)
-    * [Pull request 333](https://github.com/ignitionrobotics/ign-rendering/pull/333)
+    * [Pull request 322](https://github.com/gazebosim/gz-rendering/pull/322)
+    * [Pull request 333](https://github.com/gazebosim/gz-rendering/pull/333)
 
 1. Ogre: Do not assume that ogre plugins have lib prefix on macOS
-    * [Pull request 454](https://github.com/ignitionrobotics/ign-rendering/pull/454)
+    * [Pull request 454](https://github.com/gazebosim/gz-rendering/pull/454)
 
 1. Moved ScreenToPlane and ScreenToScene from ign-gui to ign-rendering
-    * [Pull request 363](https://github.com/ignitionrobotics/ign-rendering/pull/363)
-    * [Pull request 368](https://github.com/ignitionrobotics/ign-rendering/pull/368)
+    * [Pull request 363](https://github.com/gazebosim/gz-rendering/pull/363)
+    * [Pull request 368](https://github.com/gazebosim/gz-rendering/pull/368)
 
 1. Relax Gaussian noise test tolerance to fix flaky test
-    * [Pull request 344](https://github.com/ignitionrobotics/ign-rendering/pull/344)
+    * [Pull request 344](https://github.com/gazebosim/gz-rendering/pull/344)
 
 1. Fix ogre2 render pass high GPU usage
-    * [Pull request 342](https://github.com/ignitionrobotics/ign-rendering/pull/342)
+    * [Pull request 342](https://github.com/gazebosim/gz-rendering/pull/342)
 
 1. Backport memory fixes found by ASAN
-    * [Pull request 340](https://github.com/ignitionrobotics/ign-rendering/pull/340)
+    * [Pull request 340](https://github.com/gazebosim/gz-rendering/pull/340)
 
 1. CMake warning on Ogre versions that are not officially supported.
    To disable the new warning, it is enough to enable the cmake option USE_UNOFFICIAL_OGRE_VERSIONS
-    * [Pull request 376](https://github.com/ignitionrobotics/ign-rendering/pull/376)
+    * [Pull request 376](https://github.com/gazebosim/gz-rendering/pull/376)
 
-### Ignition Rendering 3.5.0 (2021-05-25)
+### Gazebo Rendering 3.5.0 (2021-05-25)
 
 1. Include MoveTo Helper class to ign-rendering
-    * [Pull request 311](https://github.com/ignitionrobotics/ign-rendering/pull/311)
+    * [Pull request 311](https://github.com/gazebosim/gz-rendering/pull/311)
 
 1. Remove tools/code_check and update codecov
-    * [Pull request 321](https://github.com/ignitionrobotics/ign-rendering/pull/321)
+    * [Pull request 321](https://github.com/gazebosim/gz-rendering/pull/321)
 
 1. Helper function to get a scene (#320)
-    * [Pull request 320](https://github.com/ignitionrobotics/ign-rendering/pull/320)
+    * [Pull request 320](https://github.com/gazebosim/gz-rendering/pull/320)
 
 1. Fix DepthGaussianNoise test (#271)
-    * [Pull request 271](https://github.com/ignitionrobotics/ign-rendering/pull/271)
+    * [Pull request 271](https://github.com/gazebosim/gz-rendering/pull/271)
 
 1. Master branch updates (#268)
-    * [Pull request 268](https://github.com/ignitionrobotics/ign-rendering/pull/268)
+    * [Pull request 268](https://github.com/gazebosim/gz-rendering/pull/268)
 
 1. 👩🌾 Make GitHub actions tests that are flaky due to display more verbose information (#255)
-    * [Pull request 255](https://github.com/ignitionrobotics/ign-rendering/pull/255)
+    * [Pull request 255](https://github.com/gazebosim/gz-rendering/pull/255)
 
 1. Fixed OBJ textures with the same name (#239)
-    * [Pull request 239](https://github.com/ignitionrobotics/ign-rendering/pull/239)
+    * [Pull request 239](https://github.com/gazebosim/gz-rendering/pull/239)
 
 1. More verbose messages when failing to load render engine (#236)
-    * [Pull request 236](https://github.com/ignitionrobotics/ign-rendering/pull/236)
+    * [Pull request 236](https://github.com/gazebosim/gz-rendering/pull/236)
 
-### Ignition Rendering 3.4.0 (2021-02-09)
+### Gazebo Rendering 3.4.0 (2021-02-09)
 
 1. Clear all Windows warnings
-    * [Pull request 206](https://github.com/ignitionrobotics/ign-rendering/pull/206)
-    * [Pull request 215](https://github.com/ignitionrobotics/ign-rendering/pull/215)
-    * [Pull request 225](https://github.com/ignitionrobotics/ign-rendering/pull/225)
+    * [Pull request 206](https://github.com/gazebosim/gz-rendering/pull/206)
+    * [Pull request 215](https://github.com/gazebosim/gz-rendering/pull/215)
+    * [Pull request 225](https://github.com/gazebosim/gz-rendering/pull/225)
 
 1. Add laser_retro support
-    * [Pull request 194](https://github.com/ignitionrobotics/ign-rendering/pull/194)
+    * [Pull request 194](https://github.com/gazebosim/gz-rendering/pull/194)
 
-### Ignition Rendering 3.3.0 (2021-01-22)
+### Gazebo Rendering 3.3.0 (2021-01-22)
 
 1. Add Windows installation.
-    * [Pull request 196](https://github.com/ignitionrobotics/ign-rendering/pull/196)
+    * [Pull request 196](https://github.com/gazebosim/gz-rendering/pull/196)
 
 1. Make flaky VisualAt test more verbose.
-    * [Pull request 174](https://github.com/ignitionrobotics/ign-rendering/pull/174)
+    * [Pull request 174](https://github.com/gazebosim/gz-rendering/pull/174)
 
 1. Resolve updated codecheck issues.
-    * [Pull request 173](https://github.com/ignitionrobotics/ign-rendering/pull/173)
+    * [Pull request 173](https://github.com/gazebosim/gz-rendering/pull/173)
 
 1. Fix crash due to NaN pose values.
-    * [Pull request 169](https://github.com/ignitionrobotics/ign-rendering/pull/169)
+    * [Pull request 169](https://github.com/gazebosim/gz-rendering/pull/169)
 
 1. Improve fork experience.
-    * [Pull request 165](https://github.com/ignitionrobotics/ign-rendering/pull/165)
+    * [Pull request 165](https://github.com/gazebosim/gz-rendering/pull/165)
 
-### Ignition Rendering 3.2.0 (2020-10-13)
+### Gazebo Rendering 3.2.0 (2020-10-13)
 
 1. Add Custom Render Engine support
-    * [Pull request 161](https://github.com/ignitionrobotics/ign-rendering/pull/161)
-    * [Pull request 154](https://github.com/ignitionrobotics/ign-rendering/pull/154)
-    * [Pull request 142](https://github.com/ignitionrobotics/ign-rendering/pull/142)
-    * [Pull request 141](https://github.com/ignitionrobotics/ign-rendering/pull/141)
+    * [Pull request 161](https://github.com/gazebosim/gz-rendering/pull/161)
+    * [Pull request 154](https://github.com/gazebosim/gz-rendering/pull/154)
+    * [Pull request 142](https://github.com/gazebosim/gz-rendering/pull/142)
+    * [Pull request 141](https://github.com/gazebosim/gz-rendering/pull/141)
 
 1. Add getter for Ogre2Camera
-    * [Pull request 97](https://github.com/ignitionrobotics/ign-rendering/pull/97)
+    * [Pull request 97](https://github.com/gazebosim/gz-rendering/pull/97)
 
 1. Update test configuration to use ogre2
-    * [Pull request 83](https://github.com/ignitionrobotics/ign-rendering/pull/83)
+    * [Pull request 83](https://github.com/gazebosim/gz-rendering/pull/83)
 
 1. Ogre2 GPU Ray: Cleanup all resources on destruction
     * [BitBucket pull request 258](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/258)
@@ -833,7 +833,7 @@
 
 1. Includes all changes up to and including those in version 2.5.1
 
-### Ignition Rendering 3.1.0 (2020-03-05)
+### Gazebo Rendering 3.1.0 (2020-03-05)
 
 1. Use default material properties from ign-common PBR material when loading a mesh
     * [BitBucket pull request 242](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/242)
@@ -862,7 +862,7 @@
 1. Add API to check which engines are loaded
     * [BitBucket pull request 233](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/233)
 
-### Ignition Rendering 3.0.0 (2019-12-10)
+### Gazebo Rendering 3.0.0 (2019-12-10)
 
 1. Support setting cast shadows
     * [BitBucket pull request 209](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/209)
@@ -894,20 +894,20 @@
     * [BitBucket pull request 199](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/199)
     * [BitBucket pull request 204](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/204)
 
-### Ignition Rendering 2.5.1 (2020-10-05)
+### Gazebo Rendering 2.5.1 (2020-10-05)
 
 1. Limit number of shadow casting lights in ogre2
-    * [Pull Request 155](https://github.com/ignitionrobotics/ign-rendering/pull/155)
+    * [Pull Request 155](https://github.com/gazebosim/gz-rendering/pull/155)
 
 1. Backport ogre2 depth camera fix
-    * [Pull Request 138](https://github.com/ignitionrobotics/ign-rendering/pull/138)
+    * [Pull Request 138](https://github.com/gazebosim/gz-rendering/pull/138)
 
-### Ignition Rendering 2.5.0 (2020-08-07)
+### Gazebo Rendering 2.5.0 (2020-08-07)
 
 1. Add support for Gaussian noise render pass in Ogre2DepthCamera
-    * [Pull Request 122](https://github.com/ignitionrobotics/ign-rendering/pull/122)
+    * [Pull Request 122](https://github.com/gazebosim/gz-rendering/pull/122)
 
-### Ignition Rendering 2.4.0 (2020-04-17)
+### Gazebo Rendering 2.4.0 (2020-04-17)
 
 1. Fix flaky VisualAt test
     * [BitBucket pull request 248](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/248)
@@ -921,7 +921,7 @@
 1. Backport transparency setting based on diffuse alpha
     * [BitBucket pull request 247](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/247)
 
-### Ignition Rendering 2.3.0 (2020-02-19)
+### Gazebo Rendering 2.3.0 (2020-02-19)
 
 1. Add API to check which engines are loaded
     * [BitBucket pull request 233](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/233)
@@ -933,7 +933,7 @@
     * [BitBucket pull request 222](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/222)
     * [BitBucket pull request 223](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/223)
 
-### Ignition Rendering 2.2.0 (2019-11-20)
+### Gazebo Rendering 2.2.0 (2019-11-20)
 
 1. Backport setting cast shadows
     * [BitBucket pull request 210](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/210)
@@ -941,17 +941,17 @@
 1. Ogre2: Add more shadow maps
     * [BitBucket pull request 203](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/203)
 
-### Ignition Rendering 2.1.2 (2019-09-10)
+### Gazebo Rendering 2.1.2 (2019-09-10)
 
 1. Enable gamma write on color texture in depth camera
     * [BitBucket pull request 193](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/193)
 
-### Ignition Rendering 2.1.1 (2019-09-06)
+### Gazebo Rendering 2.1.1 (2019-09-06)
 
 1. Add checks on mouse selection
     * [BitBucket pull request 191](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/191)
 
-### Ignition Rendering 2.1.0 (2019-08-27)
+### Gazebo Rendering 2.1.0 (2019-08-27)
 
 1. Support generating point cloud data in DepthCamera
     * [BitBucket pull request 187](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/187)
@@ -962,13 +962,13 @@
 1. Fix PixelFormat FLOAT32 byte and channel count
     * [BitBucket pull request 186](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/186)
 
-### Ignition Rendering 2.0.1 (2019-07-16)
+### Gazebo Rendering 2.0.1 (2019-07-16)
 
 1. Clean up camera objects when destroying scene
     * [BitBucket pull request 174](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/174)
     * [BitBucket pull request 180](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/180)
 
-### Ignition Rendering 2.0.0 (2019-05-20)
+### Gazebo Rendering 2.0.0 (2019-05-20)
 
 1. More ogre2 error messages for debugging mesh loading.
     * [BitBucket pull request 170](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/170)
@@ -999,7 +999,7 @@
     * [BitBucket pull request 154](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/154)
     * [BitBucket pull request 155](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/155)
 
-### Ignition Rendering 1.X
+### Gazebo Rendering 1.X
 
 1. Ogre2: Fix loading mesh with large index count
     * [BitBucket pull request 156](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/156)
@@ -1007,4 +1007,4 @@
 1. Move OgreDepthCameraPrivate class to src file so it is not installed.
     * [BitBucket pull request 150](https://osrf-migration.github.io/ignition-gh-pages/#!/ignitionrobotics/ign-rendering/pull-requests/150)
 
-### Ignition Rendering 1.0.0 (2019-02-28)
+### Gazebo Rendering 1.0.0 (2019-02-28)
diff --git a/Migration.md b/Migration.md
index 2d0167823..6a443c228 100644
--- a/Migration.md
+++ b/Migration.md
@@ -5,27 +5,31 @@ Deprecated code produces compile-time warnings. These warning serve as
 notification to users that their code should be upgraded. The next major
 release will remove the deprecated code.
 
-## Ignition Rendering 6.x to 7.x
+## Gazebo Rendering 6.x to 7.x
 
 ### Deprecations
 
 1. **ogre2/include/ignition/rendering/ogre2/Ogre2RenderEngine.hh**
-    + Deprecated: `Ogre2GzHlmsSphericalClipMinDistance &HlmsCustomizations()`
+    + Deprecated: `Ogre2IgnHlmsSphericalClipMinDistance &HlmsCustomizations()`
     + Replacement: `Ogre2GzHlmsSphericalClipMinDistance &SphericalClipMinDistance()`
+2. The `ignition` namespace is deprecated and will be removed in future versions.  Use `gz` instead.
+3. Header files under `ignition/...` are deprecated and will be removed in future versions.
+   Use `gz/...` instead.
+* The environment variable `IGN_RENDERING_PLUGIN_PATH` is deprecated. Use `GZ_RENDERING_PLUGIN_PATH` instead.
 
-## Ignition Rendering 6.2.1 to 6.X
+## Gazebo Rendering 6.2.1 to 6.X
 
 ### Modifications
 
 1. Ogre 2 heightmaps: the Y position sign was flipped
 
-1. `Scene::SetTime` is often unset. Ignition's `Ogre2` now defaults to 60hz otherwise rendering won't advance forward.
+1. `Scene::SetTime` is often unset. Gazebo's `Ogre2` now defaults to 60hz otherwise rendering won't advance forward.
 	+ Mostly affects Particles.
 	+ Also may affect gaussian postprocessing and other filters dependant on time.
 	+ Previous behavior was using real time instead of simulation time, which is wrong.
-	+ See https://github.com/ignitionrobotics/ign-rendering/issues/556 for details.
+	+ See https://github.com/gazebosim/gz-rendering/issues/556 for details.
 
-## Ignition Rendering 5.x to 6.x
+## Gazebo Rendering 5.x to 6.x
 
 ### Modifications
 
@@ -60,18 +64,18 @@ release will remove the deprecated code.
 1. **depth_camera_fs.glsl** and **depth_camera_final_fs.glsl**
     + Far clipping changed from clipping by depth to clipping by range, i.e. distance to point, so that the data generated will never exceed the specified max range of the camera.
 
-## Ignition Rendering 4.0 to 4.1
+## Gazebo Rendering 4.0 to 4.1
 
 ## ABI break
 
 1. **ogre2/include/ignition/rendering/ogre2/Ogre2DepthCamera.hh**
     + Medium severity ABI break with the addition of the `AddRenderPass` override.
 
-## Ignition Rendering 3.X to 4.X
+## Gazebo Rendering 3.X to 4.X
 
 ### Deprecations
 
-1. **ignition::common::Time** deprecated in favor of **std::chrono::steady_clock::duration**
+1. **gz::common::Time** deprecated in favor of **std::chrono::steady_clock::duration**
     + Deprecated: `void BaseScene::SetSimTime(const common::Time &_time)`
     + Replacement: `void BaseScene::SetTime(const std::chrono::steady_clock::duration &_time)`
     + Deprecated: `common::Time SimTime() const`
@@ -79,14 +83,14 @@ release will remove the deprecated code.
     + Deprecated: `common::Time simTime`
     + Replacement: `std::chrono::steady_clock::duration time`
 
-## Ignition Rendering 2.X to 3.X
+## Gazebo Rendering 2.X to 3.X
 
 ### Deletions
 
 1. **Ogre2DepthCamera.hh**
     + Removed unused member variables `captureData` and `newData`
 
-## Ignition Rendering 1.X to 2.X
+## Gazebo Rendering 1.X to 2.X
 
 ### Modifications
 
diff --git a/NEWS b/NEWS
index 604eba665..a73d9b7c1 100644
--- a/NEWS
+++ b/NEWS
@@ -1 +1 @@
-http://ignitionrobotics.org
+http://gazebosim.org
diff --git a/README.md b/README.md
index 2dc37b502..60c6485ed 100644
--- a/README.md
+++ b/README.md
@@ -1,24 +1,24 @@
-# Ignition Rendering: Rendering library for robot applications
+# Gazebo Rendering: Rendering library for robot applications
 
 **Maintainer:** ichen [AT] openrobotics [DOT] org
 
-[![GitHub open issues](https://img.shields.io/github/issues-raw/ignitionrobotics/ign-rendering.svg)](https://github.com/ignitionrobotics/ign-rendering/issues)
-[![GitHub open pull requests](https://img.shields.io/github/issues-pr-raw/ignitionrobotics/ign-rendering.svg)](https://github.com/ignitionrobotics/ign-rendering/pulls)
+[![GitHub open issues](https://img.shields.io/github/issues-raw/gazebosim/gz-rendering.svg)](https://github.com/gazebosim/gz-rendering/issues)
+[![GitHub open pull requests](https://img.shields.io/github/issues-pr-raw/gazebosim/gz-rendering.svg)](https://github.com/gazebosim/gz-rendering/pulls)
 [![Discourse topics](https://img.shields.io/discourse/https/community.gazebosim.org/topics.svg)](https://community.gazebosim.org)
 [![Hex.pm](https://img.shields.io/hexpm/l/plug.svg)](https://www.apache.org/licenses/LICENSE-2.0)
 
 Build | Status
 -- | --
-Test coverage | [![codecov](https://codecov.io/gh/ignitionrobotics/ign-rendering/branch/main/graph/badge.svg)](https://codecov.io/gh/ignitionrobotics/ign-rendering/branch/default)
+Test coverage | [![codecov](https://codecov.io/gh/gazebosim/gz-rendering/branch/main/graph/badge.svg)](https://codecov.io/gh/gazebosim/gz-rendering/branch/default)
 Ubuntu Focal | [![Build Status](https://build.osrfoundation.org/buildStatus/icon?job=ignition_rendering-ci-main-focal-amd64)](https://build.osrfoundation.org/job/ignition_rendering-ci-main-focal-amd64)
 Homebrew      | [![Build Status](https://build.osrfoundation.org/buildStatus/icon?job=ignition_rendering-ci-main-homebrew-amd64)](https://build.osrfoundation.org/job/ignition_rendering-ci-main-homebrew-amd64)
 Windows       | [![Build Status](https://build.osrfoundation.org/job/ign_rendering-ci-win/badge/icon)](https://build.osrfoundation.org/job/ign_rendering-ci-win/)
 
-Ignition Rendering is a C++ library designed to provide an abstraction
+Gazebo Rendering is a C++ library designed to provide an abstraction
 for different rendering engines. It offers unified APIs for creating
 3D graphics applications.
 
-Ignition Rendering is a component in the ignition framework, a set
+Gazebo Rendering is a component in the ignition framework, a set
 of libraries designed to rapidly develop robot applications.
 
 # Table of Contents
@@ -47,12 +47,12 @@ of libraries designed to rapidly develop robot applications.
 
 # Install
 
-See the [installation tutorial](https://ignitionrobotics.org/api/rendering/5.0/installation.html).
+See the [installation tutorial](https://gazebosim.org/api/rendering/5.0/installation.html).
 
 # Usage
 
 The Ign Rendering API can be found in the documentation. See the
-[installation tutorial](https://ignitionrobotics.org/api/rendering/5.0/installation.html)
+[installation tutorial](https://gazebosim.org/api/rendering/5.0/installation.html)
 on how to build the documentation files using Doxygen.
 
 You can also take a look at the sample applications in the `examples` folder.
@@ -81,18 +81,18 @@ Rendering engine plugin implementation code is stored in their own folders
 # Contributing
 
 Please see
-[CONTRIBUTING.md](https://ignitionrobotics.org/docs/all/contributing).
+[CONTRIBUTING.md](https://gazebosim.org/docs/all/contributing).
 
 # Code of Conduct
 
 Please see
-[CODE_OF_CONDUCT.md](https://github.com/ignitionrobotics/ign-gazebo/blob/main/CODE_OF_CONDUCT.md).
+[CODE_OF_CONDUCT.md](https://github.com/gazebosim/gz-sim/blob/main/CODE_OF_CONDUCT.md).
 
 # Versioning
 
-This library uses [Semantic Versioning](https://semver.org/). Additionally, this library is part of the [Ignition Robotics project](https://ignitionrobotics.org) which periodically releases a versioned set of compatible and complimentary libraries. See the [Ignition Robotics website](https://ignitionrobotics.org) for version and release information.
+This library uses [Semantic Versioning](https://semver.org/). Additionally, this library is part of the [Gazebo project](https://gazebosim.org) which periodically releases a versioned set of compatible and complimentary libraries. See the [Gazebo website](https://gazebosim.org) for version and release information.
 
 # License
 
-This library is licensed under [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0). See also the [LICENSE](https://github.com/ignitionrobotics/ign-rendering/blob/main/LICENSE) file.
+This library is licensed under [Apache 2.0](https://www.apache.org/licenses/LICENSE-2.0). See also the [LICENSE](https://github.com/gazebosim/gz-rendering/blob/main/LICENSE) file.
 
diff --git a/api.md.in b/api.md.in
index d25ca9164..1987b3bec 100644
--- a/api.md.in
+++ b/api.md.in
@@ -1,7 +1,7 @@
 ## Ignition @IGN_DESIGNATION_CAP@
 
-Ignition @IGN_DESIGNATION_CAP@ is a component in Ignition Robotics, a set of libraries
-designed to rapidly develop robot and simulation applications. 
+Ignition @IGN_DESIGNATION_CAP@ is a component in Gazebo, a set of libraries
+designed to rapidly develop robot and simulation applications.
 
 ## License
 
diff --git a/examples/actor_animation/GlutWindow.cc b/examples/actor_animation/GlutWindow.cc
index 8b84a6f21..04bf61edf 100644
--- a/examples/actor_animation/GlutWindow.cc
+++ b/examples/actor_animation/GlutWindow.cc
@@ -160,7 +160,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -171,7 +171,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -201,7 +201,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -250,9 +250,9 @@ void updatePose(double _time)
   for (auto &v : g_visuals)
   {
   //! [update pose]
-    std::map<std::string, ignition::math::Matrix4d> animFrames;
+    std::map<std::string, gz::math::Matrix4d> animFrames;
     animFrames = g_skelAnim->PoseAt(_time, true);
-    std::map<std::string, ignition::math::Matrix4d> skinFrames;
+    std::map<std::string, gz::math::Matrix4d> skinFrames;
     for (auto pair : animFrames)
     {
       std::string animNodeName = pair.first;
@@ -260,7 +260,7 @@ void updatePose(double _time)
 
       std::string skinName =
           g_skel->NodeNameAnimToSkin(g_animIdx, animNodeName);
-      ignition::math::Matrix4d skinTf =
+      gz::math::Matrix4d skinTf =
               g_skel->AlignTranslation(g_animIdx, animNodeName)
               * animTf * g_skel->AlignRotation(g_animIdx, animNodeName);
 
@@ -542,7 +542,7 @@ void run(std::vector<ir::CameraPtr> _cameras,
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/actor_animation/GlutWindow.hh b/examples/actor_animation/GlutWindow.hh
index 9ee38c5f2..c0756de12 100644
--- a/examples/actor_animation/GlutWindow.hh
+++ b/examples/actor_animation/GlutWindow.hh
@@ -21,8 +21,8 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/common/graphics/Types.hh"
 
-namespace ir = ignition::rendering;
-namespace ic = ignition::common;
+namespace ir = gz::rendering;
+namespace ic = gz::common;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/actor_animation/Main.cc b/examples/actor_animation/Main.cc
index df03d3342..5442e0ca7 100644
--- a/examples/actor_animation/Main.cc
+++ b/examples/actor_animation/Main.cc
@@ -37,7 +37,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -63,7 +63,7 @@ void buildScene(ScenePtr _scene, std::vector<VisualPtr> &_visuals,
   // Skeleton will be animated by GlutWindow
 
   //! [load mesh]
-  ignmsg << "Creating mesh with animations..." << std::endl;
+  gzmsg << "Creating mesh with animations..." << std::endl;
   MeshDescriptor descriptor;
   descriptor.meshName = common::joinPaths(RESOURCE_PATH, "walk.dae");
   common::MeshManager *meshManager = common::MeshManager::Instance();
@@ -78,18 +78,18 @@ void buildScene(ScenePtr _scene, std::vector<VisualPtr> &_visuals,
   _skel->AddBvhAnimation(bvhFile, scale);
   if (_skel->AnimationCount() == 0)
   {
-    ignerr << "Failed to load animation." << std::endl;
+    gzerr << "Failed to load animation." << std::endl;
     return;
   }
-  ignmsg << "Loaded animations: " << std::endl;
+  gzmsg << "Loaded animations: " << std::endl;
   for (unsigned int i = 0; i < _skel->AnimationCount(); ++i)
-    ignmsg << "  * " << _skel->Animation(i)->Name() << std::endl;
+    gzmsg << "  * " << _skel->Animation(i)->Name() << std::endl;
   //! [add animation]
 
   unsigned int size = 25;
   double halfSize = size * 0.5;
   unsigned int count = 0;
-  ignmsg << "Creating " << size*size << " meshes with skeleton animation"
+  gzmsg << "Creating " << size*size << " meshes with skeleton animation"
          << std::endl;
   for (unsigned int i = 0; i < size; ++i)
   {
@@ -163,7 +163,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/camera_tracking/GlutWindow.cc b/examples/camera_tracking/GlutWindow.cc
index a6df026cb..8e29e02c2 100644
--- a/examples/camera_tracking/GlutWindow.cc
+++ b/examples/camera_tracking/GlutWindow.cc
@@ -92,8 +92,8 @@ struct mouseButton
 struct mouseButton g_mouse;
 std::mutex g_mouseMutex;
 
-ignition::math::Vector3d g_trackOffset(1.0, 0, 0);
-ignition::math::Vector3d g_followOffset(-3, 0, 3);
+gz::math::Vector3d g_trackOffset(1.0, 0, 0);
+gz::math::Vector3d g_followOffset(-3, 0, 3);
 
 
 //////////////////////////////////////////////////
@@ -147,7 +147,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -158,7 +158,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -188,7 +188,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -296,21 +296,21 @@ void keyboardCB(unsigned char _key, int, int)
     if (_key == 'w' || _key == 'W')
     {
       node->SetWorldPosition(node->WorldPosition() +
-          node->WorldRotation() * ignition::math::Vector3d(posIncr, 0, 0));
+          node->WorldRotation() * gz::math::Vector3d(posIncr, 0, 0));
     }
     else if (_key == 's' || _key == 'S')
     {
       node->SetWorldPosition(node->WorldPosition() +
-          node->WorldRotation() * ignition::math::Vector3d(-posIncr, 0, 0));
+          node->WorldRotation() * gz::math::Vector3d(-posIncr, 0, 0));
     }
     else if (_key == 'a' || _key == 'A')
     {
-      node->SetWorldRotation(ignition::math::Quaterniond(0, 0,
+      node->SetWorldRotation(gz::math::Quaterniond(0, 0,
           node->WorldRotation().Yaw() + yawIncr));
     }
     else if (_key == 'd' || _key == 'D')
     {
-      node->SetWorldRotation(ignition::math::Quaterniond(0, 0,
+      node->SetWorldRotation(gz::math::Quaterniond(0, 0,
           node->WorldRotation().Yaw() - yawIncr));
     }
   }
@@ -399,14 +399,14 @@ void keyboardCB(unsigned char _key, int, int)
     if (_key == 't' || _key == 'T')
     {
       double trackPGain = 0.005;
-      double p = ignition::math::equal(cam->TrackPGain(), 1.0) ?
+      double p = gz::math::equal(cam->TrackPGain(), 1.0) ?
           trackPGain : 1.0;
       cam->SetTrackPGain(p);
     }
     else if (_key == 'f' || _key == 'F')
     {
       double followPGain = 0.01;
-      double p = ignition::math::equal(cam->FollowPGain(), 1.0) ?
+      double p = gz::math::equal(cam->FollowPGain(), 1.0) ?
           followPGain : 1.0;
       cam->SetFollowPGain(p);
     }
@@ -478,7 +478,7 @@ void run(std::vector<ir::CameraPtr> _cameras,
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/camera_tracking/GlutWindow.hh b/examples/camera_tracking/GlutWindow.hh
index 9526f565d..8670a65b8 100644
--- a/examples/camera_tracking/GlutWindow.hh
+++ b/examples/camera_tracking/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include <gz/rendering/RenderTypes.hh>
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/camera_tracking/Main.cc b/examples/camera_tracking/Main.cc
index 688b5d09c..cf691f607 100644
--- a/examples/camera_tracking/Main.cc
+++ b/examples/camera_tracking/Main.cc
@@ -31,7 +31,7 @@
 #include <gz/rendering.hh>
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/custom_scene_viewer/DemoWindow.cc b/examples/custom_scene_viewer/DemoWindow.cc
index e0e926e97..0ce5850bb 100644
--- a/examples/custom_scene_viewer/DemoWindow.cc
+++ b/examples/custom_scene_viewer/DemoWindow.cc
@@ -41,7 +41,7 @@
 #define KEY_ESC 27
 #define KEY_TAB  9
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/custom_scene_viewer/DemoWindow.hh b/examples/custom_scene_viewer/DemoWindow.hh
index 4313bc0de..2c9696032 100644
--- a/examples/custom_scene_viewer/DemoWindow.hh
+++ b/examples/custom_scene_viewer/DemoWindow.hh
@@ -19,7 +19,7 @@
 
 #include "TestTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo
 /// \param[in] _Pointer to demo
diff --git a/examples/custom_scene_viewer/ManualSceneDemo.cc b/examples/custom_scene_viewer/ManualSceneDemo.cc
index 726c7f656..97771552d 100644
--- a/examples/custom_scene_viewer/ManualSceneDemo.cc
+++ b/examples/custom_scene_viewer/ManualSceneDemo.cc
@@ -30,7 +30,7 @@
 #include "SceneBuilder.hh"
 #include "DemoWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/custom_scene_viewer/ManualSceneDemo.hh b/examples/custom_scene_viewer/ManualSceneDemo.hh
index 7dbc6ddf5..a845eb002 100644
--- a/examples/custom_scene_viewer/ManualSceneDemo.hh
+++ b/examples/custom_scene_viewer/ManualSceneDemo.hh
@@ -22,7 +22,7 @@
 #include <gz/rendering.hh>
 #include "TestTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
diff --git a/examples/custom_scene_viewer/SceneBuilder.cc b/examples/custom_scene_viewer/SceneBuilder.cc
index 10b51cad9..1ddd9e174 100644
--- a/examples/custom_scene_viewer/SceneBuilder.cc
+++ b/examples/custom_scene_viewer/SceneBuilder.cc
@@ -18,7 +18,7 @@
 #include "example_config.hh"
 #include "SceneBuilder.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH = std::string(PROJECT_BINARY_PATH) + "/media";
diff --git a/examples/custom_scene_viewer/SceneBuilder.hh b/examples/custom_scene_viewer/SceneBuilder.hh
index 42362ccd9..8674336fa 100644
--- a/examples/custom_scene_viewer/SceneBuilder.hh
+++ b/examples/custom_scene_viewer/SceneBuilder.hh
@@ -20,7 +20,7 @@
 #include <string>
 #include "TestTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
diff --git a/examples/custom_scene_viewer/TestTypes.hh b/examples/custom_scene_viewer/TestTypes.hh
index 41e1dd3ed..020cbb40c 100644
--- a/examples/custom_scene_viewer/TestTypes.hh
+++ b/examples/custom_scene_viewer/TestTypes.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include <gz/rendering.hh>
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
diff --git a/examples/custom_shaders/custom_shaders.cc b/examples/custom_shaders/custom_shaders.cc
index fc163ea18..db36faf16 100644
--- a/examples/custom_shaders/custom_shaders.cc
+++ b/examples/custom_shaders/custom_shaders.cc
@@ -20,9 +20,9 @@
 
 #include "example_config.hh"
 
-void BuildScene(ignition::rendering::ScenePtr _scene);
+void BuildScene(gz::rendering::ScenePtr _scene);
 
-void PresentImage(ignition::rendering::ImagePtr _image,
+void PresentImage(gz::rendering::ImagePtr _image,
     const std::string &_name);
 
 
@@ -41,21 +41,21 @@ const std::string fragment_shader_file = "fragment_shader.glsl";
 //! [init shaders variables]
 
 const std::string RESOURCE_PATH =
-    ignition::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
+    gz::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
 
 
 //////////////////////////////////////////////////
 int main()
 {
-  // Initialize ignition::rendering
-  auto *engine = ignition::rendering::engine("ogre");
+  // Initialize gz::rendering
+  auto *engine = gz::rendering::engine("ogre");
   if (!engine)
   {
     std::cerr << "Failed to load ogre\n";
     return 1;
   }
   // Create a scene and add stuff to it
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
   if (!scene)
   {
     std::cerr << "Failed to create scene." << std::endl;
@@ -63,42 +63,42 @@ int main()
   }
   BuildScene(scene);
 
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // Create a camera
-  ignition::rendering::CameraPtr camera;
+  gz::rendering::CameraPtr camera;
   camera = scene->CreateCamera("example_custom_shaders");
   camera->SetImageWidth(width);
   camera->SetImageHeight(height);
   camera->SetHFOV(1.05);
   camera->SetAntiAliasing(2);
   camera->SetAspectRatio(width / height);
-  camera->SetImageFormat(ignition::rendering::PF_R8G8B8);
+  camera->SetImageFormat(gz::rendering::PF_R8G8B8);
   root->AddChild(camera);
 
   // Create a camera for depth image
-  ignition::rendering::CameraPtr depthCamera;
+  gz::rendering::CameraPtr depthCamera;
   depthCamera = scene->CreateCamera("example_custom_shaders_depth");
   depthCamera->SetImageWidth(width);
   depthCamera->SetImageHeight(height);
   depthCamera->SetHFOV(1.05);
   depthCamera->SetAntiAliasing(2);
   depthCamera->SetAspectRatio(width / height);
-  depthCamera->SetImageFormat(ignition::rendering::PF_R8G8B8);
+  depthCamera->SetImageFormat(gz::rendering::PF_R8G8B8);
   root->AddChild(depthCamera);
 
   //! [Get shader path]
   // path to look for vertex and fragment shaders
-  std::string depth_vertex_shader_path = ignition::common::joinPaths(
+  std::string depth_vertex_shader_path = gz::common::joinPaths(
       RESOURCE_PATH,  depth_vertex_shader_file);
 
-  std::string depth_fragment_shader_path = ignition::common::joinPaths(
+  std::string depth_fragment_shader_path = gz::common::joinPaths(
       RESOURCE_PATH, depth_fragment_shader_file);
   //! [Get shader path]
 
   //! [add shader to camera]
   // create shader material
-  ignition::rendering::MaterialPtr depthMat = scene->CreateMaterial();
+  gz::rendering::MaterialPtr depthMat = scene->CreateMaterial();
   depthMat->SetVertexShader(depth_vertex_shader_path);
   depthMat->SetFragmentShader(depth_fragment_shader_path);
 
@@ -106,10 +106,10 @@ int main()
   depthCamera->SetMaterial(depthMat);
   //! [add shader to camera]
 
-  ignition::rendering::ImagePtr image =
-    std::make_shared<ignition::rendering::Image>(camera->CreateImage());
-  ignition::rendering::ImagePtr depthImage =
-    std::make_shared<ignition::rendering::Image>(depthCamera->CreateImage());
+  gz::rendering::ImagePtr image =
+    std::make_shared<gz::rendering::Image>(camera->CreateImage());
+  gz::rendering::ImagePtr depthImage =
+    std::make_shared<gz::rendering::Image>(depthCamera->CreateImage());
 
   depthCamera->Capture(*depthImage);
   PresentImage(depthImage, "depth.png");
@@ -120,14 +120,14 @@ int main()
 }
 
 //////////////////////////////////////////////////
-void PresentImage(ignition::rendering::ImagePtr _image,
+void PresentImage(gz::rendering::ImagePtr _image,
     const std::string &_name)
 {
   // Present the data
   unsigned char *data = _image->Data<unsigned char>();
 
-  ignition::common::Image image;
-  image.SetFromData(data, width, height, ignition::common::Image::RGB_INT8);
+  gz::common::Image image;
+  image.SetFromData(data, width, height, gz::common::Image::RGB_INT8);
 
   image.SavePNG(_name);
 
@@ -135,14 +135,14 @@ void PresentImage(ignition::rendering::ImagePtr _image,
 }
 
 //////////////////////////////////////////////////
-void BuildScene(ignition::rendering::ScenePtr _scene)
+void BuildScene(gz::rendering::ScenePtr _scene)
 {
   // initialize _scene
   _scene->SetAmbientLight(0.3, 0.3, 0.3);
-  ignition::rendering::VisualPtr root = _scene->RootVisual();
+  gz::rendering::VisualPtr root = _scene->RootVisual();
 
   // create directional light
-  ignition::rendering::DirectionalLightPtr light0 =
+  gz::rendering::DirectionalLightPtr light0 =
     _scene->CreateDirectionalLight();
   light0->SetDirection(-0.5, 0.5, -1);
   light0->SetDiffuseColor(0.5, 0.5, 0.5);
@@ -150,14 +150,14 @@ void BuildScene(ignition::rendering::ScenePtr _scene)
   root->AddChild(light0);
 
   // create white material
-  ignition::rendering::MaterialPtr grey = _scene->CreateMaterial();
+  gz::rendering::MaterialPtr grey = _scene->CreateMaterial();
   grey->SetAmbient(0.5, 0.5, 0.5);
   grey->SetDiffuse(0.8, 0.8, 0.8);
   grey->SetReceiveShadows(true);
   grey->SetReflectivity(0);
 
   // create plane visual
-  ignition::rendering::VisualPtr plane = _scene->CreateVisual();
+  gz::rendering::VisualPtr plane = _scene->CreateVisual();
   auto geom = _scene->CreatePlane();
   plane->AddGeometry(geom);
   plane->SetLocalScale(5, 8, 1);
@@ -167,20 +167,20 @@ void BuildScene(ignition::rendering::ScenePtr _scene)
 
   // create shader materials
   // path to look for vertex and fragment shader parameters
-  std::string vertex_shader_path = ignition::common::joinPaths(
+  std::string vertex_shader_path = gz::common::joinPaths(
       RESOURCE_PATH, vertex_shader_file);
 
-  std::string fragment_shader_path = ignition::common::joinPaths(
+  std::string fragment_shader_path = gz::common::joinPaths(
       RESOURCE_PATH, fragment_shader_file);
 
   //! [add shader to visual]
   // create shader material
-  ignition::rendering::MaterialPtr shader = _scene->CreateMaterial();
+  gz::rendering::MaterialPtr shader = _scene->CreateMaterial();
   shader->SetVertexShader(vertex_shader_path);
   shader->SetFragmentShader(fragment_shader_path);
 
   // create box visual and apply shader
-  ignition::rendering::VisualPtr box = _scene->CreateVisual();
+  gz::rendering::VisualPtr box = _scene->CreateVisual();
   box->AddGeometry(_scene->CreateBox());
   box->SetOrigin(0.0, 0.5, 0.0);
   box->SetLocalPosition(3, 0, 0);
diff --git a/examples/custom_shaders_uniforms/GlutWindow.cc b/examples/custom_shaders_uniforms/GlutWindow.cc
index be80661af..bc8fce27e 100644
--- a/examples/custom_shaders_uniforms/GlutWindow.cc
+++ b/examples/custom_shaders_uniforms/GlutWindow.cc
@@ -252,7 +252,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/custom_shaders_uniforms/GlutWindow.hh b/examples/custom_shaders_uniforms/GlutWindow.hh
index bca604788..92c36fcec 100644
--- a/examples/custom_shaders_uniforms/GlutWindow.hh
+++ b/examples/custom_shaders_uniforms/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/custom_shaders_uniforms/Main.cc b/examples/custom_shaders_uniforms/Main.cc
index 29add9698..0d1bca761 100644
--- a/examples/custom_shaders_uniforms/Main.cc
+++ b/examples/custom_shaders_uniforms/Main.cc
@@ -40,7 +40,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string vertexShaderGLSLFile = "vertex_shader.glsl";
@@ -55,7 +55,7 @@ const std::string fragmentShaderMetalFile = "fragment_shader.metal";
 //! [init shaders variables]
 
 const std::string RESOURCE_PATH =
-    ignition::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
+    gz::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
 
 //////////////////////////////////////////////////
 void buildScene(ScenePtr _scene,
@@ -97,15 +97,15 @@ void buildScene(ScenePtr _scene,
 
   // create shader materials
   // path to look for vertex and fragment shader parameters
-  std::string vertexShaderPath = ignition::common::joinPaths(
+  std::string vertexShaderPath = gz::common::joinPaths(
       RESOURCE_PATH, vertexShaderFile);
 
-  std::string fragmentShaderPath = ignition::common::joinPaths(
+  std::string fragmentShaderPath = gz::common::joinPaths(
       RESOURCE_PATH, fragmentShaderFile);
 
   //! [add shader to visual]
   // create shader material
-  ignition::rendering::MaterialPtr shader = _scene->CreateMaterial();
+  gz::rendering::MaterialPtr shader = _scene->CreateMaterial();
   shader->SetVertexShader(vertexShaderPath);
   shader->SetFragmentShader(fragmentShaderPath);
 
diff --git a/examples/depth_camera/GlutWindow.cc b/examples/depth_camera/GlutWindow.cc
index 07cc7a9c6..ee5b147c7 100644
--- a/examples/depth_camera/GlutWindow.cc
+++ b/examples/depth_camera/GlutWindow.cc
@@ -58,7 +58,7 @@ unsigned int imgh = 0;
 
 ir::CameraPtr g_camera;
 ir::ImagePtr g_image;
-ignition::common::ConnectionPtr g_connection;
+gz::common::ConnectionPtr g_connection;
 
 bool g_initContext = false;
 
@@ -147,7 +147,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -181,7 +181,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -357,7 +357,7 @@ void run(ir::CameraPtr _camera)
 {
   if (!_camera)
   {
-    ignerr << "No camera found. Scene will not be rendered" << std::endl;
+    gzerr << "No camera found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/depth_camera/GlutWindow.hh b/examples/depth_camera/GlutWindow.hh
index a8066f460..38aa4cf13 100644
--- a/examples/depth_camera/GlutWindow.hh
+++ b/examples/depth_camera/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _camera Depth Camera
diff --git a/examples/depth_camera/Main.cc b/examples/depth_camera/Main.cc
index 2648049e2..3e2086bb5 100644
--- a/examples/depth_camera/Main.cc
+++ b/examples/depth_camera/Main.cc
@@ -35,7 +35,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -131,7 +131,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/gazebo_scene_viewer/CameraWindow.cc b/examples/gazebo_scene_viewer/CameraWindow.cc
index 51990290e..20975b86e 100644
--- a/examples/gazebo_scene_viewer/CameraWindow.cc
+++ b/examples/gazebo_scene_viewer/CameraWindow.cc
@@ -145,8 +145,8 @@ void GlutIdle()
   }
 #endif
 
-  ignition::rendering::SceneManager* manager =
-      ignition::rendering::SceneManager::Instance();
+  gz::rendering::SceneManager* manager =
+      gz::rendering::SceneManager::Instance();
 
   manager->UpdateScenes();
 
diff --git a/examples/gazebo_scene_viewer/CameraWindow.hh b/examples/gazebo_scene_viewer/CameraWindow.hh
index 9b4479955..0ed0bb3e4 100644
--- a/examples/gazebo_scene_viewer/CameraWindow.hh
+++ b/examples/gazebo_scene_viewer/CameraWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace gz = ignition::rendering;
+namespace gz = gz::rendering;
 
 void GlutRun(std::vector<gz::CameraPtr> _cameras);
 
diff --git a/examples/gazebo_scene_viewer/GazeboDemo.cc b/examples/gazebo_scene_viewer/GazeboDemo.cc
index 34acaf46b..f50b2e777 100644
--- a/examples/gazebo_scene_viewer/GazeboDemo.cc
+++ b/examples/gazebo_scene_viewer/GazeboDemo.cc
@@ -37,7 +37,7 @@
 #include "CameraWindow.hh"
 #include "SceneManager.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 void Connect()
diff --git a/examples/gazebo_scene_viewer/GazeboWorldDemo.cc b/examples/gazebo_scene_viewer/GazeboWorldDemo.cc
index 9d378b787..8ff846e55 100644
--- a/examples/gazebo_scene_viewer/GazeboWorldDemo.cc
+++ b/examples/gazebo_scene_viewer/GazeboWorldDemo.cc
@@ -37,12 +37,12 @@
 #include "CameraWindow.hh"
 #include "SceneManager.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 void Connect()
 {
-  ignition::common::Console::SetVerbosity(4);
+  gz::common::Console::SetVerbosity(4);
   gazebo::transport::init();
   gazebo::transport::run();
 
diff --git a/examples/gazebo_scene_viewer/SceneManager.cc b/examples/gazebo_scene_viewer/SceneManager.cc
index 89aa7249f..dffd112f8 100644
--- a/examples/gazebo_scene_viewer/SceneManager.cc
+++ b/examples/gazebo_scene_viewer/SceneManager.cc
@@ -29,7 +29,7 @@
 #include "SceneManager.hh"
 #include "SceneManagerPrivate.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -706,7 +706,7 @@ ScenePtr SubSceneManager::SceneAt(unsigned int _index) const
 
   if (_index >= this->SceneCount())
   {
-    ignerr << "Invalid scene index: " << _index << std::endl;
+    gzerr << "Invalid scene index: " << _index << std::endl;
     return nullptr;
   }
 
@@ -722,13 +722,13 @@ void SubSceneManager::AddScene(ScenePtr _scene)
 
   if (!_scene)
   {
-    ignerr << "Cannot add null scene pointer" << std::endl;
+    gzerr << "Cannot add null scene pointer" << std::endl;
     return;
   }
 
   if (this->HasScene(_scene))
   {
-    ignerr << "Scene has already been added" << std::endl;
+    gzerr << "Scene has already been added" << std::endl;
     return;
   }
 
@@ -790,7 +790,7 @@ ScenePtr SubSceneManager::RemoveSceneAt(unsigned int _index)
 
   if (_index >= this->SceneCount())
   {
-    ignerr << "Invalid scene index: " << _index << std::endl;
+    gzerr << "Invalid scene index: " << _index << std::endl;
     return nullptr;
   }
 
@@ -951,7 +951,7 @@ void SubSceneManager::ProcessLight(const gazebo::msgs::Light &_lightMsg,
         return;
 
       default:
-        ignerr << "Invalid light type: " << type << std::endl;
+        gzerr << "Invalid light type: " << type << std::endl;
         return;
     }
   }
@@ -1473,8 +1473,8 @@ void SubSceneManager::ProcessGeometry(
   // check if invalid type
   if (!geomFunc)
   {
-    ignerr << "Unsupported geometry type: " << geomType << std::endl;
-    ignwarn << "Using empty geometry instead" << std::endl;
+    gzerr << "Unsupported geometry type: " << geomType << std::endl;
+    gzwarn << "Using empty geometry instead" << std::endl;
     geomFunc = this->geomFunctions[gazebo::msgs::Geometry::EMPTY];
   }
 
@@ -1743,8 +1743,8 @@ VisualPtr SubSceneManager::Parent(const std::string &_name)
     {
       if (_name != "default")
       {
-        ignerr  << "invalid parent name: " << _name << std::endl;
-        ignwarn << "using scene root node" << std::endl;
+        gzerr  << "invalid parent name: " << _name << std::endl;
+        gzwarn << "using scene root node" << std::endl;
       }
 
       parent = this->activeScene->RootVisual();
diff --git a/examples/gazebo_scene_viewer/SceneManager.hh b/examples/gazebo_scene_viewer/SceneManager.hh
index 8418c99f9..4839f3bb0 100644
--- a/examples/gazebo_scene_viewer/SceneManager.hh
+++ b/examples/gazebo_scene_viewer/SceneManager.hh
@@ -30,7 +30,7 @@
 #include <gz/common/SingletonT.hh>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
diff --git a/examples/gazebo_scene_viewer/SceneManagerPrivate.hh b/examples/gazebo_scene_viewer/SceneManagerPrivate.hh
index 711b3988c..e916fc042 100644
--- a/examples/gazebo_scene_viewer/SceneManagerPrivate.hh
+++ b/examples/gazebo_scene_viewer/SceneManagerPrivate.hh
@@ -31,7 +31,7 @@
 #include "gz/rendering/ShaderType.hh"
 #include "gazebo/transport/Node.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
diff --git a/examples/heightmap/GlutWindow.cc b/examples/heightmap/GlutWindow.cc
index 446d4bf89..bd525bb30 100644
--- a/examples/heightmap/GlutWindow.cc
+++ b/examples/heightmap/GlutWindow.cc
@@ -140,7 +140,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -151,7 +151,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -181,7 +181,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -317,7 +317,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/heightmap/GlutWindow.hh b/examples/heightmap/GlutWindow.hh
index 71b4a73e3..7fc2952e1 100644
--- a/examples/heightmap/GlutWindow.hh
+++ b/examples/heightmap/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/heightmap/Main.cc b/examples/heightmap/Main.cc
index 72f140f43..316cb9cf7 100644
--- a/examples/heightmap/Main.cc
+++ b/examples/heightmap/Main.cc
@@ -36,7 +36,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -285,7 +285,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/hello_world_plugin/HelloWorldPlugin.cc b/examples/hello_world_plugin/HelloWorldPlugin.cc
index 761cede6b..e3348b912 100644
--- a/examples/hello_world_plugin/HelloWorldPlugin.cc
+++ b/examples/hello_world_plugin/HelloWorldPlugin.cc
@@ -27,8 +27,8 @@ namespace mock
 {
   /// \brief The render engine class which implements a render engine.
   class HelloWorldRenderEngine :
-    public virtual ignition::rendering::BaseRenderEngine,
-    public ignition::common::SingletonT<HelloWorldRenderEngine>
+    public virtual gz::rendering::BaseRenderEngine,
+    public gz::common::SingletonT<HelloWorldRenderEngine>
   {
     // Documentation Inherited.
     public: virtual bool IsEnabled() const override
@@ -59,7 +59,7 @@ namespace mock
     /// \brief Get a pointer to the list of scenes managed by the render
     /// engine.
     /// \return list of scenes
-    protected: virtual ignition::rendering::SceneStorePtr Scenes()
+    protected: virtual gz::rendering::SceneStorePtr Scenes()
                      const override
     {
       return nullptr;
@@ -68,7 +68,7 @@ namespace mock
     /// \brief Create a scene.
     /// \param[in] _id Unique scene Id
     /// \parampin] _name Name of scene
-    protected: virtual ignition::rendering::ScenePtr
+    protected: virtual gz::rendering::ScenePtr
                    CreateSceneImpl(unsigned int _id,
                    const std::string &_name) override
     {
@@ -76,12 +76,12 @@ namespace mock
     }
 
     /// \brief Singelton setup.
-    private: friend class ignition::common::SingletonT<HelloWorldRenderEngine>;
+    private: friend class gz::common::SingletonT<HelloWorldRenderEngine>;
   };
 
   /// \brief Plugin for loading the HelloWorld render engine.
   class HelloWorldPlugin :
-    public ignition::rendering::RenderEnginePlugin
+    public gz::rendering::RenderEnginePlugin
   {
     /// \brief Get the name of the render engine loaded by this plugin.
     /// \return Name of render engine
@@ -92,7 +92,7 @@ namespace mock
 
     /// \brief Get a pointer to the render engine loaded by this plugin.
     /// \return Render engine instance
-    public: ignition::rendering::RenderEngine *Engine() const override
+    public: gz::rendering::RenderEngine *Engine() const override
     {
       return HelloWorldRenderEngine::Instance();
     }
@@ -101,4 +101,4 @@ namespace mock
 
 // Register this plugin
 IGNITION_ADD_PLUGIN(mock::HelloWorldPlugin,
-                    ignition::rendering::RenderEnginePlugin)
+                    gz::rendering::RenderEnginePlugin)
diff --git a/examples/hello_world_plugin/README.md b/examples/hello_world_plugin/README.md
index 0e6e58428..91e5d3469 100644
--- a/examples/hello_world_plugin/README.md
+++ b/examples/hello_world_plugin/README.md
@@ -1,7 +1,7 @@
 # Engine plugin
 
 This example shows how to create a plugin that integrates a rendering engine with
-Ignition Rendering and how to load it with Ignition Gazebo.
+Gazebo Rendering and how to load it with Gazebo.
 
 ## Build
 
@@ -39,5 +39,5 @@ or the file extension, i.e., libHelloWorldPlugin.so -> HelloWorldPlugin):
 ign gazebo --render-engine HelloWorldPlugin
 ~~~
 
-You should see a blank screen within the Ignition GUI, as this mocked plugin provides no implementation
+You should see a blank screen within the Gazebo GUI, as this mocked plugin provides no implementation
 for the scene.
diff --git a/examples/lidar_visual/GlutWindow.cc b/examples/lidar_visual/GlutWindow.cc
index 09870b5d8..0cbbc2503 100644
--- a/examples/lidar_visual/GlutWindow.cc
+++ b/examples/lidar_visual/GlutWindow.cc
@@ -43,7 +43,7 @@
 #include <gz/rendering/Scene.hh>
 #include <gz/rendering.hh>
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 #include "GlutWindow.hh"
@@ -158,7 +158,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -169,7 +169,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -199,7 +199,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -349,28 +349,28 @@ void keyboardCB(unsigned char _key, int, int)
   {
     g_lidarVisType = LidarVisualType::LVT_NONE;
     g_lidarVisualUpdateDirty = true;
-    ignmsg << "Set lidar visual type to NONE"
+    gzmsg << "Set lidar visual type to NONE"
            << std::endl;
   }
   else if (_key == '1')
   {
     g_lidarVisType = LidarVisualType::LVT_RAY_LINES;
     g_lidarVisualUpdateDirty = true;
-    ignmsg << "Set lidar visual type to RAY_LINES"
+    gzmsg << "Set lidar visual type to RAY_LINES"
            << std::endl;
   }
   else if (_key == '2')
   {
     g_lidarVisType = LidarVisualType::LVT_POINTS;
     g_lidarVisualUpdateDirty = true;
-    ignmsg << "Set lidar visual type to POINTS"
+    gzmsg << "Set lidar visual type to POINTS"
            << std::endl;
   }
   else if (_key == '3')
   {
     g_lidarVisType = LidarVisualType::LVT_TRIANGLE_STRIPS;
     g_lidarVisualUpdateDirty = true;
-    ignmsg << "Set lidar visual type to TRIANGLE_STRIPS"
+    gzmsg << "Set lidar visual type to TRIANGLE_STRIPS"
            << std::endl;
   }
   else if (_key == KEY_TAB)
@@ -440,7 +440,7 @@ void run(std::vector<ir::CameraPtr> _cameras,
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/lidar_visual/GlutWindow.hh b/examples/lidar_visual/GlutWindow.hh
index 78ed13726..3e6a9a891 100644
--- a/examples/lidar_visual/GlutWindow.hh
+++ b/examples/lidar_visual/GlutWindow.hh
@@ -21,8 +21,8 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/common/graphics/Types.hh"
 
-namespace ir = ignition::rendering;
-namespace ic = ignition::common;
+namespace ir = gz::rendering;
+namespace ic = gz::common;
 
 /// \brief Run the demo and display Lidar Visual
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/lidar_visual/Main.cc b/examples/lidar_visual/Main.cc
index 420d78db6..55907dfc4 100644
--- a/examples/lidar_visual/Main.cc
+++ b/examples/lidar_visual/Main.cc
@@ -33,7 +33,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -50,8 +50,8 @@ const int hRayCount = 640;
 const int vRayCount = 1;
 std::vector<double> pts;
 
-ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0.5),
-    ignition::math::Quaterniond::Identity);
+gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0.5),
+    gz::math::Quaterniond::Identity);
 
 //////////////////////////////////////////////////
 void OnNewGpuRaysFrame(float *_scanDest, const float *_scan,
@@ -117,8 +117,8 @@ void buildScene(ScenePtr _scene)
     root->AddChild(grid);
   }
 
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(6, 0, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(6, 0, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = _scene->CreateVisual("UnitBox1");
   visualBox1->AddGeometry(_scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -126,8 +126,8 @@ void buildScene(ScenePtr _scene)
   visualBox1->SetMaterial(red);
   root->AddChild(visualBox1);
 
-  ignition::math::Pose3d box02Pose(ignition::math::Vector3d(6, 6, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box02Pose(gz::math::Vector3d(6, 6, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox2 = _scene->CreateVisual("UnitBox2");
   visualBox2->AddGeometry(_scene->CreateBox());
   visualBox2->SetWorldPosition(box02Pose.Pos());
@@ -135,8 +135,8 @@ void buildScene(ScenePtr _scene)
   visualBox2->SetMaterial(green);
   root->AddChild(visualBox2);
 
-  ignition::math::Pose3d sphere01Pose(ignition::math::Vector3d(1, -3, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d sphere01Pose(gz::math::Vector3d(1, -3, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualSphere1 = _scene->CreateVisual("UnitSphere1");
   visualSphere1->AddGeometry(_scene->CreateSphere());
   visualSphere1->SetWorldPosition(sphere01Pose.Pos());
@@ -247,7 +247,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/mesh_viewer/GlutWindow.cc b/examples/mesh_viewer/GlutWindow.cc
index 13ac9b6b7..8e60375e1 100644
--- a/examples/mesh_viewer/GlutWindow.cc
+++ b/examples/mesh_viewer/GlutWindow.cc
@@ -140,7 +140,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -151,7 +151,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -181,7 +181,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -317,7 +317,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/mesh_viewer/GlutWindow.hh b/examples/mesh_viewer/GlutWindow.hh
index acd23cb69..7674df2c3 100644
--- a/examples/mesh_viewer/GlutWindow.hh
+++ b/examples/mesh_viewer/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/mesh_viewer/Main.cc b/examples/mesh_viewer/Main.cc
index 154ed9d6a..9a39bb1d3 100644
--- a/examples/mesh_viewer/Main.cc
+++ b/examples/mesh_viewer/Main.cc
@@ -34,7 +34,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -107,7 +107,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/mouse_picking/GlutWindow.cc b/examples/mouse_picking/GlutWindow.cc
index 382843f07..64a599dd9 100644
--- a/examples/mouse_picking/GlutWindow.cc
+++ b/examples/mouse_picking/GlutWindow.cc
@@ -118,7 +118,7 @@ void handleMouse()
     {
       // Get visual using Selection Buffer from Camera
       ir::VisualPtr visual1;
-      ignition::math::Vector2i mousePosI(g_mouse.x, g_mouse.y);
+      gz::math::Vector2i mousePosI(g_mouse.x, g_mouse.y);
       visual1 = rayCamera->VisualAt(mousePosI);
       if (visual1)
       {
@@ -256,7 +256,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/mouse_picking/GlutWindow.hh b/examples/mouse_picking/GlutWindow.hh
index 5ccd67e3c..5cb582744 100644
--- a/examples/mouse_picking/GlutWindow.hh
+++ b/examples/mouse_picking/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 void run(std::vector<ir::CameraPtr> _cameras);
 
diff --git a/examples/mouse_picking/Main.cc b/examples/mouse_picking/Main.cc
index cf77c5948..96144ec0c 100644
--- a/examples/mouse_picking/Main.cc
+++ b/examples/mouse_picking/Main.cc
@@ -32,7 +32,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/ogre2_demo/GlutWindow.cc b/examples/ogre2_demo/GlutWindow.cc
index cac85aeea..14f6c477d 100644
--- a/examples/ogre2_demo/GlutWindow.cc
+++ b/examples/ogre2_demo/GlutWindow.cc
@@ -141,7 +141,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -154,7 +154,7 @@ void handleMouse()
     {
       // Get visual using Selection Buffer from Camera
       ir::VisualPtr visual;
-      ignition::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
+      gz::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
       visual = rayCamera->VisualAt(mousePos);
       if (visual)
       {
@@ -174,7 +174,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -204,7 +204,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -362,7 +362,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/ogre2_demo/GlutWindow.hh b/examples/ogre2_demo/GlutWindow.hh
index c2cd028b2..55f47a778 100644
--- a/examples/ogre2_demo/GlutWindow.hh
+++ b/examples/ogre2_demo/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/ogre2_demo/Main.cc b/examples/ogre2_demo/Main.cc
index 7642d6739..c8f2b290a 100644
--- a/examples/ogre2_demo/Main.cc
+++ b/examples/ogre2_demo/Main.cc
@@ -34,7 +34,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 
diff --git a/examples/particles_demo/GlutWindow.cc b/examples/particles_demo/GlutWindow.cc
index 4225c6927..0f2582dbe 100644
--- a/examples/particles_demo/GlutWindow.cc
+++ b/examples/particles_demo/GlutWindow.cc
@@ -140,7 +140,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -151,7 +151,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -181,7 +181,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -317,7 +317,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/particles_demo/GlutWindow.hh b/examples/particles_demo/GlutWindow.hh
index 916f8b91a..ec9465588 100644
--- a/examples/particles_demo/GlutWindow.hh
+++ b/examples/particles_demo/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/particles_demo/Main.cc b/examples/particles_demo/Main.cc
index 202c18375..ba2247433 100644
--- a/examples/particles_demo/Main.cc
+++ b/examples/particles_demo/Main.cc
@@ -34,7 +34,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -143,7 +143,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
             << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/render_pass/GlutWindow.cc b/examples/render_pass/GlutWindow.cc
index c39c183d9..7be0b605d 100644
--- a/examples/render_pass/GlutWindow.cc
+++ b/examples/render_pass/GlutWindow.cc
@@ -168,7 +168,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/render_pass/GlutWindow.hh b/examples/render_pass/GlutWindow.hh
index 3f9926476..ef9893513 100644
--- a/examples/render_pass/GlutWindow.hh
+++ b/examples/render_pass/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/render_pass/Main.cc b/examples/render_pass/Main.cc
index 958bf4c19..94877fa45 100644
--- a/examples/render_pass/Main.cc
+++ b/examples/render_pass/Main.cc
@@ -32,7 +32,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/segmentation_camera/GlutWindow.cc b/examples/segmentation_camera/GlutWindow.cc
index cb5803919..79a6fae48 100644
--- a/examples/segmentation_camera/GlutWindow.cc
+++ b/examples/segmentation_camera/GlutWindow.cc
@@ -55,7 +55,7 @@ unsigned int imgh = 0;
 
 ir::CameraPtr g_camera;
 ir::ImagePtr g_image;
-ignition::common::ConnectionPtr g_connection;
+gz::common::ConnectionPtr g_connection;
 
 bool g_initContext = false;
 
@@ -143,7 +143,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -159,7 +159,7 @@ void handleMouse()
     {
       // Get visual using Selection Buffer from Camera
       ir::VisualPtr visual;
-      ignition::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
+      gz::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
       visual = rayCamera->VisualAt(mousePos);
       if (visual)
       {
@@ -180,7 +180,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -208,7 +208,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -353,7 +353,7 @@ void run(ir::CameraPtr _camera)
 {
   if (!_camera)
   {
-    ignerr << "No camera found. Scene will not be rendered" << std::endl;
+    gzerr << "No camera found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/segmentation_camera/GlutWindow.hh b/examples/segmentation_camera/GlutWindow.hh
index 5810db195..39704f248 100644
--- a/examples/segmentation_camera/GlutWindow.hh
+++ b/examples/segmentation_camera/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _camera Segmentation Camera
diff --git a/examples/segmentation_camera/Main.cc b/examples/segmentation_camera/Main.cc
index c4853c862..3d994cd5d 100644
--- a/examples/segmentation_camera/Main.cc
+++ b/examples/segmentation_camera/Main.cc
@@ -35,7 +35,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -125,7 +125,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/simple_demo/GlutWindow.cc b/examples/simple_demo/GlutWindow.cc
index bb13dcba8..964d7014e 100644
--- a/examples/simple_demo/GlutWindow.cc
+++ b/examples/simple_demo/GlutWindow.cc
@@ -175,7 +175,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/simple_demo/GlutWindow.hh b/examples/simple_demo/GlutWindow.hh
index 2b6bd0812..3b757b280 100644
--- a/examples/simple_demo/GlutWindow.hh
+++ b/examples/simple_demo/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/simple_demo/Main.cc b/examples/simple_demo/Main.cc
index bbf63002a..af38d901c 100644
--- a/examples/simple_demo/Main.cc
+++ b/examples/simple_demo/Main.cc
@@ -32,7 +32,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/simple_demo_qml/IgnitionRenderer.cc b/examples/simple_demo_qml/IgnitionRenderer.cc
index 7f1667a72..4b13dcfac 100644
--- a/examples/simple_demo_qml/IgnitionRenderer.cc
+++ b/examples/simple_demo_qml/IgnitionRenderer.cc
@@ -27,11 +27,11 @@
 
 #include <iostream>
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
-void BuildScene(ignition::rendering::ScenePtr _scene)
+void BuildScene(gz::rendering::ScenePtr _scene)
 {
   // initialize _scene
   _scene->SetAmbientLight(0.3, 0.3, 0.3);
@@ -170,7 +170,7 @@ void BuildScene(ignition::rendering::ScenePtr _scene)
 }
 
 //////////////////////////////////////////////////
-ignition::rendering::CameraPtr CreateCamera(const std::string &_engineName)
+gz::rendering::CameraPtr CreateCamera(const std::string &_engineName)
 {
   // create and populate scene
   std::map<std::string, std::string> params;
@@ -269,13 +269,13 @@ void IgnitionRenderer::InitEngine()
 
   if (!this->camera)
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
   // quick check on sizing...
-  ignmsg << "imageW: " << this->camera->ImageWidth() << "\n";
-  ignmsg << "imageH: " << this->camera->ImageHeight() << "\n";
+  gzmsg << "imageW: " << this->camera->ImageWidth() << "\n";
+  gzmsg << "imageH: " << this->camera->ImageHeight() << "\n";
 
   // pre-render will force texture creation and may update texture id
   this->camera->PreRender();
diff --git a/examples/simple_demo_qml/IgnitionRenderer.hh b/examples/simple_demo_qml/IgnitionRenderer.hh
index 5d2e60bb9..9b80dfcd4 100644
--- a/examples/simple_demo_qml/IgnitionRenderer.hh
+++ b/examples/simple_demo_qml/IgnitionRenderer.hh
@@ -73,7 +73,7 @@ class IgnitionRenderer
   private: double cameraOffset = 0.0;
 
   /// \brief The camera for the example scene
-  private: ignition::rendering::CameraPtr camera;
+  private: gz::rendering::CameraPtr camera;
 };
 
-#endif // GZ_RENDERING_EXAMPLES_SIMPLE_DEMO_QML_GZ_RENDERER_HH_
+#endif  // GZ_RENDERING_EXAMPLES_SIMPLE_DEMO_QML_GZ_RENDERER_HH_
diff --git a/examples/simple_demo_qml/ThreadRenderer.cpp b/examples/simple_demo_qml/ThreadRenderer.cpp
index 36e4343fa..0e59b015d 100644
--- a/examples/simple_demo_qml/ThreadRenderer.cpp
+++ b/examples/simple_demo_qml/ThreadRenderer.cpp
@@ -165,27 +165,27 @@ void RenderThread::Print(const QSurfaceFormat &_format)
     };
 
     // surface format info
-    ignmsg << "version: "
+    gzmsg << "version: "
         << _format.version().first << "."
         << _format.version().second << "\n";
-    ignmsg << "profile: "
+    gzmsg << "profile: "
         << openGLContextProfileToString(_format.profile()) << "\n";
-    ignmsg << "options: "
+    gzmsg << "options: "
         << formatOptionsToString(_format.options()) << "\n";
-    ignmsg << "renderableType: "
+    gzmsg << "renderableType: "
         << renderableTypeToString(_format.renderableType()) << "\n";
-    ignmsg << "hasAlpha: " << _format.hasAlpha() << "\n";
-    ignmsg << "redBufferSize: " << _format.redBufferSize() << "\n";
-    ignmsg << "greenBufferSize: " << _format.greenBufferSize() << "\n";
-    ignmsg << "blueBufferSize: " << _format.blueBufferSize() << "\n";
-    ignmsg << "alphaBufferSize: " << _format.alphaBufferSize() << "\n";
-    ignmsg << "depthBufferSize: " << _format.depthBufferSize() << "\n";
-    ignmsg << "stencilBufferSize: " << _format.stencilBufferSize() << "\n";
-    ignmsg << "samples: " << _format.samples() << "\n";
-    ignmsg << "swapBehavior: "
+    gzmsg << "hasAlpha: " << _format.hasAlpha() << "\n";
+    gzmsg << "redBufferSize: " << _format.redBufferSize() << "\n";
+    gzmsg << "greenBufferSize: " << _format.greenBufferSize() << "\n";
+    gzmsg << "blueBufferSize: " << _format.blueBufferSize() << "\n";
+    gzmsg << "alphaBufferSize: " << _format.alphaBufferSize() << "\n";
+    gzmsg << "depthBufferSize: " << _format.depthBufferSize() << "\n";
+    gzmsg << "stencilBufferSize: " << _format.stencilBufferSize() << "\n";
+    gzmsg << "samples: " << _format.samples() << "\n";
+    gzmsg << "swapBehavior: "
         << swapBehaviorToString(_format.swapBehavior()) << "\n";
-    ignmsg << "swapInterval: " << _format.swapInterval() << "\n";
-    ignmsg << "\n";
+    gzmsg << "swapInterval: " << _format.swapInterval() << "\n";
+    gzmsg << "\n";
 }
 
 //-----------------------------------------------------------------------
@@ -231,7 +231,7 @@ void RenderThread::RenderNext()
     // check if engine has been successfully initialized
     if (!this->renderer->Initialised())
     {
-        ignerr << "Unable to initialize renderer" << std::endl;
+        gzerr << "Unable to initialize renderer" << std::endl;
         return;
     }
 
diff --git a/examples/simple_demo_qml/ThreadRenderer.h b/examples/simple_demo_qml/ThreadRenderer.h
index 0c66dd6c4..9ca73a15b 100644
--- a/examples/simple_demo_qml/ThreadRenderer.h
+++ b/examples/simple_demo_qml/ThreadRenderer.h
@@ -170,4 +170,4 @@ public slots:
     RenderThread *renderThread = nullptr;
 };
 
-#endif // GZ_RENDERING_EXAMPLES_SIMPLE_DEMO_THREAD_RENDERER_HH_
+#endif  // GZ_RENDERING_EXAMPLES_SIMPLE_DEMO_THREAD_RENDERER_HH_
diff --git a/examples/text_geom/GlutWindow.cc b/examples/text_geom/GlutWindow.cc
index df485dc9b..61099d8fe 100644
--- a/examples/text_geom/GlutWindow.cc
+++ b/examples/text_geom/GlutWindow.cc
@@ -157,7 +157,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/text_geom/GlutWindow.hh b/examples/text_geom/GlutWindow.hh
index 4e28f07d7..2aaf4f11e 100644
--- a/examples/text_geom/GlutWindow.hh
+++ b/examples/text_geom/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/text_geom/Main.cc b/examples/text_geom/Main.cc
index d0d7472d7..04b083498 100644
--- a/examples/text_geom/Main.cc
+++ b/examples/text_geom/Main.cc
@@ -32,7 +32,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/thermal_camera/GlutWindow.cc b/examples/thermal_camera/GlutWindow.cc
index d646e4160..3ebc595b6 100644
--- a/examples/thermal_camera/GlutWindow.cc
+++ b/examples/thermal_camera/GlutWindow.cc
@@ -52,7 +52,7 @@ std::vector<ir::CameraPtr> g_cameras;
 ir::CameraPtr g_camera;
 unsigned int g_cameraIndex = 0;
 ir::ImagePtr g_image;
-ignition::common::ConnectionPtr g_connection;
+gz::common::ConnectionPtr g_connection;
 
 
 bool g_initContext = false;
@@ -142,7 +142,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -157,7 +157,7 @@ void handleMouse()
     {
       // Get visual using Selection Buffer from Camera
       ir::VisualPtr visual;
-      ignition::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
+      gz::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
       visual = rayCamera->VisualAt(mousePos);
       if (visual)
       {
@@ -178,7 +178,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -208,7 +208,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -270,7 +270,7 @@ void OnNewThermalFrame(const uint16_t *_scan,
 
   // convert temperature to grayscale image
   double range = static_cast<double>(max - min);
-  if (ignition::math::equal(range, 0.0))
+  if (gz::math::equal(range, 0.0))
     range = 1.0;
   unsigned char *data = g_image->Data<unsigned char>();
   for (unsigned int i = 0; i < _height; ++i)
@@ -394,7 +394,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/thermal_camera/GlutWindow.hh b/examples/thermal_camera/GlutWindow.hh
index bcfb981c9..d16b9b537 100644
--- a/examples/thermal_camera/GlutWindow.hh
+++ b/examples/thermal_camera/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/thermal_camera/Main.cc b/examples/thermal_camera/Main.cc
index e29191d25..8e80229cd 100644
--- a/examples/thermal_camera/Main.cc
+++ b/examples/thermal_camera/Main.cc
@@ -34,7 +34,7 @@
 #include "example_config.hh"
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string RESOURCE_PATH =
@@ -113,7 +113,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/transform_control/GlutWindow.cc b/examples/transform_control/GlutWindow.cc
index 2469ba2f5..09e0e9ccc 100644
--- a/examples/transform_control/GlutWindow.cc
+++ b/examples/transform_control/GlutWindow.cc
@@ -168,14 +168,14 @@ void handleTransform()
       if (g_mouse.state == GLUT_DOWN)
       {
         // get the visual at mouse position
-        ignition::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
+        gz::math::Vector2i mousePos(g_mouse.x, g_mouse.y);
         ir::VisualPtr visual = rayCamera->VisualAt(mousePos);
         if (visual)
         {
           // check if the visual is an axis in the gizmo visual
-          ignition::math::Vector3d axis =
+          gz::math::Vector3d axis =
               g_transformControl.AxisById(visual->Id());
-          if (axis != ignition::math::Vector3d::Zero)
+          if (axis != gz::math::Vector3d::Zero)
           {
             // start the transform process
             g_transformControl.SetActiveAxis(axis);
@@ -207,23 +207,23 @@ void handleTransform()
       double ny = 1.0 - 2.0 * g_mouse.y / imageHeight;
       double nxEnd = 2.0 * g_mouse.motionX / imageWidth - 1.0;
       double nyEnd = 1.0 - 2.0 * g_mouse.motionY / imageHeight;
-      ignition::math::Vector2d start(nx, ny);
-      ignition::math::Vector2d end(nxEnd, nyEnd);
+      gz::math::Vector2d start(nx, ny);
+      gz::math::Vector2d end(nxEnd, nyEnd);
 
       // get the currect active axis
-      ignition::math::Vector3d axis = g_transformControl.ActiveAxis();
+      gz::math::Vector3d axis = g_transformControl.ActiveAxis();
 
       // compute 3d transformation from 2d mouse movement
       if (g_transformControl.Mode() == ir::TransformMode::TM_TRANSLATION)
       {
-        ignition::math::Vector3d distance =
+        gz::math::Vector3d distance =
             g_transformControl.TranslationFrom2d(axis, start, end);
         g_transformControl.Translate(distance);
         g_mouse.motionDirty = false;
       }
       else if (g_transformControl.Mode() == ir::TransformMode::TM_ROTATION)
       {
-        ignition::math::Quaterniond rotation =
+        gz::math::Quaterniond rotation =
             g_transformControl.RotationFrom2d(axis, start, end);
         g_transformControl.Rotate(rotation);
         g_mouse.motionDirty = false;
@@ -231,7 +231,7 @@ void handleTransform()
       else if (g_transformControl.Mode() == ir::TransformMode::TM_SCALE)
       {
         // note: scaling is limited to local space
-        ignition::math::Vector3d scale =
+        gz::math::Vector3d scale =
             g_transformControl.ScaleFrom2d(axis, start, end);
         g_transformControl.Scale(scale);
         g_mouse.motionDirty = false;
@@ -252,7 +252,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -263,7 +263,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -293,7 +293,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -464,7 +464,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/transform_control/GlutWindow.hh b/examples/transform_control/GlutWindow.hh
index ca547b7e0..f162a70e6 100644
--- a/examples/transform_control/GlutWindow.hh
+++ b/examples/transform_control/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/transform_control/Main.cc b/examples/transform_control/Main.cc
index 87d000c72..253fe4948 100644
--- a/examples/transform_control/Main.cc
+++ b/examples/transform_control/Main.cc
@@ -32,7 +32,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -96,7 +96,7 @@ CameraPtr createCamera(const std::string &_engineName,
   RenderEngine *engine = rendering::engine(_engineName, _params);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/examples/view_control/GlutWindow.cc b/examples/view_control/GlutWindow.cc
index 806bbdba9..d2bf76f14 100644
--- a/examples/view_control/GlutWindow.cc
+++ b/examples/view_control/GlutWindow.cc
@@ -143,7 +143,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -154,7 +154,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -185,7 +185,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -339,7 +339,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/view_control/GlutWindow.hh b/examples/view_control/GlutWindow.hh
index 07129b404..8451263aa 100644
--- a/examples/view_control/GlutWindow.hh
+++ b/examples/view_control/GlutWindow.hh
@@ -20,10 +20,10 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
-void run(std::vector<ignition::rendering::CameraPtr> _cameras);
+void run(std::vector<gz::rendering::CameraPtr> _cameras);
 
 #endif
diff --git a/examples/view_control/Main.cc b/examples/view_control/Main.cc
index b3da5f3c0..fd4fe10e8 100644
--- a/examples/view_control/Main.cc
+++ b/examples/view_control/Main.cc
@@ -31,7 +31,7 @@
 #include <gz/rendering.hh>
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/examples/visualization_demo/GlutWindow.cc b/examples/visualization_demo/GlutWindow.cc
index e15e91e66..dbd795769 100644
--- a/examples/visualization_demo/GlutWindow.cc
+++ b/examples/visualization_demo/GlutWindow.cc
@@ -192,7 +192,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/visualization_demo/GlutWindow.hh b/examples/visualization_demo/GlutWindow.hh
index d973a93af..120669c29 100644
--- a/examples/visualization_demo/GlutWindow.hh
+++ b/examples/visualization_demo/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/visualization_demo/Main.cc b/examples/visualization_demo/Main.cc
index 5fcddf411..b7855cb4e 100644
--- a/examples/visualization_demo/Main.cc
+++ b/examples/visualization_demo/Main.cc
@@ -41,7 +41,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -155,20 +155,20 @@ void buildScene(ScenePtr _scene)
 
   // create inertia visual
   InertiaVisualPtr inertiaVisual = _scene->CreateInertiaVisual();
-  ignition::math::MassMatrix3d massMatrix(1.0, {0.1, 0.1, 0.1}, {0.0, 0.0, 0.0});
-  ignition::math::Pose3d p(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-  ignition::math::Inertiald inertial{massMatrix, p};
+  gz::math::MassMatrix3d massMatrix(1.0, {0.1, 0.1, 0.1}, {0.0, 0.0, 0.0});
+  gz::math::Pose3d p(0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
+  gz::math::Inertiald inertial{massMatrix, p};
   inertiaVisual->SetInertial(inertial);
   inertiaVisual->SetLocalPosition(1.5, -1.0, 0);
   root->AddChild(inertiaVisual);
 
   // create CoM visual
   COMVisualPtr comVisual = _scene->CreateCOMVisual();
-  ignition::math::MassMatrix3d comMassMatrix(
+  gz::math::MassMatrix3d comMassMatrix(
       5.0, {0.1, 0.1, 0.1}, {0.0, 0.0, 0.0});
-  ignition::math::Pose3d comPose(
+  gz::math::Pose3d comPose(
       0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
-  ignition::math::Inertiald comVisualInertial{comMassMatrix, comPose};
+  gz::math::Inertiald comVisualInertial{comMassMatrix, comPose};
   comVisual->SetInertial(comVisualInertial);
   box->AddChild(comVisual);
 
@@ -194,10 +194,10 @@ void buildScene(ScenePtr _scene)
   JointVisualPtr jointVisual = _scene->CreateJointVisual();
   jointChildBox->AddChild(jointVisual);
   jointVisual->SetType(JointVisualType::JVT_REVOLUTE2);
-  ignition::math::Vector3d axis2(1.0, 1.0, 1.0);
+  gz::math::Vector3d axis2(1.0, 1.0, 1.0);
   jointVisual->SetAxis(axis2);
 
-  ignition::math::Vector3d axis1(1.0, 0.0, 0.0);
+  gz::math::Vector3d axis1(1.0, 0.0, 0.0);
   jointVisual->SetParentAxis(axis1, jointParentBox->Name(), true);
 
   // create camera
diff --git a/examples/waves/GlutWindow.cc b/examples/waves/GlutWindow.cc
index 382b29cdb..ae3a17701 100644
--- a/examples/waves/GlutWindow.cc
+++ b/examples/waves/GlutWindow.cc
@@ -52,7 +52,7 @@
 #define KEY_TAB  9
 
 const std::string RESOURCE_PATH =
-    ignition::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
+    gz::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
 
 //////////////////////////////////////////////////
 unsigned int imgw = 0;
@@ -159,7 +159,7 @@ void handleMouse()
     g_rayQuery = rayCamera->Scene()->CreateRayQuery();
     if (!g_rayQuery)
     {
-      ignerr << "Failed to create Ray Query" << std::endl;
+      gzerr << "Failed to create Ray Query" << std::endl;
       return;
     }
   }
@@ -170,7 +170,7 @@ void handleMouse()
         2.0 * g_mouse.x / static_cast<double>(rayCamera->ImageWidth()) - 1.0;
     double ny = 1.0 -
         2.0 * g_mouse.y / static_cast<double>(rayCamera->ImageHeight());
-    g_rayQuery->SetFromCamera(rayCamera, ignition::math::Vector2d(nx, ny));
+    g_rayQuery->SetFromCamera(rayCamera, gz::math::Vector2d(nx, ny));
     g_target  = g_rayQuery->ClosestPoint();
     if (!g_target)
     {
@@ -200,7 +200,7 @@ void handleMouse()
   if (g_mouse.motionDirty)
   {
     g_mouse.motionDirty = false;
-    auto drag = ignition::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
+    auto drag = gz::math::Vector2d(g_mouse.dragX, g_mouse.dragY);
 
     // left mouse button pan
     if (g_mouse.button == GLUT_LEFT_BUTTON && g_mouse.state == GLUT_DOWN)
@@ -417,11 +417,11 @@ void initUniforms()
   (*g_fsParams)["deepColor"].InitializeBuffer(4);
   (*g_fsParams)["deepColor"].UpdateBuffer(deepColor);
 
-  std::string bumpMapPath = ignition::common::joinPaths(RESOURCE_PATH,
+  std::string bumpMapPath = gz::common::joinPaths(RESOURCE_PATH,
       "wave_normals.dds");
   (*g_fsParams)["bumpMap"].SetTexture(bumpMapPath);
 
-  std::string cubeMapPath = ignition::common::joinPaths(RESOURCE_PATH,
+  std::string cubeMapPath = gz::common::joinPaths(RESOURCE_PATH,
       "skybox_lowres.dds");
 
   (*g_fsParams)["cubeMap"].SetTexture(cubeMapPath,
@@ -456,7 +456,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/waves/GlutWindow.hh b/examples/waves/GlutWindow.hh
index 1c7a2e3c4..c221f0f37 100644
--- a/examples/waves/GlutWindow.hh
+++ b/examples/waves/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/waves/Main.cc b/examples/waves/Main.cc
index 6151becab..3cd271434 100644
--- a/examples/waves/Main.cc
+++ b/examples/waves/Main.cc
@@ -40,7 +40,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 const std::string vertexShaderGLSL330File = "GerstnerWaves_vs_330.glsl";
@@ -50,7 +50,7 @@ const std::string vertexShaderMetalFile = "GerstnerWaves_vs.metal";
 const std::string fragmentShaderMetalFile = "GerstnerWaves_fs.metal";
 
 const std::string RESOURCE_PATH =
-    ignition::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
+    gz::common::joinPaths(std::string(PROJECT_BINARY_PATH), "media");
 
 //////////////////////////////////////////////////
 void buildScene(ScenePtr _scene,
@@ -87,14 +87,14 @@ void buildScene(ScenePtr _scene,
 
   // create shader materials
   // path to look for vertex and fragment shader parameters
-  std::string vertexShaderPath = ignition::common::joinPaths(
+  std::string vertexShaderPath = gz::common::joinPaths(
       RESOURCE_PATH, vertexShaderFile);
 
-  std::string fragmentShaderPath = ignition::common::joinPaths(
+  std::string fragmentShaderPath = gz::common::joinPaths(
       RESOURCE_PATH, fragmentShaderFile);
 
   // create shader material
-  ignition::rendering::MaterialPtr shader = _scene->CreateMaterial();
+  gz::rendering::MaterialPtr shader = _scene->CreateMaterial();
   shader->SetVertexShader(vertexShaderPath);
   shader->SetFragmentShader(fragmentShaderPath);
 
@@ -185,7 +185,7 @@ int main(int _argc, char** _argv)
         // todo(anyone) Passing textures to custom shaders is currently
         // only available in ogre2
         engineName = "ogre2";
-        ignerr << "Only ogre2 engine is supported. Switching to use ogre2."
+        gzerr << "Only ogre2 engine is supported. Switching to use ogre2."
                << std::endl;
       }
 
diff --git a/examples/wide_angle_camera/GlutWindow.cc b/examples/wide_angle_camera/GlutWindow.cc
index 13de2a166..a1f7b02cf 100644
--- a/examples/wide_angle_camera/GlutWindow.cc
+++ b/examples/wide_angle_camera/GlutWindow.cc
@@ -57,7 +57,7 @@ ir::CameraPtr g_camera;
 ir::CameraPtr g_currCamera;
 unsigned int g_cameraIndex = 0;
 ir::ImagePtr g_image;
-ignition::common::ConnectionPtr g_connection;
+gz::common::ConnectionPtr g_connection;
 
 bool g_initContext = false;
 
@@ -197,7 +197,7 @@ void run(std::vector<ir::CameraPtr> _cameras)
 {
   if (_cameras.empty())
   {
-    ignerr << "No cameras found. Scene will not be rendered" << std::endl;
+    gzerr << "No cameras found. Scene will not be rendered" << std::endl;
     return;
   }
 
diff --git a/examples/wide_angle_camera/GlutWindow.hh b/examples/wide_angle_camera/GlutWindow.hh
index 694a9b430..2bb0b0ab6 100644
--- a/examples/wide_angle_camera/GlutWindow.hh
+++ b/examples/wide_angle_camera/GlutWindow.hh
@@ -20,7 +20,7 @@
 #include <vector>
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ir = ignition::rendering;
+namespace ir = gz::rendering;
 
 /// \brief Run the demo and render the scene from the cameras
 /// \param[in] _cameras Cameras in the scene
diff --git a/examples/wide_angle_camera/Main.cc b/examples/wide_angle_camera/Main.cc
index 6ae27a5c5..62b5adc75 100644
--- a/examples/wide_angle_camera/Main.cc
+++ b/examples/wide_angle_camera/Main.cc
@@ -38,7 +38,7 @@
 
 #include "GlutWindow.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -143,7 +143,7 @@ CameraPtr createCamera(const std::string &_engineName)
   RenderEngine *engine = rendering::engine(_engineName);
   if (!engine)
   {
-    ignwarn << "Engine '" << _engineName
+    gzwarn << "Engine '" << _engineName
               << "' is not supported" << std::endl;
     return CameraPtr();
   }
diff --git a/include/gz/rendering/ArrowVisual.hh b/include/gz/rendering/ArrowVisual.hh
index 118cb639b..646f98651 100644
--- a/include/gz/rendering/ArrowVisual.hh
+++ b/include/gz/rendering/ArrowVisual.hh
@@ -20,15 +20,15 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/CompositeVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class ArrowVisual ArrowVisual.hh gz/rendering/ArrowVisual.hh
     /// \brief Represents a arrow composite visual
-    class IGNITION_RENDERING_VISIBLE ArrowVisual :
+    class GZ_RENDERING_VISIBLE ArrowVisual :
       public virtual CompositeVisual
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/AxisVisual.hh b/include/gz/rendering/AxisVisual.hh
index 14fe47c2e..9fc251c9b 100644
--- a/include/gz/rendering/AxisVisual.hh
+++ b/include/gz/rendering/AxisVisual.hh
@@ -20,15 +20,15 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/CompositeVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class AxisVisual AxisVisual.hh gz/rendering/AxisVisual.hh
     /// \brief Represents a axis composite visual
-    class IGNITION_RENDERING_VISIBLE AxisVisual :
+    class GZ_RENDERING_VISIBLE AxisVisual :
       public virtual CompositeVisual
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/BoundingBox.hh b/include/gz/rendering/BoundingBox.hh
index df99cb1d6..a3f2e76e9 100644
--- a/include/gz/rendering/BoundingBox.hh
+++ b/include/gz/rendering/BoundingBox.hh
@@ -24,16 +24,16 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
   class BoundingBoxPrivate;
 
   /// \brief 2D or 3D Bounding box. It stores the
   /// position / orientation / size info of the box and its label
-  class IGNITION_RENDERING_VISIBLE BoundingBox
+  class GZ_RENDERING_VISIBLE BoundingBox
   {
     /// \brief Constructor
     public: BoundingBox();
diff --git a/include/gz/rendering/BoundingBoxCamera.hh b/include/gz/rendering/BoundingBoxCamera.hh
index 98ef69786..102eccabe 100644
--- a/include/gz/rendering/BoundingBoxCamera.hh
+++ b/include/gz/rendering/BoundingBoxCamera.hh
@@ -27,11 +27,11 @@
 #include "gz/rendering/BoundingBox.hh"
 #include "gz/rendering/Camera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief BoundingBox types for Visible / Full 2D Boxes / 3D Boxes
     enum class BoundingBoxType
@@ -51,7 +51,7 @@ namespace ignition
     /// gz/rendering/BoundingBoxCamera.hh
     /// \brief Poseable BoundingBox camera used for rendering bounding boxes of
     /// objects in the scene.
-    class IGNITION_RENDERING_VISIBLE BoundingBoxCamera :
+    class GZ_RENDERING_VISIBLE BoundingBoxCamera :
       public virtual Camera
     {
       /// \brief Destructor
@@ -65,7 +65,7 @@ namespace ignition
       /// \brief Connect to the new BoundingBox info
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewBoundingBoxes(
+      public: virtual gz::common::ConnectionPtr ConnectNewBoundingBoxes(
         std::function<void(const std::vector<BoundingBox> &)> _subscriber) = 0;
 
       /// \brief Set BoundingBox Type (Visible / Full)
diff --git a/include/gz/rendering/COMVisual.hh b/include/gz/rendering/COMVisual.hh
index 47a349ca5..57b5d41b1 100644
--- a/include/gz/rendering/COMVisual.hh
+++ b/include/gz/rendering/COMVisual.hh
@@ -24,16 +24,16 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     /// \class COMVisual COMVisual.hh
     /// gz/rendering/COMVisual.hh
     /// \brief Represents a center of mass visual
-    class IGNITION_RENDERING_VISIBLE COMVisual :
+    class GZ_RENDERING_VISIBLE COMVisual :
       public virtual Visual
     {
       /// \brief Destructor
@@ -42,7 +42,7 @@ namespace ignition
       /// \brief Set the inertial component of the visual
       /// \param[in] _inertial Inertial component of the visual
       public: virtual void SetInertial(
-                  const ignition::math::Inertiald &_inertial) = 0;
+                  const gz::math::Inertiald &_inertial) = 0;
 
       /// \brief Set the mass of the parent
       /// \param[in] _mass Parent mass
@@ -54,7 +54,7 @@ namespace ignition
 
       /// \brief Get the inertia pose
       /// \return Inertia pose in parent frame.
-      public: virtual ignition::math::Pose3d InertiaPose() const = 0;
+      public: virtual gz::math::Pose3d InertiaPose() const = 0;
 
       /// \brief Get the sphere visual
       /// \return Pointer to the sphere visual
diff --git a/include/gz/rendering/Camera.hh b/include/gz/rendering/Camera.hh
index eab4767bd..b51450489 100644
--- a/include/gz/rendering/Camera.hh
+++ b/include/gz/rendering/Camera.hh
@@ -29,14 +29,14 @@
 #include "gz/rendering/Scene.hh"
 
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Enum for projection types
-    enum IGNITION_RENDERING_VISIBLE CameraProjectionType
+    enum GZ_RENDERING_VISIBLE CameraProjectionType
     {
       /// \brief Perspective projection
       CPT_PERSPECTIVE,
@@ -46,7 +46,7 @@ namespace ignition
 
     /// \class Camera Camera.hh gz/rendering/Camera.hh
     /// \brief Posable camera used for rendering the scene graph
-    class IGNITION_RENDERING_VISIBLE Camera :
+    class GZ_RENDERING_VISIBLE Camera :
       public virtual Sensor
     {
       /// \brief Callback function for new frame render event listeners
@@ -146,7 +146,7 @@ namespace ignition
       /// \brief Get the visual for a given mouse position
       /// param[in] _mousePos mouse position
       //  \return visual for that position, null if no visual was found
-      public: virtual VisualPtr VisualAt(const ignition::math::Vector2i
+      public: virtual VisualPtr VisualAt(const gz::math::Vector2i
                   &_mousePos) = 0;
 
       /// \brief Renders a new frame.
diff --git a/include/gz/rendering/CameraLens.hh b/include/gz/rendering/CameraLens.hh
index 477538b51..1b2a4b157 100644
--- a/include/gz/rendering/CameraLens.hh
+++ b/include/gz/rendering/CameraLens.hh
@@ -26,14 +26,14 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Enum for mapping function types
-    enum IGNITION_RENDERING_VISIBLE MappingFunctionType
+    enum GZ_RENDERING_VISIBLE MappingFunctionType
     {
       /// \brief Gnomonic
       MFT_GNOMONIC = 0,
@@ -55,7 +55,7 @@ namespace ignition
     };
 
     /// \brief Enum for angle function types
-    enum IGNITION_RENDERING_VISIBLE AngleFunctionType
+    enum GZ_RENDERING_VISIBLE AngleFunctionType
     {
       /// \brief identity
       AFT_IDENTITY = 0,
@@ -69,7 +69,7 @@ namespace ignition
 
     /// \brief Describes a lens of a camera
     ///   as amapping function of type r = c1*f*fun(theta/c2+c3)
-    class IGNITION_RENDERING_VISIBLE CameraLens
+    class GZ_RENDERING_VISIBLE CameraLens
     {
       /// \brief Constructor
       public: CameraLens();
diff --git a/include/gz/rendering/Capsule.hh b/include/gz/rendering/Capsule.hh
index a9bdfb793..ad5d2bc03 100644
--- a/include/gz/rendering/Capsule.hh
+++ b/include/gz/rendering/Capsule.hh
@@ -22,14 +22,14 @@
 #include "gz/rendering/Geometry.hh"
 #include "gz/rendering/Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \class Capsule Capsule.hh gz/rendering/Capsule
     /// \brief Geometry for a capsule shape.
-    class IGNITION_RENDERING_VISIBLE Capsule :
+    class GZ_RENDERING_VISIBLE Capsule :
       public virtual Geometry
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/CompositeVisual.hh b/include/gz/rendering/CompositeVisual.hh
index 34b210d3e..a3006f3cc 100644
--- a/include/gz/rendering/CompositeVisual.hh
+++ b/include/gz/rendering/CompositeVisual.hh
@@ -20,16 +20,16 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class CompositeVisual CompositeVisual.hh
     /// gz/rendering/CompositeVisual.hh
     /// \brief Represents a predefined collection of geometries and visuals
-    class IGNITION_RENDERING_VISIBLE CompositeVisual :
+    class GZ_RENDERING_VISIBLE CompositeVisual :
       public virtual Visual
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/DepthCamera.hh b/include/gz/rendering/DepthCamera.hh
index d0887f047..adda64089 100644
--- a/include/gz/rendering/DepthCamera.hh
+++ b/include/gz/rendering/DepthCamera.hh
@@ -22,16 +22,16 @@
 #include <gz/common/Event.hh>
 #include "gz/rendering/Camera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \class Camera Camera.hh gz/rendering/Camera.hh
     /// \brief Poseable depth camera used for rendering the scene graph.
     /// This camera is designed to produced depth data, instead of a 2D
     /// image.
-    class IGNITION_RENDERING_VISIBLE DepthCamera :
+    class GZ_RENDERING_VISIBLE DepthCamera :
       public virtual Camera
     {
       /// \brief Callback function for new frame render event listeners
@@ -51,7 +51,7 @@ namespace ignition
       /// \brief Connect to the new depth image signal
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewDepthFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewDepthFrame(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) = 0;
 
@@ -71,7 +71,7 @@ namespace ignition
       ///  _depth Point cloud image depth
       ///  _format Point cloud image format
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewRgbPointCloud(
+      public: virtual gz::common::ConnectionPtr ConnectNewRgbPointCloud(
           std::function<void(const float *_pointCloud, unsigned int _width,
           unsigned int _height, unsigned int _depth,
           const std::string &_format)> _subscriber) = 0;
diff --git a/include/gz/rendering/DistortionPass.hh b/include/gz/rendering/DistortionPass.hh
index a6960f994..847974bd7 100644
--- a/include/gz/rendering/DistortionPass.hh
+++ b/include/gz/rendering/DistortionPass.hh
@@ -24,17 +24,17 @@
 #include "gz/rendering/Export.hh"
 #include "gz/rendering/RenderPass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class DistortionPass DistortionPass.hh \
      * gz/rendering/DistortionPass.hh
      */
     /// \brief A render pass that applies distortion to the render target
-    class IGNITION_RENDERING_VISIBLE DistortionPass
+    class GZ_RENDERING_VISIBLE DistortionPass
       : public virtual RenderPass
     {
       /// \brief Constructor
diff --git a/include/gz/rendering/GaussianNoisePass.hh b/include/gz/rendering/GaussianNoisePass.hh
index 48f2e633b..3443db832 100644
--- a/include/gz/rendering/GaussianNoisePass.hh
+++ b/include/gz/rendering/GaussianNoisePass.hh
@@ -22,17 +22,17 @@
 #include "gz/rendering/Export.hh"
 #include "gz/rendering/RenderPass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class GaussianNoisePass GaussianNoisePass.hh \
      * gz/rendering/GaussianNoisePass.hh
      */
     /// \brief A render pass that applies Gaussian noise to the render target
-    class IGNITION_RENDERING_VISIBLE GaussianNoisePass
+    class GZ_RENDERING_VISIBLE GaussianNoisePass
       : public virtual RenderPass
     {
       /// \brief Constructor
diff --git a/include/gz/rendering/Geometry.hh b/include/gz/rendering/Geometry.hh
index 98554aaca..ed5c6e66c 100644
--- a/include/gz/rendering/Geometry.hh
+++ b/include/gz/rendering/Geometry.hh
@@ -24,15 +24,15 @@
 #include "gz/rendering/Object.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Geometry Geometry.hh gz/rendering/Geometry.hh
     /// \brief Represents a geometric shape to be rendered
-    class IGNITION_RENDERING_VISIBLE Geometry :
+    class GZ_RENDERING_VISIBLE Geometry :
       public virtual Object
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/GizmoVisual.hh b/include/gz/rendering/GizmoVisual.hh
index ad1296c8f..d230cd47a 100644
--- a/include/gz/rendering/GizmoVisual.hh
+++ b/include/gz/rendering/GizmoVisual.hh
@@ -23,15 +23,15 @@
 #include "gz/rendering/Export.hh"
 #include "gz/rendering/TransformType.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class GizmoVisual GizmoVisual.hh gz/rendering/GizmoVisual.hh
     /// \brief A gizmo that contains rotate, translate, and scale visuals
-    class IGNITION_RENDERING_VISIBLE GizmoVisual :
+    class GZ_RENDERING_VISIBLE GizmoVisual :
       public virtual CompositeVisual
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/GpuRays.hh b/include/gz/rendering/GpuRays.hh
index 3ca7a2d9a..3fb81bac5 100644
--- a/include/gz/rendering/GpuRays.hh
+++ b/include/gz/rendering/GpuRays.hh
@@ -26,15 +26,15 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/Camera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class GpuRays GpuRays.hh gz/rendering/GpuRays.hh
     /// \brief Generate depth ray data.
-    class IGNITION_RENDERING_VISIBLE GpuRays :
+    class GZ_RENDERING_VISIBLE GpuRays :
       public virtual Camera
     {
       /// \brief Callback function for new frame render event listeners
@@ -106,14 +106,14 @@ namespace ignition
 
       /// \brief Get minimal horizontal angle value
       // \return minimal horizontal angle value
-      public: virtual ignition::math::Angle AngleMin() const = 0;
+      public: virtual gz::math::Angle AngleMin() const = 0;
 
       /// \brief Set minimal horizontal angle value
       public: virtual void SetAngleMin(double _angle) = 0;
 
       /// \brief Get maximal horizontal angle value
       // \return maximal horizontal angle value
-      public: virtual ignition::math::Angle AngleMax() const = 0;
+      public: virtual gz::math::Angle AngleMax() const = 0;
 
       /// \brief Set maximal horizontal angle value
       public: virtual void SetAngleMax(double _angle) = 0;
@@ -142,14 +142,14 @@ namespace ignition
 
       /// \brief Get minimal vertical angle value
       // \return minimal vertical angle value
-      public: virtual ignition::math::Angle VerticalAngleMin() const = 0;
+      public: virtual gz::math::Angle VerticalAngleMin() const = 0;
 
       /// \brief Set minimal vertical angle value
       public: virtual void SetVerticalAngleMin(const double _angle) = 0;
 
       /// \brief Get maximal vertical angle value
       // \return maximal vertical angle value
-      public: virtual ignition::math::Angle VerticalAngleMax() const = 0;
+      public: virtual gz::math::Angle VerticalAngleMax() const = 0;
 
       /// \brief Set maximal vertical angle value
       // \return minimal vertical angle value
diff --git a/include/gz/rendering/GraphicsAPI.hh b/include/gz/rendering/GraphicsAPI.hh
index b7ce2c710..8039ef6ba 100644
--- a/include/gz/rendering/GraphicsAPI.hh
+++ b/include/gz/rendering/GraphicsAPI.hh
@@ -21,14 +21,14 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
      /// \brief The graphics API used by the render engine
-    enum class IGNITION_RENDERING_VISIBLE GraphicsAPI : uint16_t
+    enum class GZ_RENDERING_VISIBLE GraphicsAPI : uint16_t
     {
       /// \internal
       /// \brief Indicator used to create an iterator over the
@@ -57,7 +57,7 @@ namespace ignition
     };
 
     /// \brief Utils to convert GraphicsAPI to and from strings
-    class IGNITION_RENDERING_VISIBLE GraphicsAPIUtils
+    class GZ_RENDERING_VISIBLE GraphicsAPIUtils
     {
       /// \brief Convert enum value to string.
       /// \param[in] _e Enum value to convert.
diff --git a/include/gz/rendering/Grid.hh b/include/gz/rendering/Grid.hh
index 3f61864c8..547b79b74 100644
--- a/include/gz/rendering/Grid.hh
+++ b/include/gz/rendering/Grid.hh
@@ -22,16 +22,16 @@
 #include "gz/rendering/Geometry.hh"
 #include "gz/rendering/Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Grid Grid.hh gz/rendering/Grid
     /// \brief Represents a grid geometry drawn along the XY plane.
     /// If vertical cell count is specified then the grid becomes 3D.
-    class IGNITION_RENDERING_VISIBLE Grid :
+    class GZ_RENDERING_VISIBLE Grid :
       public virtual Geometry
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/Heightmap.hh b/include/gz/rendering/Heightmap.hh
index d4eba3e57..56830712b 100644
--- a/include/gz/rendering/Heightmap.hh
+++ b/include/gz/rendering/Heightmap.hh
@@ -21,11 +21,11 @@
 #include "gz/rendering/Geometry.hh"
 #include "gz/rendering/HeightmapDescriptor.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Heightmap Heightmap.hh gz/rendering/Heightmap
     /// \brief A terrain defined by a heightfield.
diff --git a/include/gz/rendering/HeightmapDescriptor.hh b/include/gz/rendering/HeightmapDescriptor.hh
index d7f416517..86d240956 100644
--- a/include/gz/rendering/HeightmapDescriptor.hh
+++ b/include/gz/rendering/HeightmapDescriptor.hh
@@ -25,17 +25,17 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
   class HeightmapDescriptorPrivate;
   class HeightmapTexturePrivate;
   class HeightmapBlendPrivate;
 
   /// \brief Texture to be used on heightmaps.
-  class IGNITION_RENDERING_VISIBLE HeightmapTexture
+  class GZ_RENDERING_VISIBLE HeightmapTexture
   {
     /// \brief Constructor
     public: HeightmapTexture();
@@ -92,7 +92,7 @@ inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
   };
 
   /// \brief Blend information to be used between textures on heightmaps.
-  class IGNITION_RENDERING_VISIBLE HeightmapBlend
+  class GZ_RENDERING_VISIBLE HeightmapBlend
   {
     /// \brief Constructor
     public: HeightmapBlend();
@@ -143,7 +143,7 @@ inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
   /// \class HeightmapDescriptor HeightmapDescriptor.hh
   /// gz/rendering/HeightmapDescriptor.hh
   /// \brief Describes how a Heightmap should be loaded
-  class IGNITION_RENDERING_VISIBLE HeightmapDescriptor
+  class GZ_RENDERING_VISIBLE HeightmapDescriptor
   {
     /// \brief Constructor
     public: HeightmapDescriptor();
@@ -188,19 +188,19 @@ inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
 
     /// \brief Get the heightmap's final size in world units.
     /// \return The heightmap's size.
-    public: ignition::math::Vector3d Size() const;
+    public: gz::math::Vector3d Size() const;
 
     /// \brief Set the heightmap's final size in world units. Defaults to 1x1x1.
     /// \param[in] _size The heightmap's size factor.
-    public: void SetSize(const ignition::math::Vector3d &_size);
+    public: void SetSize(const gz::math::Vector3d &_size);
 
     /// \brief Get the heightmap's position offset.
     /// \return The heightmap's position offset.
-    public: ignition::math::Vector3d Position() const;
+    public: gz::math::Vector3d Position() const;
 
     /// \brief Set the heightmap's position offset.
     /// \param[in] _position The heightmap's position offset.
-    public: void SetPosition(const ignition::math::Vector3d &_position);
+    public: void SetPosition(const gz::math::Vector3d &_position);
 
     /// \brief Get whether the heightmap uses terrain paging.
     /// \return True if the heightmap uses terrain paging.
diff --git a/include/gz/rendering/Image.hh b/include/gz/rendering/Image.hh
index 37214566d..5bea0e765 100644
--- a/include/gz/rendering/Image.hh
+++ b/include/gz/rendering/Image.hh
@@ -25,15 +25,15 @@
 #include "gz/rendering/PixelFormat.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Image Image.hh gz/rendering/Image.hh
     /// \brief Encapsulates a raw image buffer and relevant properties
-    class IGNITION_RENDERING_VISIBLE Image
+    class GZ_RENDERING_VISIBLE Image
     {
       /// \brief Shared pointer to raw image buffer
       typedef std::shared_ptr<unsigned char> DataPtr;
diff --git a/include/gz/rendering/InertiaVisual.hh b/include/gz/rendering/InertiaVisual.hh
index b9353f6ed..fd1824b26 100644
--- a/include/gz/rendering/InertiaVisual.hh
+++ b/include/gz/rendering/InertiaVisual.hh
@@ -23,16 +23,16 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     /// \class InertiaVisual InertiaVisual.hh
     /// gz/rendering/InertiaVisual.hh
     /// \brief Represents a inertia visual
-    class IGNITION_RENDERING_VISIBLE InertiaVisual :
+    class GZ_RENDERING_VISIBLE InertiaVisual :
       public virtual Visual
     {
       /// \brief Destructor
@@ -41,13 +41,13 @@ namespace ignition
       /// \brief Set the inertial component of the visual
       /// \param[in] _inertial Inertial component of the visual
       public: virtual void SetInertial(
-                  const ignition::math::Inertiald &_inertial) = 0;
+                  const gz::math::Inertiald &_inertial) = 0;
 
       /// \brief Load the Inertia visual from its pose and scale
       /// \param[in] _pose Pose of the Inertia visual
       /// \param[in] _scale Scale factor of the box visual
-      public: virtual void Load(const ignition::math::Pose3d &_pose,
-          const ignition::math::Vector3d &_scale) = 0;
+      public: virtual void Load(const gz::math::Pose3d &_pose,
+          const gz::math::Vector3d &_scale) = 0;
 
       /// \brief Get the box visual
       /// \return Pointer to the box visual
diff --git a/include/gz/rendering/JointVisual.hh b/include/gz/rendering/JointVisual.hh
index 369da9131..507b04ff3 100644
--- a/include/gz/rendering/JointVisual.hh
+++ b/include/gz/rendering/JointVisual.hh
@@ -26,14 +26,14 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Enum for JointVisual types
-    enum IGNITION_RENDERING_VISIBLE JointVisualType
+    enum GZ_RENDERING_VISIBLE JointVisualType
     {
       /// \brief No type
       JVT_NONE           = 0,
@@ -66,7 +66,7 @@ namespace ignition
     /// \class JointVisual JointVisual.hh
     /// gz/rendering/JointVisual.hh
     /// \brief Represents a joint visual
-    class IGNITION_RENDERING_VISIBLE JointVisual :
+    class GZ_RENDERING_VISIBLE JointVisual :
       public virtual Visual
     {
       /// \brief Destructor
@@ -76,12 +76,12 @@ namespace ignition
       /// \param[in] _axis Axis vector.
       /// \param[in] _useParentFrame True if axis vector is expressed in
       /// parent frame.
-      public: virtual void SetAxis(const ignition::math::Vector3d &_axis,
+      public: virtual void SetAxis(const gz::math::Vector3d &_axis,
           bool _useParentFrame = false) = 0;
 
       /// \brief Get axis vector.
       /// \return The axis vector.
-      public: virtual ignition::math::Vector3d Axis() const = 0;
+      public: virtual gz::math::Vector3d Axis() const = 0;
 
       /// \brief Create a parent axis for hinge2 and universal joint types
       /// and attach it to the joint visual.
@@ -90,20 +90,20 @@ namespace ignition
       /// \param[in] _useParentFrame True if axis vector is expressed in
       /// parent frame.
       public: virtual void SetParentAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           const std::string &_parentName,
           bool _useParentFrame = false) = 0;
 
       /// \brief Get parent axis vector.
       /// \return The parent axis vector.
-      public: virtual ignition::math::Vector3d ParentAxis() const = 0;
+      public: virtual gz::math::Vector3d ParentAxis() const = 0;
 
       /// \brief Update an axis' arrow visual.
       /// \param[in] _axis Axis vector.
       /// \param[in] _useParentFrame True if axis vector is expressed in
       /// parent frame.
       /// \return True if axis was updated else false.
-      public: virtual bool UpdateAxis(const ignition::math::Vector3d &_axis,
+      public: virtual bool UpdateAxis(const gz::math::Vector3d &_axis,
           bool _useParentFrame = false) = 0;
 
       /// \brief Update the parent axis' arrow visual if it exists.
@@ -112,7 +112,7 @@ namespace ignition
       /// parent frame.
       /// \return True if parent axis was updated else false.
       public: virtual bool UpdateParentAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           bool _useParentFrame = false) = 0;
 
       /// \brief Set type for joint visual.
diff --git a/include/gz/rendering/LidarVisual.hh b/include/gz/rendering/LidarVisual.hh
index 431ae10dd..f122b33de 100644
--- a/include/gz/rendering/LidarVisual.hh
+++ b/include/gz/rendering/LidarVisual.hh
@@ -26,14 +26,14 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Marker.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Enum for LidarVisual types
-    enum IGNITION_RENDERING_VISIBLE LidarVisualType
+    enum GZ_RENDERING_VISIBLE LidarVisualType
     {
       /// \brief No type
       LVT_NONE           = 0,
@@ -51,7 +51,7 @@ namespace ignition
     /// \class LidarVisual LidarVisual.hh gz/rendering/LidarVisual
     /// \brief A LidarVisual geometry class. The visual appearance is based
     /// on the type specified.
-    class IGNITION_RENDERING_VISIBLE LidarVisual :
+    class GZ_RENDERING_VISIBLE LidarVisual :
       public virtual Visual
     {
       protected: LidarVisual();
@@ -73,7 +73,7 @@ namespace ignition
       /// \param[in] _points Vector of points representing distance of the ray
       /// \param[in] _colors Vector of colors for the rendered points
       public: virtual void SetPoints(const std::vector<double> &_points,
-                        const std::vector<ignition::math::Color> &_colors) = 0;
+                        const std::vector<gz::math::Color> &_colors) = 0;
 
       /// \brief Set minimum vertical angle
       /// \param[in] _minVerticalAngle Minimum vertical angle
@@ -148,11 +148,11 @@ namespace ignition
       /// \brief Set offset of visual
       /// \param[in] _offset The offset of the lidar rays from visual origin
       public: virtual void SetOffset(
-                  const ignition::math::Pose3d _offset) = 0;
+                  const gz::math::Pose3d _offset) = 0;
 
       /// \brief Get offset of visual
       /// \return The offset of the lidar rays from visual origin
-      public: virtual ignition::math::Pose3d  Offset() const = 0;
+      public: virtual gz::math::Pose3d  Offset() const = 0;
 
       /// \brief Get number of points in laser data
       /// \return The number of points in the laser data
diff --git a/include/gz/rendering/Light.hh b/include/gz/rendering/Light.hh
index b594603ad..084b3c30e 100644
--- a/include/gz/rendering/Light.hh
+++ b/include/gz/rendering/Light.hh
@@ -21,15 +21,15 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Node.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Light Light.hh gz/rendering/Light.hh
     /// \brief Represents a light source in the scene graph
-    class IGNITION_RENDERING_VISIBLE Light :
+    class GZ_RENDERING_VISIBLE Light :
       public virtual Node
     {
       /// \brief Destructor
@@ -118,7 +118,7 @@ namespace ignition
 
     /// \class DirectionalLight Light.hh gz/rendering/Light.hh
     /// \brief Represents a infinite directional light
-    class IGNITION_RENDERING_VISIBLE DirectionalLight :
+    class GZ_RENDERING_VISIBLE DirectionalLight :
       public virtual Light
     {
       /// \brief Destructor
@@ -141,7 +141,7 @@ namespace ignition
 
     /// \class PointLight Light.hh gz/rendering/Light.hh
     /// \brief Represents a point light
-    class IGNITION_RENDERING_VISIBLE PointLight :
+    class GZ_RENDERING_VISIBLE PointLight :
       public virtual Light
     {
       /// \brief Destructor
@@ -150,7 +150,7 @@ namespace ignition
 
     /// \class SpotLight Light.hh gz/rendering/Light.hh
     /// \brief Represents a spotlight
-    class IGNITION_RENDERING_VISIBLE SpotLight :
+    class GZ_RENDERING_VISIBLE SpotLight :
       public virtual Light
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/LightVisual.hh b/include/gz/rendering/LightVisual.hh
index a53516ae7..6de0a5bc1 100644
--- a/include/gz/rendering/LightVisual.hh
+++ b/include/gz/rendering/LightVisual.hh
@@ -22,14 +22,14 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
       /// \brief Enum for LightVisual types
-      enum IGNITION_RENDERING_VISIBLE LightVisualType
+      enum GZ_RENDERING_VISIBLE LightVisualType
       {
         /// \brief No type
         LVT_EMPTY                = 0,
@@ -46,7 +46,7 @@ namespace ignition
 
     /// \class LightVisual LightVisual.hh gz/rendering/LightVisual.hh
     /// \brief Represents a light visual
-    class IGNITION_RENDERING_VISIBLE LightVisual :
+    class GZ_RENDERING_VISIBLE LightVisual :
       public virtual Visual
     {
       /// \brief Descructor
diff --git a/include/gz/rendering/Marker.hh b/include/gz/rendering/Marker.hh
index a7b0f8e7d..4342072d8 100644
--- a/include/gz/rendering/Marker.hh
+++ b/include/gz/rendering/Marker.hh
@@ -24,14 +24,14 @@
 #include "gz/rendering/Object.hh"
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Enum for marker types
-    enum IGNITION_RENDERING_VISIBLE MarkerType
+    enum GZ_RENDERING_VISIBLE MarkerType
     {
       /// \brief No type
       MT_NONE           = 0,
@@ -73,7 +73,7 @@ namespace ignition
     /// \class Marker Marker.hh gz/rendering/Marker
     /// \brief A marker geometry class. The marker's visual appearance is based
     /// on the marker type specified.
-    class IGNITION_RENDERING_VISIBLE Marker :
+    class GZ_RENDERING_VISIBLE Marker :
       public virtual Geometry
     {
       protected: Marker();
@@ -101,11 +101,11 @@ namespace ignition
       /// \brief Set the render type of this Marker
       /// \param[in] _markerType The desired render type
       public: virtual void SetType(
-                  const ignition::rendering::MarkerType _markerType) = 0;
+                  const gz::rendering::MarkerType _markerType) = 0;
 
       /// \brief Get the render type of this Marker
       /// \return The render type of the marker
-      public: virtual ignition::rendering::MarkerType Type() const = 0;
+      public: virtual gz::rendering::MarkerType Type() const = 0;
 
       /// \brief Set size of the marker. Only affects MT_POINTS.
       /// e.g. size of rasterized points in pixels
@@ -127,19 +127,19 @@ namespace ignition
       /// \param[in] _color The color the point is set to
       public: virtual void AddPoint(double _x,
                   double _y, double _z,
-                  const ignition::math::Color &_color) = 0;
+                  const gz::math::Color &_color) = 0;
 
       /// \brief Add a point with its respective color to the marker
       /// \param[in] _pt A vector containing the position of the point
       /// \param[in] _color The color the point is set to
-      public: virtual void AddPoint(const ignition::math::Vector3d &_pt,
-                  const ignition::math::Color &_color) = 0;
+      public: virtual void AddPoint(const gz::math::Vector3d &_pt,
+                  const gz::math::Color &_color) = 0;
 
       /// \brief Set an existing point's vector
       /// \param[in] _index The index of the point
       /// \param[in] _value The new positional vector of the point
       public: virtual void SetPoint(unsigned int _index,
-                  const ignition::math::Vector3d &_value) = 0;
+                  const gz::math::Vector3d &_value) = 0;
     };
     }
   }
diff --git a/include/gz/rendering/Material.hh b/include/gz/rendering/Material.hh
index 2da51fcf4..9a34be08f 100644
--- a/include/gz/rendering/Material.hh
+++ b/include/gz/rendering/Material.hh
@@ -26,14 +26,14 @@
 #include "gz/rendering/ShaderType.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief An enum for the type of material
-    enum IGNITION_RENDERING_VISIBLE MaterialType
+    enum GZ_RENDERING_VISIBLE MaterialType
     {
       /// \brief Classic shading, i.e. variants of Phong
       MT_CLASSIC = 0,
@@ -44,7 +44,7 @@ namespace ignition
 
     /// \class Material Material.hh gz/rendering/Material.hh
     /// \brief Represents a surface material of a Geometry
-    class IGNITION_RENDERING_VISIBLE Material :
+    class GZ_RENDERING_VISIBLE Material :
       public virtual Object
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/Mesh.hh b/include/gz/rendering/Mesh.hh
index dd470a4bb..6a134ddd1 100644
--- a/include/gz/rendering/Mesh.hh
+++ b/include/gz/rendering/Mesh.hh
@@ -26,15 +26,15 @@
 #include "gz/rendering/MeshDescriptor.hh"
 #include "gz/rendering/Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Mesh Mesh.hh gz/rendering/Mesh
     /// \brief Represents a collection of mesh geometries
-    class IGNITION_RENDERING_VISIBLE Mesh :
+    class GZ_RENDERING_VISIBLE Mesh :
       public virtual Geometry
     {
       /// \brief Destructor
@@ -132,7 +132,7 @@ namespace ignition
 
     /// \class SubMesh Mesh.hh gz/rendering/Mesh.hh
     /// \brief Represents a single mesh geometry
-    class IGNITION_RENDERING_VISIBLE SubMesh :
+    class GZ_RENDERING_VISIBLE SubMesh :
       public virtual Object
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/MeshDescriptor.hh b/include/gz/rendering/MeshDescriptor.hh
index ad43d5a54..24fadae1b 100644
--- a/include/gz/rendering/MeshDescriptor.hh
+++ b/include/gz/rendering/MeshDescriptor.hh
@@ -24,7 +24,7 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace common
   {
@@ -32,16 +32,16 @@ namespace ignition
   }
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \struct MeshDescriptor MeshDescriptor.hh
     /// gz/rendering/MeshDescriptor.hh
     /// \brief Describes how a Mesh should be loaded
-    struct IGNITION_RENDERING_VISIBLE MeshDescriptor
+    struct GZ_RENDERING_VISIBLE MeshDescriptor
     {
       /// \brief Constructor
       public: MeshDescriptor();
diff --git a/include/gz/rendering/MoveToHelper.hh b/include/gz/rendering/MoveToHelper.hh
index 276ed00d7..2aa83c980 100644
--- a/include/gz/rendering/MoveToHelper.hh
+++ b/include/gz/rendering/MoveToHelper.hh
@@ -27,18 +27,18 @@
 
 #include "gz/rendering/Camera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
     // Inline bracket to help doxygen filtering.
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
       // forward declaration
       class MoveToHelperPrivate;
 
       /// \brief Helper class for animating a user camera to move to a target
       /// entity
-      class IGNITION_RENDERING_VISIBLE MoveToHelper
+      class GZ_RENDERING_VISIBLE MoveToHelper
       {
         public: MoveToHelper();
 
diff --git a/include/gz/rendering/Node.hh b/include/gz/rendering/Node.hh
index 5dcb041da..faa4d8de2 100644
--- a/include/gz/rendering/Node.hh
+++ b/include/gz/rendering/Node.hh
@@ -29,11 +29,11 @@
 #include "gz/rendering/Object.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Alias for a variant that can hold various types of data.
     /// The first type of the variant is std::monostate in order to prevent
@@ -48,7 +48,7 @@ namespace ignition
 
     /// \class Node Node.hh gz/rendering/Node.hh
     /// \brief Represents a single posable node in the scene graph
-    class IGNITION_RENDERING_VISIBLE Node :
+    class GZ_RENDERING_VISIBLE Node :
       public virtual Object
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/Object.hh b/include/gz/rendering/Object.hh
index 24a1bb715..69c994065 100644
--- a/include/gz/rendering/Object.hh
+++ b/include/gz/rendering/Object.hh
@@ -22,16 +22,16 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Object Object.hh gz/rendering/Object.hh
     /// \brief Represents an object present in the scene graph. This includes
     /// sub-meshes, materials, render targets, as well as posable nodes.
-    class IGNITION_RENDERING_VISIBLE Object
+    class GZ_RENDERING_VISIBLE Object
     {
       /// \brief Destructor
       public: virtual ~Object() { }
diff --git a/include/gz/rendering/OrbitViewController.hh b/include/gz/rendering/OrbitViewController.hh
index 5bbf13686..49b14ae00 100644
--- a/include/gz/rendering/OrbitViewController.hh
+++ b/include/gz/rendering/OrbitViewController.hh
@@ -27,11 +27,11 @@
 #include "gz/rendering/Camera.hh"
 #include "gz/rendering/ViewController.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations
     class OrbitViewControllerPrivate;
@@ -39,7 +39,7 @@ namespace ignition
     /// \class OrbitViewController OrbitViewController.hh
     /// gz/rendering/OrbitViewController.hh
     /// \brief A camera view controller
-    class IGNITION_RENDERING_VISIBLE OrbitViewController
+    class GZ_RENDERING_VISIBLE OrbitViewController
         : public virtual ViewController
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/OrthoViewController.hh b/include/gz/rendering/OrthoViewController.hh
index 47a297f46..2c906eccd 100644
--- a/include/gz/rendering/OrthoViewController.hh
+++ b/include/gz/rendering/OrthoViewController.hh
@@ -23,18 +23,18 @@
 
 #include "gz/rendering/ViewController.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declare private data pointer.
     class OrthoViewControllerPrivate;
 
     /// \class OrthoViewController OrthoViewController.hh
     /// \brief Orthographic view controller
-    class IGNITION_RENDERING_VISIBLE OrthoViewController
+    class GZ_RENDERING_VISIBLE OrthoViewController
         : public virtual ViewController
     {
       /// \brief Constructor
diff --git a/include/gz/rendering/ParticleEmitter.hh b/include/gz/rendering/ParticleEmitter.hh
index aad003b38..b2829317b 100644
--- a/include/gz/rendering/ParticleEmitter.hh
+++ b/include/gz/rendering/ParticleEmitter.hh
@@ -26,14 +26,14 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Enum for emitter types.
-    enum IGNITION_RENDERING_VISIBLE EmitterType
+    enum GZ_RENDERING_VISIBLE EmitterType
     {
       /// \brief Point emitter.
       EM_POINT            = 0,
@@ -55,7 +55,7 @@ namespace ignition
     /// gz/rendering/ParticleEmitter.hh
     //
     /// \brief Class to manage a particle emitter.
-    class IGNITION_RENDERING_VISIBLE ParticleEmitter :
+    class GZ_RENDERING_VISIBLE ParticleEmitter :
       public virtual Visual
     {
       /// \brief Destructor
@@ -78,7 +78,7 @@ namespace ignition
       /// \return The emitter size. See SetEmitterSize() for the interpretation
       /// of the dimensions depending on the emitter type.
       /// \sa SetEmitterSize
-      public: virtual ignition::math::Vector3d EmitterSize() const = 0;
+      public: virtual gz::math::Vector3d EmitterSize() const = 0;
 
       /// \brief Set the size of the emitter where the particles are sampled.
       /// Default value is (1, 1, 1).
@@ -96,7 +96,7 @@ namespace ignition
       /// \param[in] _size Size of the emitter (width, height, depth).
       /// \sa EmitterSize
       public: virtual void SetEmitterSize(
-                  const ignition::math::Vector3d &_size) = 0;
+                  const gz::math::Vector3d &_size) = 0;
 
       /// \brief Get how many particles per second should be emitted.
       /// \return Particles per second.
@@ -136,14 +136,14 @@ namespace ignition
       /// \brief Get the particle dimensions (width, height, depth).
       /// \return Particle dimensions.
       /// \sa SetParticleSize
-      public: virtual ignition::math::Vector3d ParticleSize() const = 0;
+      public: virtual gz::math::Vector3d ParticleSize() const = 0;
 
       /// \brief Set the particle dimensions (width, height, depth).
       /// Default value is {1, 1, 1}.
       /// \param[in] _size Particle dimensions.
       /// \sa ParticleSize
       public: virtual void SetParticleSize(
-                  const ignition::math::Vector3d &_size) = 0;
+                  const gz::math::Vector3d &_size) = 0;
 
       /// \brief Get the number of seconds each particle will ’live’ for before
       /// being destroyed.
@@ -194,13 +194,13 @@ namespace ignition
       /// \return Start color.
       /// \sa ColorEnd
       /// \sa SetColorRange
-      public: virtual ignition::math::Color ColorStart() const = 0;
+      public: virtual gz::math::Color ColorStart() const = 0;
 
       /// \brief Get the end color of the particles.
       /// \return End color.
       /// \sa ColorStart
       /// \sa SetColorRange
-      public: virtual ignition::math::Color ColorEnd() const = 0;
+      public: virtual gz::math::Color ColorEnd() const = 0;
 
       /// \brief Sets a color for all particle emitted.
       /// The actual color will be interpolated between these two colors
@@ -213,8 +213,8 @@ namespace ignition
       /// \sa ColorStart
       /// \sa ColorEnd
       public: virtual void SetColorRange(
-                  const ignition::math::Color &_colorStart,
-                  const ignition::math::Color &_colorEnd) = 0;
+                  const gz::math::Color &_colorStart,
+                  const gz::math::Color &_colorEnd) = 0;
 
       /// \brief Get the amount by which to scale the particles in both x and y
       /// direction per second.
diff --git a/include/gz/rendering/PixelFormat.hh b/include/gz/rendering/PixelFormat.hh
index c064c209f..3617f8c43 100644
--- a/include/gz/rendering/PixelFormat.hh
+++ b/include/gz/rendering/PixelFormat.hh
@@ -21,15 +21,15 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \enum PixelFormat PixelFormat.hh gz/rendering/PixelFormat.hh
     /// \brief Image pixel format types
-    enum IGNITION_RENDERING_VISIBLE PixelFormat
+    enum GZ_RENDERING_VISIBLE PixelFormat
     {
       /// < Unknown or errant type
       PF_UNKNOWN      = 0,
@@ -63,7 +63,7 @@ namespace ignition
 
     /// \class PixelUtil PixelFormat.hh gz/rendering/PixelFormat.hh
     /// \brief Provides supporting functions for PixelFormat enum
-    class IGNITION_RENDERING_VISIBLE PixelUtil
+    class GZ_RENDERING_VISIBLE PixelUtil
     {
       /// \brief Determine if given format is valid PixelFormat enum
       /// \param[in] _format Enum value to be evaluated
diff --git a/include/gz/rendering/RayQuery.hh b/include/gz/rendering/RayQuery.hh
index 5faa8ab7b..b949ee7a2 100644
--- a/include/gz/rendering/RayQuery.hh
+++ b/include/gz/rendering/RayQuery.hh
@@ -25,14 +25,14 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief A class that stores ray query intersection results.
-    class IGNITION_RENDERING_VISIBLE RayQueryResult
+    class GZ_RENDERING_VISIBLE RayQueryResult
     {
       /// \brief Intersection distance
       public: double distance = -1;
@@ -60,7 +60,7 @@ namespace ignition
 
     /// \class RayQuery RayQuery.hh gz/rendering/RayQuery.hh
     /// \brief A Ray Query class used for computing ray object intersections
-    class IGNITION_RENDERING_VISIBLE RayQuery
+    class GZ_RENDERING_VISIBLE RayQuery
         : public virtual Object
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/RenderEngine.hh b/include/gz/rendering/RenderEngine.hh
index 844433e04..df09b7b9d 100644
--- a/include/gz/rendering/RenderEngine.hh
+++ b/include/gz/rendering/RenderEngine.hh
@@ -24,17 +24,17 @@
 #include "gz/rendering/RenderTypes.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class RenderEngine RenderEngine.hh gz/rendering/RenderEngine.hh
     /// \brief An abstract interface to a concrete render-engine. A
     /// RenderEngine is responsible for initializing a render-engine as well as
     /// creating, storing, and destroying scenes.
-    class IGNITION_RENDERING_VISIBLE RenderEngine
+    class GZ_RENDERING_VISIBLE RenderEngine
     {
       /// \brief Destructor
       public: virtual ~RenderEngine() { }
diff --git a/include/gz/rendering/RenderEngineManager.hh b/include/gz/rendering/RenderEngineManager.hh
index e24d52a89..bbae29f20 100644
--- a/include/gz/rendering/RenderEngineManager.hh
+++ b/include/gz/rendering/RenderEngineManager.hh
@@ -27,11 +27,11 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations.
     class RenderEngine;
@@ -43,7 +43,7 @@ namespace ignition
     /// render-engines available at runtime. RenderEngine objects should not
     /// be access directly, but instead via the RenderEngineManager to maintain
     /// a flexible render-engine agnostic design.
-    class IGNITION_RENDERING_VISIBLE RenderEngineManager :
+    class GZ_RENDERING_VISIBLE RenderEngineManager :
       public virtual common::SingletonT<RenderEngineManager>
     {
       /// \brief Constructor
@@ -141,7 +141,7 @@ namespace ignition
       IGN_UTILS_WARN_RESUME__DLL_INTERFACE_MISSING
 
       /// \brief required SingletonT friendship
-      private: friend class ignition::common::SingletonT<RenderEngineManager>;
+      private: friend class gz::common::SingletonT<RenderEngineManager>;
     };
     }
   }
diff --git a/include/gz/rendering/RenderEnginePlugin.hh b/include/gz/rendering/RenderEnginePlugin.hh
index a6cfd3c66..447baa0fc 100644
--- a/include/gz/rendering/RenderEnginePlugin.hh
+++ b/include/gz/rendering/RenderEnginePlugin.hh
@@ -26,18 +26,18 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declarations
     class RenderEngine;
     class RenderEnginePluginPrivate;
 
     /// \brief Base plugin class for render engines
-    class IGNITION_RENDERING_VISIBLE RenderEnginePlugin
+    class GZ_RENDERING_VISIBLE RenderEnginePlugin
     {
       /// \brief Constructor
       public: RenderEnginePlugin();
diff --git a/include/gz/rendering/RenderPass.hh b/include/gz/rendering/RenderPass.hh
index f4ac9f06c..adc5e925d 100644
--- a/include/gz/rendering/RenderPass.hh
+++ b/include/gz/rendering/RenderPass.hh
@@ -21,17 +21,17 @@
 #include "gz/rendering/Object.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class RenderPass RenderPass.hh gz/rendering/RenderPass.hh
     /// \brief A render pass can be added to a camera to affect how the scene
     /// is rendered. It can be used to add post-processing effects. Multiple
     /// passes can be chained together.
-    class IGNITION_RENDERING_VISIBLE RenderPass
+    class GZ_RENDERING_VISIBLE RenderPass
       : public virtual Object
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/RenderPassSystem.hh b/include/gz/rendering/RenderPassSystem.hh
index 7182532b5..23b28dc94 100644
--- a/include/gz/rendering/RenderPassSystem.hh
+++ b/include/gz/rendering/RenderPassSystem.hh
@@ -29,11 +29,11 @@
 #include "gz/rendering/RenderPass.hh"
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class RenderPassSystemPrivate;
@@ -42,7 +42,7 @@ namespace ignition
      * gz/rendering/RenderPassSystem.hh
      */
     /// \brief A factory interface for creating render passes
-    class IGNITION_RENDERING_VISIBLE RenderPassFactory
+    class GZ_RENDERING_VISIBLE RenderPassFactory
     {
       /// \brief Instantiate new render pass
       /// \return New render pass
@@ -53,7 +53,7 @@ namespace ignition
      * gz/rendering/RenderPassSystem.hh
      */
     /// \brief A class for creating and managing render passes
-    class IGNITION_RENDERING_VISIBLE RenderPassSystem
+    class GZ_RENDERING_VISIBLE RenderPassSystem
     {
       /// \brief Constructor
       public: RenderPassSystem();
@@ -93,11 +93,11 @@ namespace ignition
     ///
     /// Use this macro to register render pass with the render pass factory.
     #define IGN_RENDERING_REGISTER_RENDER_PASS(classname, interface) \
-    class classname##Factory : public ignition::rendering::RenderPassFactory \
+    class classname##Factory : public gz::rendering::RenderPassFactory \
     { \
       public: classname##Factory() \
               { \
-                ignition::rendering::RenderPassSystem::Register( \
+                gz::rendering::RenderPassSystem::Register( \
                     typeid(interface).name(), this); \
               } \
       public: RenderPass *New() const override \
diff --git a/include/gz/rendering/RenderTarget.hh b/include/gz/rendering/RenderTarget.hh
index 35c16f5a2..06087a70b 100644
--- a/include/gz/rendering/RenderTarget.hh
+++ b/include/gz/rendering/RenderTarget.hh
@@ -26,15 +26,15 @@
 #include "gz/rendering/Image.hh"
 #include "gz/rendering/Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class RenderTarget RenderTarget.hh gz/rendering/RenderTarget.hh
     /// \brief Represents a render-target to which cameras can render images.
-    class IGNITION_RENDERING_VISIBLE RenderTarget :
+    class GZ_RENDERING_VISIBLE RenderTarget :
       public virtual Object
     {
       /// \brief Destructor
@@ -100,7 +100,7 @@ namespace ignition
      */
     /// \brief Represents a off-screen render-texture to which cameras can
     /// render images.
-    class IGNITION_RENDERING_VISIBLE RenderTexture :
+    class GZ_RENDERING_VISIBLE RenderTexture :
       public virtual RenderTarget
     {
       /// \brief Destructor
@@ -123,7 +123,7 @@ namespace ignition
      */
     /// \brief Represents a on-screen render-window to which cameras can
     /// render images.
-    class IGNITION_RENDERING_VISIBLE RenderWindow :
+    class GZ_RENDERING_VISIBLE RenderWindow :
       public virtual RenderTarget
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/RenderTypes.hh b/include/gz/rendering/RenderTypes.hh
index fa869265a..117698291 100644
--- a/include/gz/rendering/RenderTypes.hh
+++ b/include/gz/rendering/RenderTypes.hh
@@ -37,11 +37,11 @@
 /// \brief Render visuals that are selectable mask.
 #define IGN_VISIBILITY_SELECTABLE      0x00000002
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     using shared_ptr = std::shared_ptr<T>;
diff --git a/include/gz/rendering/RenderingIface.hh b/include/gz/rendering/RenderingIface.hh
index 13825ee77..aca11bce8 100644
--- a/include/gz/rendering/RenderingIface.hh
+++ b/include/gz/rendering/RenderingIface.hh
@@ -26,49 +26,49 @@
 #include "gz/rendering/Export.hh"
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class RenderEngine;
 
     /// \brief Load shared render-engine resources
     /// \return True if successful
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     bool load();
 
     /// \brief Initialized shared render-engine features
     /// \return True if successful
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     bool init();
 
     /// \brief Destroy all render-engines and related resources
     /// \return True if successful
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     bool fini();
 
     /// \brief Get the number of available render-engines.
     /// \return The number of available render-engines
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     unsigned int engineCount();
 
     /// \brief Determine if a render-engine is registered under the given name
     /// \param[in] _name Name of the desired render-engine
     /// \return True if a render-engine is registered under the given name
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     bool hasEngine(const std::string &_name);
 
     /// \brief Determine if a render-engine is already loaded.
     /// \param[in] _name Name of the desired render-engine
     /// \return True if a render-engine is loaded under the given name
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     bool isEngineLoaded(const std::string &_name);
 
     /// \brief Get the names of all engines currently loaded.
     /// \return All the engines currently loaded.
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     std::vector<std::string> loadedEngines();
 
     /// \brief Get the render-engine registered under the given name. If no
@@ -79,7 +79,7 @@ namespace ignition
     /// \param[in] _params Parameters to be passed to the render engine.
     /// \param[in] _path Another search path for rendering engine plugin.
     /// \return The specified render-engine
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     RenderEngine *engine(const std::string &_name,
         const std::map<std::string, std::string> &_params = {},
         const std::string &_path = "");
@@ -91,7 +91,7 @@ namespace ignition
     /// \param[in] _params Parameters to be passed to the render engine.
     /// \param[in] _path Another search path for rendering engine plugin.
     /// \return The specified render-engine
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     RenderEngine *engine(const unsigned int _index,
         const std::map<std::string, std::string> &_params = {},
         const std::string &_path = "");
@@ -99,38 +99,38 @@ namespace ignition
     /// \brief Unload the render-engine registered under the given name.
     /// \param[in] _name Name of the desired render-engine
     /// \return True if the engine is unloaded
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     bool unloadEngine(const std::string &_name);
 
     /// \brief Register a new render-engine under the given name. If the given
     /// name is already in use, the render-engine will not be registered.
     /// \param[in] _name Name the render-engine will be registered under
     /// \param[in] _engine Render-engine to be registered
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     void registerEngine(const std::string &_name, RenderEngine *_engine);
 
     /// \brief Unregister a render-engine registered under the given name.
     /// If the no render-engine is registered under the given name no work
     /// will be done.
     /// \param[in] _name Name of the render-engine to unregister
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     void unregisterEngine(const std::string &_name);
 
     /// \brief Unregister the given render-engine. If the given render-engine
     /// is not currently registered, no work will be done.
     /// \param[in] _engine Render-engine to unregister
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     void unregisterEngine(RenderEngine *_engine);
 
     /// \brief Unregister a render-engine at the given index. If the no
     /// render-engine is registered at the given index, no work will be done.
     /// \param[in] _index Index of the render-engine to unregister
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     void unregisterEngine(const unsigned int _index);
 
     /// \brief Set the plugin paths from which render engines can be loaded.
     /// \param[in] _paths The list of the plugin paths
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     void setPluginPaths(const std::list<std::string> &_paths);
 
     /// \brief Most applications will only have one rendering engine loaded
@@ -141,7 +141,7 @@ namespace ignition
     /// engine or scene.
     ///
     /// \return Pointer to a scene that was found, null if no scene is loaded.
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     ScenePtr sceneFromFirstRenderEngine();
     }
   }
diff --git a/include/gz/rendering/Scene.hh b/include/gz/rendering/Scene.hh
index 0493e31b1..bfe20bebb 100644
--- a/include/gz/rendering/Scene.hh
+++ b/include/gz/rendering/Scene.hh
@@ -33,11 +33,11 @@
 #include "gz/rendering/Storage.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class RenderEngine;
 
@@ -45,7 +45,7 @@ namespace ignition
     /// \brief Manages a single scene-graph. This class updates scene-wide
     /// properties and holds the root scene node. A Scene also serves as a
     /// factory for all scene objects.
-    class IGNITION_RENDERING_VISIBLE Scene
+    class GZ_RENDERING_VISIBLE Scene
     {
       /// \brief Destructor
       public: virtual ~Scene() { }
diff --git a/include/gz/rendering/SegmentationCamera.hh b/include/gz/rendering/SegmentationCamera.hh
index 565bba1ad..3aaf120d3 100644
--- a/include/gz/rendering/SegmentationCamera.hh
+++ b/include/gz/rendering/SegmentationCamera.hh
@@ -26,7 +26,7 @@
 #include "gz/rendering/Camera.hh"
 
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
@@ -42,13 +42,13 @@ namespace ignition
       ST_PANOPTIC = 1
     };
 
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \class SegmentationCamera SegmentationCamera.hh
     /// gz/rendering/SegmentationCamera.hh
     /// \brief Poseable Segmentation camera used for rendering the scene graph.
     /// This camera is designed to produce segmentation data, instead of a 2D
     /// image.
-    class IGNITION_RENDERING_VISIBLE SegmentationCamera :
+    class GZ_RENDERING_VISIBLE SegmentationCamera :
       public virtual Camera
     {
       /// \brief Destructor
@@ -68,7 +68,7 @@ namespace ignition
       /// The callback function arguments are:
       /// <segmentation data, width, height, channels, format>
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr
+      public: virtual gz::common::ConnectionPtr
         ConnectNewSegmentationFrame(
           std::function<void(const uint8_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) = 0;
diff --git a/include/gz/rendering/Sensor.hh b/include/gz/rendering/Sensor.hh
index 7415a0c0a..7bf0a928f 100644
--- a/include/gz/rendering/Sensor.hh
+++ b/include/gz/rendering/Sensor.hh
@@ -20,16 +20,16 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Node.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Sensor Sensor.hh gz/rendering/Sensor.hh
     /// \brief Represents a scene sensor. The most obvious example is a camera,
     /// but it can be anything that generates output from the scene.
-    class IGNITION_RENDERING_VISIBLE Sensor :
+    class GZ_RENDERING_VISIBLE Sensor :
       public virtual Node
     {
       /// \brief Sensor
diff --git a/include/gz/rendering/ShaderParam.hh b/include/gz/rendering/ShaderParam.hh
index 21a336768..f60830ff5 100644
--- a/include/gz/rendering/ShaderParam.hh
+++ b/include/gz/rendering/ShaderParam.hh
@@ -28,17 +28,17 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief forward declaration
     class ShaderParamPrivate;
 
     /// \brief a variant type that holds params that can be passed to a shader
-    class IGNITION_RENDERING_VISIBLE ShaderParam
+    class GZ_RENDERING_VISIBLE ShaderParam
     {
       public: enum ParamType : uint16_t
       {
diff --git a/include/gz/rendering/ShaderParams.hh b/include/gz/rendering/ShaderParams.hh
index b575d081f..3487296ef 100644
--- a/include/gz/rendering/ShaderParams.hh
+++ b/include/gz/rendering/ShaderParams.hh
@@ -25,24 +25,24 @@
 #include "gz/rendering/Export.hh"
 #include "gz/rendering/ShaderParam.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief forward declaration
     class ShaderParamsPrivate;
 
     /// \brief a map that holds params to be passed to a shader
-    class IGNITION_RENDERING_VISIBLE ShaderParams
+    class GZ_RENDERING_VISIBLE ShaderParams
     {
       /// \brief forward declaration
       class IteratorPrivate;
 
       /// \brief Iterator for looping through params
       /// \remarks implements a forward-iterator
-      class IGNITION_RENDERING_VISIBLE Iterator
+      class GZ_RENDERING_VISIBLE Iterator
       {
         /// \brief Default constructor
         public: Iterator();
diff --git a/include/gz/rendering/ShaderType.hh b/include/gz/rendering/ShaderType.hh
index 8377dcd51..aa2519341 100644
--- a/include/gz/rendering/ShaderType.hh
+++ b/include/gz/rendering/ShaderType.hh
@@ -21,17 +21,17 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \enum ShaderType ShaderType.hh gz/rendering/ShaderType.hh
     /// \brief Available types of shaders. Note that not all rendering-engines
     /// will be able to use each type. They will instead default to the closest
     /// alternative.
-    enum IGNITION_RENDERING_VISIBLE ShaderType
+    enum GZ_RENDERING_VISIBLE ShaderType
     {
       /// \brief Unknown or errant type
       ST_UNKNOWN  = 0,
@@ -54,7 +54,7 @@ namespace ignition
 
     /// \class ShaderUtil ShaderType.hh gz/rendering/ShaderType.hh
     /// \brief Provides supporting functions for ShaderType enum
-    class IGNITION_RENDERING_VISIBLE ShaderUtil
+    class GZ_RENDERING_VISIBLE ShaderUtil
     {
       /// \brief Determine if given type is valid ShaderType enum
       /// \param[in] _type Enum value to be evaluated
diff --git a/include/gz/rendering/Storage.hh b/include/gz/rendering/Storage.hh
index 4396dccb1..954474fdc 100644
--- a/include/gz/rendering/Storage.hh
+++ b/include/gz/rendering/Storage.hh
@@ -36,17 +36,17 @@
 #undef DestroyAll
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Map Storage.hh gz/rendering/Storage.hh
     /// \brief Storage map from std::string to template class T
     /// \tparam T The storage element type
     template <class T>
-    class IGNITION_RENDERING_VISIBLE Map
+    class GZ_RENDERING_VISIBLE Map
     {
       /// \typedef TPtr
       /// \brief Shared pointer to T
@@ -111,7 +111,7 @@ namespace ignition
     /// will ensure that each element's name and ID are unique.
     /// \tparam T The storage element type
     template <class T>
-    class IGNITION_RENDERING_VISIBLE Store
+    class GZ_RENDERING_VISIBLE Store
     {
       /// \typedef TPtr
       /// \brief Shared pointer to T
@@ -224,7 +224,7 @@ namespace ignition
     /// a single composite store.
     /// \tparam T The storage element type
     template <class T>
-    class IGNITION_RENDERING_VISIBLE CompositeStore :
+    class GZ_RENDERING_VISIBLE CompositeStore :
       public Store<T>
     {
       /// \typedef TPtr
@@ -288,7 +288,7 @@ namespace ignition
     /// \tparam T New storage type
     /// \tparam U Some derived class of T
     template <class T, class U>
-    class IGNITION_RENDERING_VISIBLE StoreWrapper :
+    class GZ_RENDERING_VISIBLE StoreWrapper :
       public Store<T>
     {
       public: virtual ~StoreWrapper() { }
@@ -296,7 +296,7 @@ namespace ignition
 
 // armhf failed to build with this code. It can not be removed for the rest
 // of arches to keep ABI but should be removed in major versions unreleased
-// see https://github.com/ignitionrobotics/ign-rendering/pull/457
+// see https://github.com/gazebosim/gz-rendering/pull/457
 #ifndef __ARM_PCS_VFP
     template class Store<Scene>;
     template class Store<Node>;
diff --git a/include/gz/rendering/Text.hh b/include/gz/rendering/Text.hh
index e443edcbf..b5b3f08d9 100644
--- a/include/gz/rendering/Text.hh
+++ b/include/gz/rendering/Text.hh
@@ -26,11 +26,11 @@
 #include "gz/rendering/Geometry.hh"
 #include "gz/rendering/Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \enum TextHorizontalAlign
     /// \brief Text Horizontal alignment
@@ -59,7 +59,7 @@ namespace ignition
     /// \class Text Text.hh gz/rendering/Text
     /// \brief Represents a billboard text geometry that is always facing the
     /// camera.
-    class IGNITION_RENDERING_VISIBLE Text :
+    class GZ_RENDERING_VISIBLE Text :
       public virtual Geometry
     {
       /// \brief Constructor
@@ -91,12 +91,12 @@ namespace ignition
       /// \brief Set the text color.
       /// \param[in] _color Text color.
       /// \sa Color()
-      public: virtual void SetColor(const ignition::math::Color &_color) = 0;
+      public: virtual void SetColor(const gz::math::Color &_color) = 0;
 
       /// \brief Get the text color.
       /// \return Text color.
       /// \sa SetColor()
-      public: virtual ignition::math::Color Color() const = 0;
+      public: virtual gz::math::Color Color() const = 0;
 
       /// \brief Set the height of the character in meters.
       /// \param[in] _height Height of the characters.
@@ -155,7 +155,7 @@ namespace ignition
 
       /// \brief Get the axis aligned bounding box of the text.
       /// \return The axis aligned bounding box.
-      public: virtual ignition::math::AxisAlignedBox AABB() const = 0;
+      public: virtual gz::math::AxisAlignedBox AABB() const = 0;
     };
     }
   }
diff --git a/include/gz/rendering/ThermalCamera.hh b/include/gz/rendering/ThermalCamera.hh
index 9a308d5fe..17189e472 100644
--- a/include/gz/rendering/ThermalCamera.hh
+++ b/include/gz/rendering/ThermalCamera.hh
@@ -20,11 +20,11 @@
 #include <string>
 #include "gz/rendering/Camera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /* \class ThermalCamera ThermalCamera.hh \
       * gz/rendering/ThermalCamera.hh
      */
@@ -37,7 +37,7 @@ namespace ignition
     /// are modeled as a function of depth (which is not how a real thermal
     /// sensor works). Ideally we support heatmaps for visuals in order to
     /// produce more realistic temperature output.
-    class IGNITION_RENDERING_VISIBLE ThermalCamera :
+    class GZ_RENDERING_VISIBLE ThermalCamera :
       public virtual Camera
     {
       /// \brief Destructor
@@ -115,7 +115,7 @@ namespace ignition
       /// \param[in] _subscriber Subscriber callback function. The callback
       /// function arguments are: <thermal data, width, height, depth, format>
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewThermalFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewThermalFrame(
           std::function<void(const uint16_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) = 0;
     };
diff --git a/include/gz/rendering/TransformController.hh b/include/gz/rendering/TransformController.hh
index 1a60fbdb1..0695da6d5 100644
--- a/include/gz/rendering/TransformController.hh
+++ b/include/gz/rendering/TransformController.hh
@@ -30,11 +30,11 @@
 #include "gz/rendering/GizmoVisual.hh"
 #include "gz/rendering/TransformType.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations
     class TransformControllerPrivate;
@@ -43,7 +43,7 @@ namespace ignition
      * gz/rendering/TransformController.hh
      */
     /// \brief An transform tool for translating, rotating, and scaling objects.
-    class IGNITION_RENDERING_VISIBLE TransformController
+    class GZ_RENDERING_VISIBLE TransformController
     {
       /// \brief Constructor
       public: TransformController();
@@ -134,8 +134,8 @@ namespace ignition
       /// \param[in] _sensitivity Sensitivity of point snapping, in terms of a
       /// percentage of the interval.
       /// \return Snapped 3D point.
-      public: static ignition::math::Vector3d SnapPoint(
-          const ignition::math::Vector3d &_point, const double _interval = 1.0,
+      public: static gz::math::Vector3d SnapPoint(
+          const gz::math::Vector3d &_point, const double _interval = 1.0,
           const double _sensitivity = 0.4);
 
       /// \brief Start the transform process. To be used with helper functions
diff --git a/include/gz/rendering/TransformType.hh b/include/gz/rendering/TransformType.hh
index 158b4d07b..32930e86d 100644
--- a/include/gz/rendering/TransformType.hh
+++ b/include/gz/rendering/TransformType.hh
@@ -23,15 +23,15 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \enum TransformAxis
     /// \brief Unique identifiers for transformation axes.
-    enum IGNITION_RENDERING_VISIBLE TransformAxis
+    enum GZ_RENDERING_VISIBLE TransformAxis
     {
       /// \brief No axis
       TA_NONE = 0,
@@ -57,7 +57,7 @@ namespace ignition
 
     /// \enum TransformMode
     /// \brief Unique identifiers for transformation modes.
-    enum IGNITION_RENDERING_VISIBLE TransformMode
+    enum GZ_RENDERING_VISIBLE TransformMode
     {
       /// \brief Inactive state
       TM_NONE = 0,
@@ -71,7 +71,7 @@ namespace ignition
 
     /// \enum TransformSpace
     /// \brief Unique identifiers for transformation spaces.
-    enum IGNITION_RENDERING_VISIBLE TransformSpace
+    enum GZ_RENDERING_VISIBLE TransformSpace
     {
       /// \brief transformation in local frame
       TS_LOCAL,
diff --git a/include/gz/rendering/Utils.hh b/include/gz/rendering/Utils.hh
index cc552d4d1..d36b99729 100644
--- a/include/gz/rendering/Utils.hh
+++ b/include/gz/rendering/Utils.hh
@@ -31,13 +31,13 @@
 #include "gz/rendering/RayQuery.hh"
 
 
-namespace ignition
+namespace gz
 {
   /// \brief Rendering classes and function useful in robot applications.
   namespace rendering
   {
     // Inline bracket to help doxygen filtering.
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Retrieve the first point on a surface in the 3D scene hit by a
     /// ray cast from the given 2D screen coordinates.
@@ -46,7 +46,7 @@ namespace ignition
     /// \param[in] _rayQuery Ray query for mouse clicks
     /// \param[in] _maxDistance maximum distance to check the collision
     /// \return 3D coordinates of a point in the 3D scene.
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     math::Vector3d screenToScene(
         const math::Vector2i &_screenPos,
         const CameraPtr &_camera,
@@ -61,7 +61,7 @@ namespace ignition
     /// \param[inout] _rayResult Ray query result
     /// \param[in] _maxDistance maximum distance to check the collision
     /// \return 3D coordinates of a point in the 3D scene.
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     math::Vector3d screenToScene(
         const math::Vector2i &_screenPos,
         const CameraPtr &_camera,
@@ -76,7 +76,7 @@ namespace ignition
     /// \param[in] _rayQuery Ray query for mouse clicks
     /// \param[in] _offset Offset along the plane normal
     /// \return 3D coordinates of a point in the 3D scene.
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     math::Vector3d screenToPlane(
       const math::Vector2i &_screenPos,
       const CameraPtr &_camera,
@@ -85,7 +85,7 @@ namespace ignition
 
     /// \brief Get the screen scaling factor.
     /// \return The screen scaling factor.
-    IGNITION_RENDERING_VISIBLE
+    GZ_RENDERING_VISIBLE
     float screenScalingFactor();
 
     /// \brief Transform a bounding box.
@@ -93,10 +93,10 @@ namespace ignition
     /// \param[in] _pose Pose used to transform the bounding box.
     /// \return Vertices of the transformed bounding box in
     /// world coordinates.
-    IGNITION_RENDERING_VISIBLE
-    ignition::math::AxisAlignedBox transformAxisAlignedBox(
-        const ignition::math::AxisAlignedBox &_box,
-        const ignition::math::Pose3d &_pose);
+    GZ_RENDERING_VISIBLE
+    gz::math::AxisAlignedBox transformAxisAlignedBox(
+        const gz::math::AxisAlignedBox &_box,
+        const gz::math::Pose3d &_pose);
     }
   }
 }
diff --git a/include/gz/rendering/ViewController.hh b/include/gz/rendering/ViewController.hh
index 8c7530e7a..095ed9400 100644
--- a/include/gz/rendering/ViewController.hh
+++ b/include/gz/rendering/ViewController.hh
@@ -23,16 +23,16 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Camera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class ViewController ViewController.hh
     ///   gz/rendering/ViewController.hh
     /// \brief A camera view controller
-    class IGNITION_RENDERING_VISIBLE ViewController
+    class GZ_RENDERING_VISIBLE ViewController
     {
       /// \brief Destructor
       public: virtual ~ViewController() { }
diff --git a/include/gz/rendering/Visual.hh b/include/gz/rendering/Visual.hh
index 1d8e5d39e..7f9aca51b 100644
--- a/include/gz/rendering/Visual.hh
+++ b/include/gz/rendering/Visual.hh
@@ -22,15 +22,15 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/Node.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \class Visual Visual.hh gz/rendering/Visual.hh
     /// \brief Represents a visual node in a scene graph. A Visual is the only
     /// node that can have Geometry and other Visual children.
-    class IGNITION_RENDERING_VISIBLE Visual :
+    class GZ_RENDERING_VISIBLE Visual :
       public virtual Node
     {
       /// \brief Destructor
@@ -136,11 +136,11 @@ namespace ignition
 
       /// \brief Get the bounding box in world frame coordinates.
       /// \return The axis aligned bounding box
-      public: virtual ignition::math::AxisAlignedBox BoundingBox() const = 0;
+      public: virtual gz::math::AxisAlignedBox BoundingBox() const = 0;
 
       /// \brief Get the local bounding box of the visual.
       /// \return The local bounding box
-      public: virtual ignition::math::AxisAlignedBox LocalBoundingBox()
+      public: virtual gz::math::AxisAlignedBox LocalBoundingBox()
               const = 0;
 
       /// \brief Clone the visual (and its children) with a new name.
diff --git a/include/gz/rendering/WideAngleCamera.hh b/include/gz/rendering/WideAngleCamera.hh
index dbf60fcf1..3df4c7dbd 100644
--- a/include/gz/rendering/WideAngleCamera.hh
+++ b/include/gz/rendering/WideAngleCamera.hh
@@ -25,16 +25,16 @@
 #include "gz/rendering/CameraLens.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class WideAngleCamera WideAngleCamera.hh
     ///     gz/rendering/WideAngleCamera.hh
     /// \brief Wide angle camera class
-    class IGNITION_RENDERING_VISIBLE WideAngleCamera :
+    class GZ_RENDERING_VISIBLE WideAngleCamera :
       public virtual Camera
     {
       /// \brief Destructor
diff --git a/include/gz/rendering/WireBox.hh b/include/gz/rendering/WireBox.hh
index e44b1ff3b..9c5647b08 100644
--- a/include/gz/rendering/WireBox.hh
+++ b/include/gz/rendering/WireBox.hh
@@ -21,15 +21,15 @@
 #include "gz/rendering/Geometry.hh"
 #include "gz/math/AxisAlignedBox.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class WireBox WireBox.hh gz/rendering/WireBox
     /// \brief Draws a wireframe box.
-    class IGNITION_RENDERING_VISIBLE WireBox :
+    class GZ_RENDERING_VISIBLE WireBox :
       public virtual Geometry
     {
       /// \brief Constructor
@@ -41,11 +41,11 @@ namespace ignition
       /// \brief Set the axis aligned box
       /// \param[in] _box The axis aligned box
       public: virtual void SetBox(
-                  const ignition::math::AxisAlignedBox &_box) = 0;
+                  const gz::math::AxisAlignedBox &_box) = 0;
 
       /// \brief Get the wireframe box.
       /// \return The wireframe box.
-      public: virtual ignition::math::AxisAlignedBox Box() const = 0;
+      public: virtual gz::math::AxisAlignedBox Box() const = 0;
     };
     }
   }
diff --git a/include/gz/rendering/base/BaseArrowVisual.hh b/include/gz/rendering/base/BaseArrowVisual.hh
index dae000add..e5735913e 100644
--- a/include/gz/rendering/base/BaseArrowVisual.hh
+++ b/include/gz/rendering/base/BaseArrowVisual.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/ArrowVisual.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseArrowVisual :
diff --git a/include/gz/rendering/base/BaseAxisVisual.hh b/include/gz/rendering/base/BaseAxisVisual.hh
index 691315c97..6e8cae264 100644
--- a/include/gz/rendering/base/BaseAxisVisual.hh
+++ b/include/gz/rendering/base/BaseAxisVisual.hh
@@ -21,11 +21,11 @@
 #include "gz/rendering/ArrowVisual.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseAxisVisual :
diff --git a/include/gz/rendering/base/BaseBoundingBoxCamera.hh b/include/gz/rendering/base/BaseBoundingBoxCamera.hh
index fb29a56e3..215f1cb54 100644
--- a/include/gz/rendering/base/BaseBoundingBoxCamera.hh
+++ b/include/gz/rendering/base/BaseBoundingBoxCamera.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/base/BaseCamera.hh"
 #include "gz/rendering/BoundingBoxCamera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     template <class T>
     class BaseBoundingBoxCamera:
@@ -47,7 +47,7 @@ namespace ignition
       public: virtual const std::vector<BoundingBox> &BoundingBoxData() const;
 
       // Documentation inherited
-      public: virtual ignition::common::ConnectionPtr ConnectNewBoundingBoxes(
+      public: virtual gz::common::ConnectionPtr ConnectNewBoundingBoxes(
         std::function<void(const std::vector<BoundingBox> &)> _subscriber) = 0;
 
       // Documentation inherited
diff --git a/include/gz/rendering/base/BaseCOMVisual.hh b/include/gz/rendering/base/BaseCOMVisual.hh
index 58ad81e1a..0c91179f2 100644
--- a/include/gz/rendering/base/BaseCOMVisual.hh
+++ b/include/gz/rendering/base/BaseCOMVisual.hh
@@ -26,11 +26,11 @@
 #include "gz/rendering/COMVisual.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of an center of mass visual
     template <class T>
@@ -52,7 +52,7 @@ namespace ignition
 
       // Documentation inherited.
       public: virtual void SetInertial(
-                  const ignition::math::Inertiald &_inertial) override;
+                  const gz::math::Inertiald &_inertial) override;
 
       // Documentation inherited.
       public: virtual void SetMass(double _mass) override;
@@ -61,7 +61,7 @@ namespace ignition
       public: virtual double Mass() const override;
 
       // Documentation inherited
-      public: virtual ignition::math::Pose3d InertiaPose() const override;
+      public: virtual gz::math::Pose3d InertiaPose() const override;
 
       // Documentation inherited
       public: virtual VisualPtr SphereVisual() const override;
@@ -77,8 +77,8 @@ namespace ignition
       protected: double mass = 1.0;
 
       /// \brief Inertia pose in parent frame.
-      protected: ignition::math::Pose3d inertiaPose =
-          ignition::math::Pose3d::Zero;
+      protected: gz::math::Pose3d inertiaPose =
+          gz::math::Pose3d::Zero;
 
       /// \brief Flag to indicate parent properties have changed.
       protected: bool dirtyCOMVisual = false;
@@ -113,7 +113,7 @@ namespace ignition
     //////////////////////////////////////////////////
     template <class T>
     void BaseCOMVisual<T>::SetInertial(
-          const ignition::math::Inertiald &_inertial)
+          const gz::math::Inertiald &_inertial)
     {
       this->inertiaPose = _inertial.Pose();
 
@@ -128,13 +128,13 @@ namespace ignition
         // Unrealistic mass, load with default mass
         if (_mass < 0)
         {
-          ignlog << "The parent " << this->parentName
+          gzlog << "The parent " << this->parentName
               << " has unrealistic mass, "
               << "unable to visualize sphere of equivalent mass.\n";
         }
         else
         {
-          ignlog << "The parent " << this->parentName
+          gzlog << "The parent " << this->parentName
               << " is static or has mass of 0, "
               << "so a sphere of equivalent mass will not be shown.\n";
         }
@@ -154,7 +154,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Pose3d BaseCOMVisual<T>::InertiaPose() const
+    gz::math::Pose3d BaseCOMVisual<T>::InertiaPose() const
     {
       return this->inertiaPose;
     }
diff --git a/include/gz/rendering/base/BaseCamera.hh b/include/gz/rendering/base/BaseCamera.hh
index e56b1b758..88f14205f 100644
--- a/include/gz/rendering/base/BaseCamera.hh
+++ b/include/gz/rendering/base/BaseCamera.hh
@@ -32,11 +32,11 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/base/BaseRenderTarget.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     template <class T>
     class BaseDepthCamera;
 
@@ -105,7 +105,7 @@ namespace ignition
       public: virtual RenderWindowPtr CreateRenderWindow() override;
 
       // Documentation inherited.
-      public: virtual VisualPtr VisualAt(const ignition::math::Vector2i
+      public: virtual VisualPtr VisualAt(const gz::math::Vector2i
                   &_mousePos) override;
 
       // Documentation inherited.
@@ -489,7 +489,7 @@ namespace ignition
     RenderWindowPtr BaseCamera<T>::CreateRenderWindow()
     {
       // Does nothing by default
-      ignerr << "Render window not supported for render engine: " <<
+      gzerr << "Render window not supported for render engine: " <<
           this->Scene()->Engine()->Name() << std::endl;
       return RenderWindowPtr();
     }
@@ -556,7 +556,7 @@ namespace ignition
       }
       else
       {
-        ignerr << "Unknown camera projection type: " << this->projectionType
+        gzerr << "Unknown camera projection type: " << this->projectionType
                << std::endl;
       }
 
@@ -631,10 +631,10 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    VisualPtr BaseCamera<T>::VisualAt(const ignition::math::Vector2i
+    VisualPtr BaseCamera<T>::VisualAt(const gz::math::Vector2i
         &/*_mousePos*/)
     {
-      ignerr << "VisualAt not implemented for the render engine" << std::endl;
+      gzerr << "VisualAt not implemented for the render engine" << std::endl;
       return VisualPtr();
     }
 
@@ -795,7 +795,7 @@ namespace ignition
     template <class T>
     void BaseCamera<T>::SetMaterial(const MaterialPtr &/*_material*/)
     {
-      ignerr << "SetMaterial not implemented for current render"
+      gzerr << "SetMaterial not implemented for current render"
           << " engine" << std::endl;
     }
 
@@ -803,7 +803,7 @@ namespace ignition
     template <class T>
     unsigned int BaseCamera<T>::RenderTextureGLId() const
     {
-      ignerr << "RenderTextureGLId is not supported by current render"
+      gzerr << "RenderTextureGLId is not supported by current render"
           << " engine" << std::endl;
       return 0u;
     }
@@ -812,7 +812,7 @@ namespace ignition
     template <class T>
     void BaseCamera<T>::RenderTextureMetalId(void *) const
     {
-      ignerr << "RenderTextureMetalId is not supported by current render"
+      gzerr << "RenderTextureMetalId is not supported by current render"
           << " engine" << std::endl;
     }
 
diff --git a/include/gz/rendering/base/BaseCapsule.hh b/include/gz/rendering/base/BaseCapsule.hh
index cae6d639f..5ef5a0194 100644
--- a/include/gz/rendering/base/BaseCapsule.hh
+++ b/include/gz/rendering/base/BaseCapsule.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/base/BaseObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \brief Base implementation of a Capsule Geometry
     template <class T>
     class BaseCapsule :
@@ -116,7 +116,7 @@ namespace ignition
     {
       if (!this->Scene())
       {
-        ignerr << "Cloning a Capsule failed because the capsule to be "
+        gzerr << "Cloning a Capsule failed because the capsule to be "
           << "cloned does not belong to a scene.\n";
         return nullptr;
       }
diff --git a/include/gz/rendering/base/BaseDepthCamera.hh b/include/gz/rendering/base/BaseDepthCamera.hh
index 7701517df..5df4f5475 100644
--- a/include/gz/rendering/base/BaseDepthCamera.hh
+++ b/include/gz/rendering/base/BaseDepthCamera.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/base/BaseCamera.hh"
 #include "gz/rendering/DepthCamera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     template <class T>
     class BaseDepthCamera :
       public virtual DepthCamera,
@@ -43,11 +43,11 @@ namespace ignition
 
       public: virtual const float *DepthData() const;
 
-      public: virtual ignition::common::ConnectionPtr ConnectNewDepthFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewDepthFrame(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber);
 
-      public: virtual ignition::common::ConnectionPtr ConnectNewRGBPointCloud(
+      public: virtual gz::common::ConnectionPtr ConnectNewRGBPointCloud(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber);
     };
@@ -79,7 +79,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::common::ConnectionPtr BaseDepthCamera<T>::ConnectNewDepthFrame(
+    gz::common::ConnectionPtr BaseDepthCamera<T>::ConnectNewDepthFrame(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>)
     {
@@ -88,7 +88,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::common::ConnectionPtr BaseDepthCamera<T>::ConnectNewRGBPointCloud(
+    gz::common::ConnectionPtr BaseDepthCamera<T>::ConnectNewRGBPointCloud(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>)
     {
diff --git a/include/gz/rendering/base/BaseDistortionPass.hh b/include/gz/rendering/base/BaseDistortionPass.hh
index ce7c617e6..6599cf6c5 100644
--- a/include/gz/rendering/base/BaseDistortionPass.hh
+++ b/include/gz/rendering/base/BaseDistortionPass.hh
@@ -19,11 +19,11 @@
 
 #include "gz/rendering/DistortionPass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class BaseDistortionPass BaseDistortionPass.hh \
      * gz/rendering/base/BaseDistortionPass.hh
diff --git a/include/gz/rendering/base/BaseGaussianNoisePass.hh b/include/gz/rendering/base/BaseGaussianNoisePass.hh
index 89fa17bfe..e4be55836 100644
--- a/include/gz/rendering/base/BaseGaussianNoisePass.hh
+++ b/include/gz/rendering/base/BaseGaussianNoisePass.hh
@@ -22,11 +22,11 @@
 
 #include "gz/rendering/GaussianNoisePass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class BaseGaussianNoisePass BaseGaussianNoisePass.hh \
      * gz/rendering/base/BaseGaussianNoisePass.hh
@@ -155,11 +155,11 @@ namespace ignition
     void BaseGaussianNoisePass<T>::SampleBias()
     {
       this->bias =
-          ignition::math::Rand::DblNormal(this->biasMean, this->biasStdDev);
+          gz::math::Rand::DblNormal(this->biasMean, this->biasStdDev);
       // With equal probability, we pick a negative bias (by convention,
       // rateBiasMean should be positive, though it would work fine if
       // negative).
-      if (ignition::math::Rand::DblUniform() < 0.5)
+      if (gz::math::Rand::DblUniform() < 0.5)
         this->bias = -this->bias;
     }
     }
diff --git a/include/gz/rendering/base/BaseGeometry.hh b/include/gz/rendering/base/BaseGeometry.hh
index 336034325..cde12860d 100644
--- a/include/gz/rendering/base/BaseGeometry.hh
+++ b/include/gz/rendering/base/BaseGeometry.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/Geometry.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseGeometry :
@@ -99,7 +99,7 @@ namespace ignition
     template <class T>
     GeometryPtr BaseGeometry<T>::Clone() const
     {
-      ignwarn << "Clone functionality for Geometry does not exist yet.\n";
+      gzwarn << "Clone functionality for Geometry does not exist yet.\n";
       return nullptr;
     }
 
diff --git a/include/gz/rendering/base/BaseGizmoVisual.hh b/include/gz/rendering/base/BaseGizmoVisual.hh
index e9b4cc2a4..0d531a3c7 100644
--- a/include/gz/rendering/base/BaseGizmoVisual.hh
+++ b/include/gz/rendering/base/BaseGizmoVisual.hh
@@ -29,11 +29,11 @@
 #include "gz/rendering/Camera.hh"
 #include "gz/rendering/GizmoVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class BaseGizmoVisual BaseGizmoVisuall.hh \
      * gz/rendering/base/BaseGizmoVisual.hh
diff --git a/include/gz/rendering/base/BaseGpuRays.hh b/include/gz/rendering/base/BaseGpuRays.hh
index debd5fff2..d6eb6b1de 100644
--- a/include/gz/rendering/base/BaseGpuRays.hh
+++ b/include/gz/rendering/base/BaseGpuRays.hh
@@ -32,11 +32,11 @@
 #include "gz/rendering/RenderTypes.hh"
 
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseGpuRays :
@@ -95,13 +95,13 @@ namespace ignition
                   const double _rayCountRatio) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Angle AngleMin() const override;
+      public: virtual gz::math::Angle AngleMin() const override;
 
       // Documentation inherited.
       public: virtual void SetAngleMin(double _angle) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Angle AngleMax() const override;
+      public: virtual gz::math::Angle AngleMax() const override;
 
       // Documentation inherited.
       public: virtual void SetAngleMax(double _angle) override;
@@ -125,13 +125,13 @@ namespace ignition
       public: virtual int VerticalRangeCount() const override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Angle VerticalAngleMin() const override;
+      public: virtual gz::math::Angle VerticalAngleMin() const override;
 
       // Documentation inherited.
       public: virtual void SetVerticalAngleMin(const double _angle) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Angle VerticalAngleMax() const override;
+      public: virtual gz::math::Angle VerticalAngleMax() const override;
 
       // Documentation inherited.
       public: virtual void SetVerticalAngleMax(const double _angle) override;
@@ -152,10 +152,10 @@ namespace ignition
       public: virtual double VerticalResolution() const override;
 
       /// \brief maximum value used for data outside sensor range
-      public: float dataMaxVal = ignition::math::INF_D;
+      public: float dataMaxVal = gz::math::INF_D;
 
       /// \brief minimum value used for data outside sensor range
-      public: float dataMinVal = -ignition::math::INF_D;
+      public: float dataMinVal = -gz::math::INF_D;
 
       /// \brief True if data values are clamped to camera clip distances,
       // false if data outside of camera range is +/- inf
@@ -243,8 +243,8 @@ namespace ignition
       }
       else
       {
-        this->dataMinVal = -ignition::math::INF_D;
-        this->dataMaxVal = ignition::math::INF_D;
+        this->dataMinVal = -gz::math::INF_D;
+        this->dataMaxVal = gz::math::INF_D;
       }
     }
 
@@ -258,7 +258,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::common::ConnectionPtr BaseGpuRays<T>::ConnectNewGpuRaysFrame(
+    gz::common::ConnectionPtr BaseGpuRays<T>::ConnectNewGpuRaysFrame(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>)
     {
@@ -316,7 +316,7 @@ namespace ignition
 
     template <class T>
     //////////////////////////////////////////////////
-    ignition::math::Angle BaseGpuRays<T>::AngleMin() const
+    gz::math::Angle BaseGpuRays<T>::AngleMin() const
     {
       return this->minAngle;
     }
@@ -330,7 +330,7 @@ namespace ignition
 
     template <class T>
     //////////////////////////////////////////////////
-    ignition::math::Angle BaseGpuRays<T>::AngleMax() const
+    gz::math::Angle BaseGpuRays<T>::AngleMax() const
     {
       return this->maxAngle;
     }
@@ -386,7 +386,7 @@ namespace ignition
 
     template <class T>
     //////////////////////////////////////////////////
-    ignition::math::Angle BaseGpuRays<T>::VerticalAngleMin() const
+    gz::math::Angle BaseGpuRays<T>::VerticalAngleMin() const
     {
       return this->vMinAngle;
     }
@@ -400,7 +400,7 @@ namespace ignition
 
     template <class T>
     //////////////////////////////////////////////////
-    ignition::math::Angle BaseGpuRays<T>::VerticalAngleMax() const
+    gz::math::Angle BaseGpuRays<T>::VerticalAngleMax() const
     {
       return this->vMaxAngle;
     }
diff --git a/include/gz/rendering/base/BaseGrid.hh b/include/gz/rendering/base/BaseGrid.hh
index 899f703ff..fa629e12e 100644
--- a/include/gz/rendering/base/BaseGrid.hh
+++ b/include/gz/rendering/base/BaseGrid.hh
@@ -21,11 +21,11 @@
 #include "gz/rendering/Grid.hh"
 #include "gz/rendering/base/BaseObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of a grid geometry
     template <class T>
diff --git a/include/gz/rendering/base/BaseHeightmap.hh b/include/gz/rendering/base/BaseHeightmap.hh
index f023b6028..d7dc35b94 100644
--- a/include/gz/rendering/base/BaseHeightmap.hh
+++ b/include/gz/rendering/base/BaseHeightmap.hh
@@ -19,11 +19,11 @@
 
 #include "gz/rendering/Heightmap.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     //////////////////////////////////////////////////
     template <class T>
diff --git a/include/gz/rendering/base/BaseInertiaVisual.hh b/include/gz/rendering/base/BaseInertiaVisual.hh
index 3f3c18b23..f9c44f0f7 100644
--- a/include/gz/rendering/base/BaseInertiaVisual.hh
+++ b/include/gz/rendering/base/BaseInertiaVisual.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/InertiaVisual.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of an inertia visual
     template <class T>
@@ -50,11 +50,11 @@ namespace ignition
 
       // Documentation inherited.
       public: virtual void SetInertial(
-                  const ignition::math::Inertiald &_inertial) override;
+                  const gz::math::Inertiald &_inertial) override;
 
       // Documentation inherited.
-      public: virtual void Load(const ignition::math::Pose3d &,
-          const ignition::math::Vector3d &) override;
+      public: virtual void Load(const gz::math::Pose3d &,
+          const gz::math::Vector3d &) override;
 
       // Documentation inherited
       public: virtual VisualPtr BoxVisual() const override;
@@ -89,33 +89,33 @@ namespace ignition
     //////////////////////////////////////////////////
     template <class T>
     void BaseInertiaVisual<T>::SetInertial(
-          const ignition::math::Inertiald &_inertial)
+          const gz::math::Inertiald &_inertial)
     {
       auto xyz = _inertial.Pose().Pos();
       auto q = _inertial.Pose().Rot();
 
-      // Use ignition::math::MassMatrix3 to compute
+      // Use gz::math::MassMatrix3 to compute
       // equivalent box size and rotation
       auto m = _inertial.MassMatrix();
-      ignition::math::Vector3d boxScale;
-      ignition::math::Quaterniond boxRot;
+      gz::math::Vector3d boxScale;
+      gz::math::Quaterniond boxRot;
       if (!m.EquivalentBox(boxScale, boxRot))
       {
         // Invalid inertia, load with default scale
-        ignlog << "The link is static or has unrealistic "
+        gzlog << "The link is static or has unrealistic "
             << "inertia, so the equivalent inertia box will not be shown.\n";
       }
       else
       {
         // Apply additional rotation by boxRot
-        this->Load(ignition::math::Pose3d(xyz, q * boxRot), boxScale);
+        this->Load(gz::math::Pose3d(xyz, q * boxRot), boxScale);
       }
     }
 
     //////////////////////////////////////////////////
     template <class T>
-    void BaseInertiaVisual<T>::Load(const ignition::math::Pose3d &,
-        const ignition::math::Vector3d &)
+    void BaseInertiaVisual<T>::Load(const gz::math::Pose3d &,
+        const gz::math::Vector3d &)
     {
       // no op
     }
diff --git a/include/gz/rendering/base/BaseJointVisual.hh b/include/gz/rendering/base/BaseJointVisual.hh
index 34a4aaf70..40e32527c 100644
--- a/include/gz/rendering/base/BaseJointVisual.hh
+++ b/include/gz/rendering/base/BaseJointVisual.hh
@@ -29,11 +29,11 @@
 #include "gz/rendering/base/BaseObject.hh"
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of a joint visual
     template <class T>
@@ -57,28 +57,28 @@ namespace ignition
       protected: virtual void Destroy() override;
 
       // Documentation inherited.
-      public: virtual void SetAxis(const ignition::math::Vector3d &_axis,
+      public: virtual void SetAxis(const gz::math::Vector3d &_axis,
           bool _useParentFrame) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Vector3d Axis() const override;
+      public: virtual gz::math::Vector3d Axis() const override;
 
       // Documentation inherited.
       public: virtual void SetParentAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           const std::string &_parentName,
           bool _useParentFrame) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Vector3d ParentAxis() const override;
+      public: virtual gz::math::Vector3d ParentAxis() const override;
 
       // Documentation inherited.
-      public: virtual bool UpdateAxis(const ignition::math::Vector3d &_axis,
+      public: virtual bool UpdateAxis(const gz::math::Vector3d &_axis,
           bool _useParentFrame) override;
 
       // Documentation inherited.
       public: virtual bool UpdateParentAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           bool _useParentFrame) override;
 
       // Documentation inherited.
@@ -102,7 +102,7 @@ namespace ignition
       /// \param[in] _useParentFrame True if the axis vector is
       /// expressed in the joint parent frame.
       protected: void UpdateAxisImpl(ArrowVisualPtr _arrowVisual,
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           bool _useParentFrame);
 
       /// \brief Helper function to create axis visual.
@@ -131,8 +131,8 @@ namespace ignition
       protected: JointVisualPtr parentAxisVis = nullptr;
 
       /// \brief Scale based on the size of the joint's child.
-      protected: ignition::math::Vector3d scaleToChild =
-          ignition::math::Vector3d::One;
+      protected: gz::math::Vector3d scaleToChild =
+          gz::math::Vector3d::One;
 
       /// \brief Flag to indicate joint visual type has changed.
       protected: bool dirtyJointType = false;
@@ -144,8 +144,8 @@ namespace ignition
       protected: bool dirtyParentAxis = false;
 
       /// \brief Joint visual axis vector.
-      protected: ignition::math::Vector3d axis =
-          ignition::math::Vector3d::Zero;
+      protected: gz::math::Vector3d axis =
+          gz::math::Vector3d::Zero;
 
       /// \brief Flag to indicate whether axis vector is
       /// expressed in joint parent frame.
@@ -155,8 +155,8 @@ namespace ignition
       protected: bool updateAxis = false;
 
       /// \brief Parent axis vector.
-      protected: ignition::math::Vector3d parentAxis =
-          ignition::math::Vector3d::Zero;
+      protected: gz::math::Vector3d parentAxis =
+          gz::math::Vector3d::Zero;
 
       /// \brief Joint parent name.
       protected: std::string jointParentName = "";
@@ -268,7 +268,7 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseJointVisual<T>::SetAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           bool _useParentFrame)
     {
       this->axis = _axis;
@@ -299,14 +299,14 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseJointVisual<T>::SetParentAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           const std::string &_parentName,
           bool _useParentFrame)
     {
       if (this->Type() != JointVisualType::JVT_REVOLUTE2 &&
           this->Type() != JointVisualType::JVT_UNIVERSAL)
       {
-        ignlog << "Joint visual is not of type Revolute2 or "
+        gzlog << "Joint visual is not of type Revolute2 or "
                << " Universal "
                << " so the parent axis will not be shown\n";
         return;
@@ -325,7 +325,7 @@ namespace ignition
       auto jointParentVis = this->Scene()->NodeByName(this->jointParentName);
       if (jointParentVis == nullptr)
       {
-        ignlog << "Joint parent with name " << this->jointParentName
+        gzlog << "Joint parent with name " << this->jointParentName
                << " does not exist"
                << " so the parent axis will not be shown\n";
         return;
@@ -349,7 +349,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    bool BaseJointVisual<T>::UpdateAxis(const ignition::math::Vector3d &_axis,
+    bool BaseJointVisual<T>::UpdateAxis(const gz::math::Vector3d &_axis,
           bool _useParentFrame)
     {
       if (this->ArrowVisual() && this->HasParent())
@@ -364,7 +364,7 @@ namespace ignition
     //////////////////////////////////////////////////
     template <class T>
     bool BaseJointVisual<T>::UpdateParentAxis(
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           bool _useParentFrame)
     {
       if (this->ParentAxisVisual() &&
@@ -382,18 +382,18 @@ namespace ignition
     //////////////////////////////////////////////////
     template <class T>
     void BaseJointVisual<T>::UpdateAxisImpl(ArrowVisualPtr _arrowVisual,
-          const ignition::math::Vector3d &_axis,
+          const gz::math::Vector3d &_axis,
           bool _useParentFrame)
     {
       // Get rotation to axis vector
-      ignition::math::Vector3d axisDir = _axis;
-      ignition::math::Vector3d u = axisDir.Normalize();
-      ignition::math::Vector3d v = ignition::math::Vector3d::UnitZ;
+      gz::math::Vector3d axisDir = _axis;
+      gz::math::Vector3d u = axisDir.Normalize();
+      gz::math::Vector3d v = gz::math::Vector3d::UnitZ;
       double cosTheta = v.Dot(u);
       double angle = acos(cosTheta);
-      ignition::math::Quaterniond quat;
+      gz::math::Quaterniond quat;
       // check the parallel case
-      if (ignition::math::equal(angle, IGN_PI))
+      if (gz::math::equal(angle, IGN_PI))
         quat.SetFromAxisAngle(u.Perpendicular(), angle);
       else
         quat.SetFromAxisAngle((v.Cross(u)).Normalize(), angle);
@@ -401,11 +401,11 @@ namespace ignition
 
       if (_useParentFrame)
       {
-        ignition::math::Pose3d parentInitPose =
+        gz::math::Pose3d parentInitPose =
             this->Parent()->InitialLocalPose();
 
         // get rotation of joint visual in model frame
-        ignition::math::Quaterniond quatFromModel =
+        gz::math::Quaterniond quatFromModel =
             (parentInitPose * this->LocalPose()).Rot();
 
         // rotate arrow visual so that the axis vector applies to the model
@@ -436,20 +436,20 @@ namespace ignition
       this->axisVisual->ShowAxisHead(true);
       _arrowVisual->ShowArrowShaft(true);
 
-      auto axisWorld = axisWorldRotation * ignition::math::Vector3d::UnitZ;
-      if (axisWorld == jointWorldRotation * ignition::math::Vector3d::UnitX)
+      auto axisWorld = axisWorldRotation * gz::math::Vector3d::UnitZ;
+      if (axisWorld == jointWorldRotation * gz::math::Vector3d::UnitX)
       {
         this->axisVisual->ShowAxisHead(0, false);
         _arrowVisual->ShowArrowShaft(false);
       }
       else if (axisWorld ==
-          jointWorldRotation * ignition::math::Vector3d::UnitY)
+          jointWorldRotation * gz::math::Vector3d::UnitY)
       {
         this->axisVisual->ShowAxisHead(1, false);
         _arrowVisual->ShowArrowShaft(false);
       }
       else if (axisWorld ==
-          jointWorldRotation * ignition::math::Vector3d::UnitZ)
+          jointWorldRotation * gz::math::Vector3d::UnitZ)
       {
         this->axisVisual->ShowAxisHead(2, false);
         _arrowVisual->ShowArrowShaft(false);
@@ -471,7 +471,7 @@ namespace ignition
       {
         double childSize =
             std::max(0.1, parentVisual->BoundingBox().Size().Length());
-        this->scaleToChild = ignition::math::Vector3d(childSize * 0.2,
+        this->scaleToChild = gz::math::Vector3d(childSize * 0.2,
             childSize * 0.2, childSize * 0.2);
         this->SetLocalScale(this->scaleToChild);
         if (this->ParentAxisVisual())
@@ -489,14 +489,14 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Vector3d BaseJointVisual<T>::Axis() const
+    gz::math::Vector3d BaseJointVisual<T>::Axis() const
     {
       return this->axis;
     }
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Vector3d BaseJointVisual<T>::ParentAxis() const
+    gz::math::Vector3d BaseJointVisual<T>::ParentAxis() const
     {
       return this->parentAxis;
     }
diff --git a/include/gz/rendering/base/BaseLidarVisual.hh b/include/gz/rendering/base/BaseLidarVisual.hh
index 62deee791..764a286e6 100644
--- a/include/gz/rendering/base/BaseLidarVisual.hh
+++ b/include/gz/rendering/base/BaseLidarVisual.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/base/BaseRenderTypes.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \brief Base implementation of a Lidar Visual
     template <class T>
     class BaseLidarVisual :
@@ -56,7 +56,7 @@ namespace ignition
 
       // Documentation inherited
       public: virtual void SetPoints(const std::vector<double> &_points,
-                            const std::vector<ignition::math::Color> &_colors)
+                            const std::vector<gz::math::Color> &_colors)
                             override;
 
       // Documentation inherited
@@ -121,10 +121,10 @@ namespace ignition
 
       // Documentation inherited
       public: virtual void SetOffset(
-                  const ignition::math::Pose3d _offset) override;
+                  const gz::math::Pose3d _offset) override;
 
       // Documentation inherited
-      public: virtual ignition::math::Pose3d  Offset() const override;
+      public: virtual gz::math::Pose3d  Offset() const override;
 
       // Documentation inherited
       public: virtual unsigned int PointCount() const override;
@@ -187,7 +187,7 @@ namespace ignition
       protected: bool displayNonHitting = true;
 
       /// \brief Offset of visual
-      protected: ignition::math::Pose3d offset = ignition::math::Pose3d::Zero;
+      protected: gz::math::Pose3d offset = gz::math::Pose3d::Zero;
 
       /// \brief Type of lidar visualisation
       protected: LidarVisualType lidarVisualType =
@@ -264,7 +264,7 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseLidarVisual<T>::SetPoints(const std::vector<double> &,
-                                const std::vector<ignition::math::Color> &)
+                                const std::vector<gz::math::Color> &)
     {
       // no op
     }
@@ -314,7 +314,7 @@ namespace ignition
     {
       if (_verticalRayCount == 0)
       {
-        ignwarn << "Cannot have zero vertical rays. Setting value to 1."
+        gzwarn << "Cannot have zero vertical rays. Setting value to 1."
                << std::endl;
         this->verticalCount = 1;
       }
@@ -368,7 +368,7 @@ namespace ignition
     {
       if (_horizontalRayCount == 0)
       {
-        ignwarn << "Cannot have zero horizontal rays. Setting value to 1."
+        gzwarn << "Cannot have zero horizontal rays. Setting value to 1."
                << std::endl;
         this->horizontalCount = 1u;
       }
@@ -415,14 +415,14 @@ namespace ignition
 
     /////////////////////////////////////////////////
     template <class T>
-    void BaseLidarVisual<T>::SetOffset(const ignition::math::Pose3d _offset)
+    void BaseLidarVisual<T>::SetOffset(const gz::math::Pose3d _offset)
     {
       this->offset = _offset;
     }
 
     /////////////////////////////////////////////////
     template <class T>
-    ignition::math::Pose3d BaseLidarVisual<T>::Offset() const
+    gz::math::Pose3d BaseLidarVisual<T>::Offset() const
     {
       return this->offset;
     }
diff --git a/include/gz/rendering/base/BaseLight.hh b/include/gz/rendering/base/BaseLight.hh
index 3e467b140..e0bbd1696 100644
--- a/include/gz/rendering/base/BaseLight.hh
+++ b/include/gz/rendering/base/BaseLight.hh
@@ -19,11 +19,11 @@
 
 #include "gz/rendering/Light.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseLight :
diff --git a/include/gz/rendering/base/BaseLightVisual.hh b/include/gz/rendering/base/BaseLightVisual.hh
index 2ef69acf1..4023584a1 100644
--- a/include/gz/rendering/base/BaseLightVisual.hh
+++ b/include/gz/rendering/base/BaseLightVisual.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/LightVisual.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of a light visual
     template <class T>
@@ -64,7 +64,7 @@ namespace ignition
       public: virtual double OuterAngle() override;
 
       /// \brief Draw the light visual using dynamic renderables
-      public: std::vector<ignition::math::Vector3d> CreateVisualLines();
+      public: std::vector<gz::math::Vector3d> CreateVisualLines();
 
       // Documentation inherited
       public: virtual LightVisualType Type() override;
@@ -154,67 +154,67 @@ namespace ignition
     }
 
     template <class T>
-    std::vector<ignition::math::Vector3d>
+    std::vector<gz::math::Vector3d>
     BaseLightVisual<T>::CreateVisualLines()
     {
-      std::vector<ignition::math::Vector3d> positions;
+      std::vector<gz::math::Vector3d> positions;
 
       if (this->type == LightVisualType::LVT_DIRECTIONAL)
       {
         float s = 0.5;
-        positions.emplace_back(ignition::math::Vector3d(-s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(-s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(-s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, -s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(-s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, -s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(0, 0, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, -s));
+        positions.emplace_back(gz::math::Vector3d(0, 0, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, -s));
       }
       else if (this->type == LightVisualType::LVT_POINT)
       {
         float s = 0.1f;
-        positions.emplace_back(ignition::math::Vector3d(-s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(-s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(-s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, -s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(-s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(-s, -s, 0));
 
-        positions.emplace_back(ignition::math::Vector3d(-s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, s));
+        positions.emplace_back(gz::math::Vector3d(-s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, s));
 
-        positions.emplace_back(ignition::math::Vector3d(-s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, s));
+        positions.emplace_back(gz::math::Vector3d(-s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, s));
 
-        positions.emplace_back(ignition::math::Vector3d(s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, s));
+        positions.emplace_back(gz::math::Vector3d(s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, s));
 
-        positions.emplace_back(ignition::math::Vector3d(s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, s));
+        positions.emplace_back(gz::math::Vector3d(s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, s));
 
-        positions.emplace_back(ignition::math::Vector3d(-s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, -s));
+        positions.emplace_back(gz::math::Vector3d(-s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, -s));
 
-        positions.emplace_back(ignition::math::Vector3d(-s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, -s));
+        positions.emplace_back(gz::math::Vector3d(-s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, -s));
 
-        positions.emplace_back(ignition::math::Vector3d(s, s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, -s));
+        positions.emplace_back(gz::math::Vector3d(s, s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, -s));
 
-        positions.emplace_back(ignition::math::Vector3d(s, -s, 0));
-        positions.emplace_back(ignition::math::Vector3d(0, 0, -s));
+        positions.emplace_back(gz::math::Vector3d(s, -s, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, -s));
       }
       else if (this->type == LightVisualType::LVT_SPOT)
       {
@@ -224,46 +224,46 @@ namespace ignition
         angles[1] = range * tan(innerAngle / 2.0);
 
         unsigned int i = 0;
-        positions.emplace_back(ignition::math::Vector3d(0, 0, 0));
+        positions.emplace_back(gz::math::Vector3d(0, 0, 0));
         positions.emplace_back(
-            ignition::math::Vector3d(angles[i], angles[i], -range));
+            gz::math::Vector3d(angles[i], angles[i], -range));
 
         for (i = 0; i < 2; i++)
         {
-          positions.emplace_back(ignition::math::Vector3d(0, 0, 0));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(0, 0, 0));
+          positions.emplace_back(gz::math::Vector3d(
                 angles[i], angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(0, 0, 0));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(0, 0, 0));
+          positions.emplace_back(gz::math::Vector3d(
                 -angles[i], -angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(0, 0, 0));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(0, 0, 0));
+          positions.emplace_back(gz::math::Vector3d(
                 angles[i], -angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(0, 0, 0));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(0, 0, 0));
+          positions.emplace_back(gz::math::Vector3d(
                 -angles[i], angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 angles[i], angles[i], -range));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 -angles[i], angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 -angles[i], angles[i], -range));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 -angles[i], -angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 -angles[i], -angles[i], -range));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 angles[i], -angles[i], -range));
 
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 angles[i], -angles[i], -range));
-          positions.emplace_back(ignition::math::Vector3d(
+          positions.emplace_back(gz::math::Vector3d(
                 angles[i], angles[i], -range));
         }
       }
diff --git a/include/gz/rendering/base/BaseMarker.hh b/include/gz/rendering/base/BaseMarker.hh
index 8047ded5f..2fb81da45 100644
--- a/include/gz/rendering/base/BaseMarker.hh
+++ b/include/gz/rendering/base/BaseMarker.hh
@@ -23,11 +23,11 @@
 #include "gz/rendering/base/BaseObject.hh"
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \brief Base implementation of a Marker geometry
     template <class T>
     class BaseMarker :
@@ -78,15 +78,15 @@ namespace ignition
       // Documentation inherited
       public: virtual void AddPoint(double _x,
                   double _y, double _z,
-                  const ignition::math::Color &_color) override;
+                  const gz::math::Color &_color) override;
 
       // Documentation inherited
-      public: virtual void AddPoint(const ignition::math::Vector3d &_pt,
-                  const ignition::math::Color &_color) override;
+      public: virtual void AddPoint(const gz::math::Vector3d &_pt,
+                  const gz::math::Color &_color) override;
 
       // Documentation inherited
       public: virtual void SetPoint(unsigned int _index,
-                  const ignition::math::Vector3d &_value) override;
+                  const gz::math::Vector3d &_value) override;
 
       /// \brief Life time of a marker
       IGN_UTILS_WARN_IGNORE__DLL_INTERFACE_MISSING
@@ -102,7 +102,7 @@ namespace ignition
 
       /// \brief Marker type
       protected: MarkerType markerType =
-          ignition::rendering::MarkerType::MT_NONE;
+          gz::rendering::MarkerType::MT_NONE;
 
       /// \brief Marker size
       protected: double size = 1.0;
@@ -206,8 +206,8 @@ namespace ignition
 
     /////////////////////////////////////////////////
     template <class T>
-    void BaseMarker<T>::AddPoint(const ignition::math::Vector3d &,
-                                 const ignition::math::Color &)
+    void BaseMarker<T>::AddPoint(const gz::math::Vector3d &,
+                                 const gz::math::Color &)
     {
         // no op
     }
@@ -215,15 +215,15 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseMarker<T>::AddPoint(double _x, double _y, double _z,
-                  const ignition::math::Color &_color)
+                  const gz::math::Color &_color)
     {
-      this->AddPoint(ignition::math::Vector3d(_x, _y, _z), _color);
+      this->AddPoint(gz::math::Vector3d(_x, _y, _z), _color);
     }
 
     /////////////////////////////////////////////////
     template <class T>
     void BaseMarker<T>::SetPoint(unsigned int,
-                  const ignition::math::Vector3d &)
+                  const gz::math::Vector3d &)
     {
       // no op
     }
diff --git a/include/gz/rendering/base/BaseMaterial.hh b/include/gz/rendering/base/BaseMaterial.hh
index 6d82c173b..788023f36 100644
--- a/include/gz/rendering/base/BaseMaterial.hh
+++ b/include/gz/rendering/base/BaseMaterial.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/ShaderType.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Default pbr material properties
     static const common::Pbr kDefaultPbr;
diff --git a/include/gz/rendering/base/BaseMesh.hh b/include/gz/rendering/base/BaseMesh.hh
index aa5e1a6a0..4a1677c8f 100644
--- a/include/gz/rendering/base/BaseMesh.hh
+++ b/include/gz/rendering/base/BaseMesh.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/Storage.hh"
 #include "gz/rendering/base/BaseObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     //////////////////////////////////////////////////
     template <class T>
@@ -189,7 +189,7 @@ namespace ignition
     std::map<std::string, math::Matrix4d>
           BaseMesh<T>::SkeletonLocalTransforms() const
     {
-      std::map<std::string, ignition::math::Matrix4d> tmpMap;
+      std::map<std::string, gz::math::Matrix4d> tmpMap;
       return tmpMap;
     }
 
@@ -213,7 +213,7 @@ namespace ignition
     void BaseMesh<T>::SetSkeletonWeights(
           const std::unordered_map<std::string, float> &)
     {
-      ignerr << "SetSkeletonWeights not supported for render engine: "
+      gzerr << "SetSkeletonWeights not supported for render engine: "
              << this->Scene()->Engine()->Name() << std::endl;
     }
 
@@ -333,13 +333,13 @@ namespace ignition
     {
       if (!this->Scene())
       {
-        ignerr << "Cloning a mesh failed because the mesh to be "
+        gzerr << "Cloning a mesh failed because the mesh to be "
           << "cloned does not belong to a scene.\n";
         return nullptr;
       }
       else if (this->meshDescriptor.meshName.empty())
       {
-        ignerr << "Cloning a geometry failed because the name of the mesh is "
+        gzerr << "Cloning a geometry failed because the name of the mesh is "
           << "missing.\n";
         return nullptr;
       }
diff --git a/include/gz/rendering/base/BaseNode.hh b/include/gz/rendering/base/BaseNode.hh
index eaca3fc5d..43d02a601 100644
--- a/include/gz/rendering/base/BaseNode.hh
+++ b/include/gz/rendering/base/BaseNode.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/Storage.hh"
 #include "gz/rendering/base/BaseStorage.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseNode :
@@ -207,8 +207,8 @@ namespace ignition
       protected: bool initialLocalPoseSet = false;
 
       /// \brief Initial local pose for this node.
-      protected: ignition::math::Pose3d initialLocalPose =
-          ignition::math::Pose3d::Zero;
+      protected: gz::math::Pose3d initialLocalPose =
+          gz::math::Pose3d::Zero;
 
       /// \brief A map of custom key value data
       protected: std::map<std::string, Variant> userData;
@@ -247,7 +247,7 @@ namespace ignition
     {
       if (_child->Id() == this->Id())
       {
-        ignerr << "Cannot add self as a child node" << std::endl;
+        gzerr << "Cannot add self as a child node" << std::endl;
         return;
       }
 
@@ -341,7 +341,7 @@ namespace ignition
 
       if (!pose.IsFinite())
       {
-        ignerr << "Unable to set pose of a node: "
+        gzerr << "Unable to set pose of a node: "
                << "non-finite (nan, inf) values detected." << std::endl;
         return;
       }
diff --git a/include/gz/rendering/base/BaseObject.hh b/include/gz/rendering/base/BaseObject.hh
index e89cd20fb..73ad24d66 100644
--- a/include/gz/rendering/base/BaseObject.hh
+++ b/include/gz/rendering/base/BaseObject.hh
@@ -22,13 +22,13 @@
 #include <gz/utils/SuppressWarning.hh>
 #include "gz/rendering/Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_VISIBLE BaseObject :
+    class GZ_RENDERING_VISIBLE BaseObject :
       IGN_UTILS_WARN_IGNORE__DLL_INTERFACE_MISSING
       public virtual std::enable_shared_from_this<BaseObject>,
       IGN_UTILS_WARN_RESUME__DLL_INTERFACE_MISSING
diff --git a/include/gz/rendering/base/BaseParticleEmitter.hh b/include/gz/rendering/base/BaseParticleEmitter.hh
index 24edf862b..569d0b886 100644
--- a/include/gz/rendering/base/BaseParticleEmitter.hh
+++ b/include/gz/rendering/base/BaseParticleEmitter.hh
@@ -23,11 +23,11 @@
 #include "gz/rendering/base/BaseNode.hh"
 #include "gz/rendering/ParticleEmitter.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class BaseParticleEmitter BaseParticleEmitter.hh \
      * gz/rendering/base/BaseParticleEmitter.hh
@@ -60,11 +60,11 @@ namespace ignition
       public: virtual void SetType(const EmitterType _type) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Vector3d EmitterSize() const override;
+      public: virtual gz::math::Vector3d EmitterSize() const override;
 
       // Documentation inherited.
       public: virtual void SetEmitterSize(
-                  const ignition::math::Vector3d &_size) override;
+                  const gz::math::Vector3d &_size) override;
 
       // Documentation inherited.
       public: virtual double Rate() const override;
@@ -85,11 +85,11 @@ namespace ignition
       public: virtual void SetEmitting(bool _enable) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Vector3d ParticleSize() const override;
+      public: virtual gz::math::Vector3d ParticleSize() const override;
 
       // Documentation inherited.
       public: virtual void SetParticleSize(
-                  const ignition::math::Vector3d &_size) override;
+                  const gz::math::Vector3d &_size) override;
 
       // Documentation inherited.
       public: virtual double Lifetime() const override;
@@ -114,15 +114,15 @@ namespace ignition
                                             double _maxVelocity) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Color ColorStart() const override;
+      public: virtual gz::math::Color ColorStart() const override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Color ColorEnd() const override;
+      public: virtual gz::math::Color ColorEnd() const override;
 
       // Documentation inherited.
       public: virtual void SetColorRange(
-                  const ignition::math::Color &_colorStart,
-                  const ignition::math::Color &_colorEnd) override;
+                  const gz::math::Color &_colorStart,
+                  const gz::math::Color &_colorEnd) override;
 
       // Documentation inherited.
       public: virtual double ScaleRate() const override;
@@ -147,8 +147,8 @@ namespace ignition
       protected: EmitterType type = EM_POINT;
 
       /// \brief Emitter size.
-      protected: ignition::math::Vector3d emitterSize =
-          ignition::math::Vector3d::One;
+      protected: gz::math::Vector3d emitterSize =
+          gz::math::Vector3d::One;
 
       /// \brief Rate of emission.
       protected: double rate = 10;
@@ -160,7 +160,7 @@ namespace ignition
       protected: bool emitting = false;
 
       /// \brief Particle size.
-      protected: ignition::math::Vector3d particleSize = {1, 1, 1};
+      protected: gz::math::Vector3d particleSize = {1, 1, 1};
 
       /// \brief Particle lifetime.
       protected: double lifetime = 5;
@@ -175,12 +175,12 @@ namespace ignition
       protected: double maxVelocity = 1;
 
       /// \brief The start color of a particle to choose from.
-      protected: ignition::math::Color colorStart =
-          ignition::math::Color::White;
+      protected: gz::math::Color colorStart =
+          gz::math::Color::White;
 
       /// \brief The end color of a particle to choose from.
-      protected: ignition::math::Color colorEnd =
-          ignition::math::Color::White;
+      protected: gz::math::Color colorEnd =
+          gz::math::Color::White;
 
       /// \brief The scale rate.
       protected: double scaleRate = 1;
@@ -248,7 +248,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Vector3d BaseParticleEmitter<T>::EmitterSize() const
+    gz::math::Vector3d BaseParticleEmitter<T>::EmitterSize() const
     {
       return this->emitterSize;
     }
@@ -256,7 +256,7 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseParticleEmitter<T>::SetEmitterSize(
-                const ignition::math::Vector3d &_size)
+                const gz::math::Vector3d &_size)
     {
       this->emitterSize = _size;
     }
@@ -305,7 +305,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Vector3d BaseParticleEmitter<T>::ParticleSize() const
+    gz::math::Vector3d BaseParticleEmitter<T>::ParticleSize() const
     {
       return this->particleSize;
     }
@@ -313,7 +313,7 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseParticleEmitter<T>::SetParticleSize(
-                const ignition::math::Vector3d &_size)
+                const gz::math::Vector3d &_size)
     {
       this->particleSize = _size;
     }
@@ -371,14 +371,14 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Color BaseParticleEmitter<T>::ColorStart() const
+    gz::math::Color BaseParticleEmitter<T>::ColorStart() const
     {
       return this->colorStart;
     }
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Color BaseParticleEmitter<T>::ColorEnd() const
+    gz::math::Color BaseParticleEmitter<T>::ColorEnd() const
     {
       return this->colorEnd;
     }
@@ -386,8 +386,8 @@ namespace ignition
     /////////////////////////////////////////////////
     template <class T>
     void BaseParticleEmitter<T>::SetColorRange(
-                  const ignition::math::Color &_colorStart,
-                  const ignition::math::Color &_colorEnd)
+                  const gz::math::Color &_colorStart,
+                  const gz::math::Color &_colorEnd)
     {
       this->colorStart = _colorStart;
       this->colorEnd = _colorEnd;
diff --git a/include/gz/rendering/base/BaseRayQuery.hh b/include/gz/rendering/base/BaseRayQuery.hh
index ec6d3abde..b3ce884ab 100644
--- a/include/gz/rendering/base/BaseRayQuery.hh
+++ b/include/gz/rendering/base/BaseRayQuery.hh
@@ -23,11 +23,11 @@
 #include "gz/rendering/RayQuery.hh"
 #include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class BaseRayQuery BaseRayQuery.hh
     /// gz/rendering/base/BaseRayQuery.hh
@@ -91,7 +91,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Vector3d BaseRayQuery<T>::Origin() const
+    gz::math::Vector3d BaseRayQuery<T>::Origin() const
     {
       return this->origin;
     }
@@ -105,7 +105,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Vector3d BaseRayQuery<T>::Direction() const
+    gz::math::Vector3d BaseRayQuery<T>::Direction() const
     {
       return this->direction;
     }
@@ -113,7 +113,7 @@ namespace ignition
     //////////////////////////////////////////////////
     template <class T>
     void BaseRayQuery<T>::SetFromCamera(const CameraPtr &_camera,
-        const ignition::math::Vector2d &_coord)
+        const gz::math::Vector2d &_coord)
     {
       math::Matrix4d projectionMatrix = _camera->ProjectionMatrix();
       math::Matrix4d viewMatrix = _camera->ViewMatrix();
diff --git a/include/gz/rendering/base/BaseRenderEngine.hh b/include/gz/rendering/base/BaseRenderEngine.hh
index 06a73811f..d446852f8 100644
--- a/include/gz/rendering/base/BaseRenderEngine.hh
+++ b/include/gz/rendering/base/BaseRenderEngine.hh
@@ -24,13 +24,13 @@
 #include "gz/rendering/RenderEngine.hh"
 #include "gz/rendering/Storage.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_VISIBLE BaseRenderEngine :
+    class GZ_RENDERING_VISIBLE BaseRenderEngine :
       public virtual RenderEngine
     {
       protected: BaseRenderEngine();
diff --git a/include/gz/rendering/base/BaseRenderPass.hh b/include/gz/rendering/base/BaseRenderPass.hh
index f9dcd44f0..635afc41b 100644
--- a/include/gz/rendering/base/BaseRenderPass.hh
+++ b/include/gz/rendering/base/BaseRenderPass.hh
@@ -20,11 +20,11 @@
 #include <string>
 #include "gz/rendering/RenderPass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class BaseRenderPass BaseRenderPass.hh \
      * gz/rendering/base/BaseRenderPass.hh
diff --git a/include/gz/rendering/base/BaseRenderTarget.hh b/include/gz/rendering/base/BaseRenderTarget.hh
index e25116c85..0d473a301 100644
--- a/include/gz/rendering/base/BaseRenderTarget.hh
+++ b/include/gz/rendering/base/BaseRenderTarget.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseRenderTarget :
@@ -267,7 +267,7 @@ namespace ignition
     {
       if (_index > this->renderPasses.size())
       {
-        ignerr << "RenderPass index out of range: " << _index << std::endl;
+        gzerr << "RenderPass index out of range: " << _index << std::endl;
         return RenderPassPtr();
       }
       return this->renderPasses[_index];
diff --git a/include/gz/rendering/base/BaseRenderTypes.hh b/include/gz/rendering/base/BaseRenderTypes.hh
index bda3c2506..d43df0ef5 100644
--- a/include/gz/rendering/base/BaseRenderTypes.hh
+++ b/include/gz/rendering/base/BaseRenderTypes.hh
@@ -21,11 +21,11 @@
 
 #include "gz/rendering/RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class BaseNodeCompositeStore;
     typedef shared_ptr<BaseNodeCompositeStore>   BaseNodeCompositeStorePtr;
diff --git a/include/gz/rendering/base/BaseScene.hh b/include/gz/rendering/base/BaseScene.hh
index f97f8a104..c415f2cce 100644
--- a/include/gz/rendering/base/BaseScene.hh
+++ b/include/gz/rendering/base/BaseScene.hh
@@ -28,13 +28,13 @@
 #include "gz/rendering/Scene.hh"
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_VISIBLE BaseScene :
+    class GZ_RENDERING_VISIBLE BaseScene :
       IGN_UTILS_WARN_IGNORE__DLL_INTERFACE_MISSING
       public std::enable_shared_from_this<BaseScene>,
       IGN_UTILS_WARN_RESUME__DLL_INTERFACE_MISSING
@@ -204,7 +204,7 @@ namespace ignition
 
       // Documentation inherited
       public: virtual VisualPtr VisualAt(const CameraPtr &_camera,
-                          const ignition::math::Vector2i &_mousePos) override;
+                          const gz::math::Vector2i &_mousePos) override;
 
       // Documentation inherited.
       public: virtual void DestroyVisual(VisualPtr _visual,
@@ -635,7 +635,7 @@ namespace ignition
                    // The following two lines will avoid doxygen warnings
                    (void)_id;
                    (void)_name;
-                   ignerr << "Thermal camera not supported by: "
+                   gzerr << "Thermal camera not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return ThermalCameraPtr();
                  }
@@ -650,7 +650,7 @@ namespace ignition
                    // The following two lines will avoid doxygen warnings
                    (void)_id;
                    (void)_name;
-                   ignerr << "BoundingBox camera not supported by: "
+                   gzerr << "BoundingBox camera not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return BoundingBoxCameraPtr();
                  }
@@ -666,7 +666,7 @@ namespace ignition
                    // The following two lines will avoid doxygen warnings
                    (void)_id;
                    (void)_name;
-                   ignerr << "Segmentation camera not supported by: "
+                   gzerr << "Segmentation camera not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return SegmentationCameraPtr();
                  }
@@ -682,7 +682,7 @@ namespace ignition
                    // The following two lines will avoid doxygen warnings
                    (void)_id;
                    (void)_name;
-                   ignerr << "Wide angle camera not supported by: "
+                   gzerr << "Wide angle camera not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return WideAngleCameraPtr();
                  }
@@ -695,7 +695,7 @@ namespace ignition
                  {
                    (void)_id;
                    (void)_name;
-                   ignerr << "GpuRays not supported by: "
+                   gzerr << "GpuRays not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return GpuRaysPtr();
                  }
@@ -717,7 +717,7 @@ namespace ignition
                  {
                    (void)_id;
                    (void)_name;
-                   ignerr << "GizmoVisual not supported by: "
+                   gzerr << "GizmoVisual not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return GizmoVisualPtr();
                  }
@@ -818,7 +818,7 @@ namespace ignition
                  {
                    (void)_id;
                    (void)_name;
-                   ignerr << "ParticleEmitter not supported by: "
+                   gzerr << "ParticleEmitter not supported by: "
                           << this->Engine()->Name() << std::endl;
                    return ParticleEmitterPtr();
                  }
diff --git a/include/gz/rendering/base/BaseSegmentationCamera.hh b/include/gz/rendering/base/BaseSegmentationCamera.hh
index a9bedb2e6..aa319580e 100644
--- a/include/gz/rendering/base/BaseSegmentationCamera.hh
+++ b/include/gz/rendering/base/BaseSegmentationCamera.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/base/BaseCamera.hh"
 #include "gz/rendering/SegmentationCamera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     template <class T>
     class BaseSegmentationCamera :
@@ -49,7 +49,7 @@ namespace ignition
       public: virtual uint8_t *SegmentationData() const override;
 
       // Documentation inherited
-      public: virtual ignition::common::ConnectionPtr
+      public: virtual gz::common::ConnectionPtr
         ConnectNewSegmentationFrame(
           std::function<void(const uint8_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
@@ -128,7 +128,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::common::ConnectionPtr BaseSegmentationCamera<T>::
+    gz::common::ConnectionPtr BaseSegmentationCamera<T>::
       ConnectNewSegmentationFrame(
           std::function<void(const uint8_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>)
diff --git a/include/gz/rendering/base/BaseSensor.hh b/include/gz/rendering/base/BaseSensor.hh
index d49e95309..de5d59d0a 100644
--- a/include/gz/rendering/base/BaseSensor.hh
+++ b/include/gz/rendering/base/BaseSensor.hh
@@ -19,11 +19,11 @@
 
 #include "gz/rendering/Sensor.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseSensor :
diff --git a/include/gz/rendering/base/BaseStorage.hh b/include/gz/rendering/base/BaseStorage.hh
index b37d009f5..69fcfdb53 100644
--- a/include/gz/rendering/base/BaseStorage.hh
+++ b/include/gz/rendering/base/BaseStorage.hh
@@ -27,11 +27,11 @@
 
 #include "gz/rendering/Storage.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     //////////////////////////////////////////////////
     template <class T, class U>
@@ -446,19 +446,19 @@ namespace ignition
     {
       if (_key.empty())
       {
-        ignerr << "Cannot store item with empty key" << std::endl;
+        gzerr << "Cannot store item with empty key" << std::endl;
         return false;
       }
 
       if (!_value)
       {
-        ignerr << "Cannot store null pointer value" << std::endl;
+        gzerr << "Cannot store null pointer value" << std::endl;
         return false;
       }
 
       if (this->ContainsKey(_key))
       {
-        ignerr << "Item already registered with key: " << _key << std::endl;
+        gzerr << "Item already registered with key: " << _key << std::endl;
         return false;
       }
 
@@ -466,7 +466,7 @@ namespace ignition
 
       if (!derived)
       {
-        ignerr << "Cannot add item created by another render-engine"
+        gzerr << "Cannot add item created by another render-engine"
               << std::endl;
 
         return false;
@@ -529,7 +529,7 @@ namespace ignition
     {
       if (_index >= this->Size())
       {
-        ignerr << "Invalid index: " << _index << std::endl;
+        gzerr << "Invalid index: " << _index << std::endl;
         return nullptr;
       }
 
@@ -634,7 +634,7 @@ namespace ignition
     {
       if (!_object)
       {
-        ignerr << "Cannot add null pointer" << std::endl;
+        gzerr << "Cannot add null pointer" << std::endl;
         return false;
       }
 
@@ -642,7 +642,7 @@ namespace ignition
 
       if (!derived)
       {
-        ignerr << "Cannot add item created by another render-engine"
+        gzerr << "Cannot add item created by another render-engine"
               << std::endl;
 
         return false;
@@ -768,7 +768,7 @@ namespace ignition
     {
       if (!_object)
       {
-        ignerr << "Cannot add null pointer" << std::endl;
+        gzerr << "Cannot add null pointer" << std::endl;
         return false;
       }
 
@@ -864,7 +864,7 @@ namespace ignition
     {
       if (_index >= this->Size())
       {
-        ignerr << "Invalid index: " << _index << std::endl;
+        gzerr << "Invalid index: " << _index << std::endl;
         return this->store.end();
       }
 
@@ -918,13 +918,13 @@ namespace ignition
 
       if (this->ContainsId(id))
       {
-        ignerr << "Another item already exists with id: " << id << std::endl;
+        gzerr << "Another item already exists with id: " << id << std::endl;
         return false;
       }
 
       if (this->ContainsName(name))
       {
-        ignerr << "Another item already exists with name: " << name
+        gzerr << "Another item already exists with name: " << name
             << std::endl;
         return false;
       }
@@ -1077,7 +1077,7 @@ namespace ignition
         _index -= size;
       }
 
-      ignerr << "Invalid index: " << origIndex << std::endl;
+      gzerr << "Invalid index: " << origIndex << std::endl;
       return nullptr;
     }
 
@@ -1085,7 +1085,7 @@ namespace ignition
     template <class T>
     bool BaseCompositeStore<T>::Add(TPtr)
     {
-      ignerr << "Adding to BaseCompositeStore not supported" << std::endl;
+      gzerr << "Adding to BaseCompositeStore not supported" << std::endl;
       return false;
     }
 
@@ -1241,7 +1241,7 @@ namespace ignition
     {
       if (_index >= this->GetStoreCount())
       {
-        ignerr << "Invalid store index: " << _index << std::endl;
+        gzerr << "Invalid store index: " << _index << std::endl;
         return nullptr;
       }
 
@@ -1254,13 +1254,13 @@ namespace ignition
     {
       if (!_store)
       {
-        ignerr << "Cannot all null store pointer" << std::endl;
+        gzerr << "Cannot all null store pointer" << std::endl;
         return false;
       }
 
       if (this->ContainsStore(_store))
       {
-        ignerr << "Store has already been added" << std::endl;
+        gzerr << "Store has already been added" << std::endl;
         return false;
       }
 
@@ -1286,7 +1286,7 @@ namespace ignition
     {
       if (_index >= this->GetStoreCount())
       {
-        ignerr << "Invalid store index: " << _index << std::endl;
+        gzerr << "Invalid store index: " << _index << std::endl;
         return nullptr;
       }
 
diff --git a/include/gz/rendering/base/BaseText.hh b/include/gz/rendering/base/BaseText.hh
index 7f32194ce..e8a973443 100644
--- a/include/gz/rendering/base/BaseText.hh
+++ b/include/gz/rendering/base/BaseText.hh
@@ -21,11 +21,11 @@
 #include "gz/rendering/Text.hh"
 #include "gz/rendering/base/BaseObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of a text geometry
     template <class T>
@@ -58,11 +58,11 @@ namespace ignition
       public: virtual std::string TextString() const override;
 
       // Documentation inherited.
-      public: virtual void SetColor(const ignition::math::Color &_color)
+      public: virtual void SetColor(const gz::math::Color &_color)
           override;
 
       // Documentation inherited.
-      public: virtual ignition::math::Color Color() const override;
+      public: virtual gz::math::Color Color() const override;
 
       // Documentation inherited.
       public: virtual void SetCharHeight(const float _height) override;
@@ -98,7 +98,7 @@ namespace ignition
       public: virtual bool ShowOnTop() const override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox AABB() const override;
+      public: virtual gz::math::AxisAlignedBox AABB() const override;
 
       /// \brief Font name, such as "Liberation Sans"
       protected: std::string fontName = "Liberation Sans";
@@ -107,7 +107,7 @@ namespace ignition
       protected: std::string text;
 
       /// \brief Text color
-      protected: ignition::math::Color color = ignition::math::Color::White;
+      protected: gz::math::Color color = gz::math::Color::White;
 
       /// \brief Character height in meters
       protected: float charHeight = 1.0;
@@ -179,14 +179,14 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::Color BaseText<T>::Color() const
+    gz::math::Color BaseText<T>::Color() const
     {
       return this->color;
     }
 
     //////////////////////////////////////////////////
     template <class T>
-    void BaseText<T>::SetColor(const ignition::math::Color &_color)
+    void BaseText<T>::SetColor(const gz::math::Color &_color)
     {
       this->color = _color;
       this->textDirty = true;
@@ -278,7 +278,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::AxisAlignedBox BaseText<T>::AABB() const
+    gz::math::AxisAlignedBox BaseText<T>::AABB() const
     {
       math::AxisAlignedBox box;
       return box;
diff --git a/include/gz/rendering/base/BaseThermalCamera.hh b/include/gz/rendering/base/BaseThermalCamera.hh
index dc365fe26..5f29515cf 100644
--- a/include/gz/rendering/base/BaseThermalCamera.hh
+++ b/include/gz/rendering/base/BaseThermalCamera.hh
@@ -22,11 +22,11 @@
 #include "gz/rendering/base/BaseCamera.hh"
 #include "gz/rendering/ThermalCamera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of the ThermalCamera class
     template <class T>
@@ -78,7 +78,7 @@ namespace ignition
       public: virtual void SetHeatSourceTemperatureRange(float _range) override;
 
       // Documentation inherted.
-      public: virtual ignition::common::ConnectionPtr ConnectNewThermalFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewThermalFrame(
           std::function<void(const uint16_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
@@ -89,10 +89,10 @@ namespace ignition
       protected: float ambientRange = 0.0f;
 
       /// \brief Minimum temperature
-      protected: float minTemp = -ignition::math::INF_F;
+      protected: float minTemp = -gz::math::INF_F;
 
       /// \brief Maximum temperature
-      protected: float maxTemp = ignition::math::INF_F;
+      protected: float maxTemp = gz::math::INF_F;
 
       /// \brief Linear resolution. Defaults to 10mK.
       protected: float resolution = 0.01f;
diff --git a/include/gz/rendering/base/BaseVisual.hh b/include/gz/rendering/base/BaseVisual.hh
index 848186eea..56df7832a 100644
--- a/include/gz/rendering/base/BaseVisual.hh
+++ b/include/gz/rendering/base/BaseVisual.hh
@@ -27,11 +27,11 @@
 #include "gz/rendering/RenderEngine.hh"
 #include "gz/rendering/base/BaseStorage.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template <class T>
     class BaseVisual :
@@ -107,11 +107,11 @@ namespace ignition
       public: virtual void Destroy() override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox BoundingBox()
+      public: virtual gz::math::AxisAlignedBox BoundingBox()
               const override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox LocalBoundingBox()
+      public: virtual gz::math::AxisAlignedBox LocalBoundingBox()
               const override;
 
       // Documentation inherited.
@@ -135,7 +135,7 @@ namespace ignition
       protected: uint32_t visibilityFlags = IGN_VISIBILITY_ALL;
 
       /// \brief The bounding box of the visual
-      protected: ignition::math::AxisAlignedBox boundingBox;
+      protected: gz::math::AxisAlignedBox boundingBox;
 
       /// \brief True if wireframe mode is enabled else false
       protected: bool wireframe = false;
@@ -173,7 +173,7 @@ namespace ignition
 
       if (!rawPose.IsFinite())
       {
-        ignerr << "Unable to set pose of a node: "
+        gzerr << "Unable to set pose of a node: "
                << "non-finite (nan, inf) values detected." << std::endl;
         return;
       }
@@ -266,11 +266,11 @@ namespace ignition
       _material = (_unique && count > 0) ? _material->Clone() : _material;
 
       auto children_ =
-          std::dynamic_pointer_cast<BaseStore<ignition::rendering::Node, T>>(
+          std::dynamic_pointer_cast<BaseStore<gz::rendering::Node, T>>(
           this->Children());
       if (!children_)
       {
-        ignerr << "Cast failed in BaseVisual::SetChildMaterial" << std::endl;
+        gzerr << "Cast failed in BaseVisual::SetChildMaterial" << std::endl;
         return;
       }
       for (auto it = children_->Begin(); it != children_->End(); ++it)
@@ -326,11 +326,11 @@ namespace ignition
     void BaseVisual<T>::PreRenderChildren()
     {
       auto children_ =
-          std::dynamic_pointer_cast<BaseStore<ignition::rendering::Node, T>>(
+          std::dynamic_pointer_cast<BaseStore<gz::rendering::Node, T>>(
           this->Children());
       if (!children_)
       {
-        ignerr << "Cast failed in BaseVisual::PreRenderChildren" << std::endl;
+        gzerr << "Cast failed in BaseVisual::PreRenderChildren" << std::endl;
         return;
       }
       for (auto it = children_->Begin(); it != children_->End(); ++it)
@@ -363,7 +363,7 @@ namespace ignition
     template <class T>
     void BaseVisual<T>::SetWireframe(bool _show)
     {
-      ignerr << "SetWireframe(" << _show << ") not supported for "
+      gzerr << "SetWireframe(" << _show << ") not supported for "
              << "render engine: " << this->Scene()->Engine()->Name()
              << std::endl;
     }
@@ -372,24 +372,24 @@ namespace ignition
     template <class T>
     void BaseVisual<T>::SetVisible(bool _visible)
     {
-      ignerr << "SetVisible(" << _visible << ") not supported for "
+      gzerr << "SetVisible(" << _visible << ") not supported for "
              << "render engine: " << this->Scene()->Engine()->Name()
              << std::endl;
     }
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::AxisAlignedBox BaseVisual<T>::LocalBoundingBox() const
+    gz::math::AxisAlignedBox BaseVisual<T>::LocalBoundingBox() const
     {
-      ignition::math::AxisAlignedBox box;
+      gz::math::AxisAlignedBox box;
 
       // Recursively loop through child visuals
       auto childNodes =
-          std::dynamic_pointer_cast<BaseStore<ignition::rendering::Node, T>>(
+          std::dynamic_pointer_cast<BaseStore<gz::rendering::Node, T>>(
           this->Children());
       if (!childNodes)
       {
-        ignerr << "Cast failed in BaseVisual::LocalBoundingBox" << std::endl;
+        gzerr << "Cast failed in BaseVisual::LocalBoundingBox" << std::endl;
         return box;
       }
       for (auto it = childNodes->Begin(); it != childNodes->End(); ++it)
@@ -398,7 +398,7 @@ namespace ignition
         VisualPtr visual = std::dynamic_pointer_cast<Visual>(child);
         if (visual)
         {
-          ignition::math::AxisAlignedBox aabb = visual->LocalBoundingBox();
+          gz::math::AxisAlignedBox aabb = visual->LocalBoundingBox();
           if (aabb.Min().IsFinite() && aabb.Max().IsFinite())
             box.Merge(aabb);
         }
@@ -408,17 +408,17 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::AxisAlignedBox BaseVisual<T>::BoundingBox() const
+    gz::math::AxisAlignedBox BaseVisual<T>::BoundingBox() const
     {
-      ignition::math::AxisAlignedBox box;
+      gz::math::AxisAlignedBox box;
 
       // Recursively loop through child visuals
       auto childNodes =
-          std::dynamic_pointer_cast<BaseStore<ignition::rendering::Node, T>>(
+          std::dynamic_pointer_cast<BaseStore<gz::rendering::Node, T>>(
           this->Children());
       if (!childNodes)
       {
-        ignerr << "Cast failed in BaseVisual::BoundingBox" << std::endl;
+        gzerr << "Cast failed in BaseVisual::BoundingBox" << std::endl;
         return box;
       }
       for (auto it = childNodes->Begin(); it != childNodes->End(); ++it)
@@ -453,11 +453,11 @@ namespace ignition
 
       // recursively set child visuals' visibility flags
       auto childNodes =
-          std::dynamic_pointer_cast<BaseStore<ignition::rendering::Node, T>>(
+          std::dynamic_pointer_cast<BaseStore<gz::rendering::Node, T>>(
           this->Children());
       if (!childNodes)
       {
-        ignerr << "Cast failed in BaseVisual::SetVisibiltyFlags" << std::endl;
+        gzerr << "Cast failed in BaseVisual::SetVisibiltyFlags" << std::endl;
         return;
       }
       for (auto it = childNodes->Begin(); it != childNodes->End(); ++it)
@@ -484,7 +484,7 @@ namespace ignition
       ScenePtr scene_ = this->Scene();
       if (nullptr == scene_)
       {
-        ignerr << "Cloning a visual failed because the visual to be cloned is "
+        gzerr << "Cloning a visual failed because the visual to be cloned is "
           << "not attached to a scene.\n";
         return nullptr;
       }
@@ -499,7 +499,7 @@ namespace ignition
         auto parentScene = _newParent->Scene();
         if (nullptr != parentScene && parentScene->Id() != scene_->Id())
         {
-          ignerr << "Cloning a visual failed because the desired parent of the "
+          gzerr << "Cloning a visual failed because the desired parent of the "
             << "cloned visual belongs to a different scene.\n";
           scene_->DestroyVisual(result);
           return nullptr;
@@ -516,11 +516,11 @@ namespace ignition
 
       // if the visual that was cloned has child visuals, clone those as well
       auto children_ =
-          std::dynamic_pointer_cast<BaseStore<ignition::rendering::Node, T>>(
+          std::dynamic_pointer_cast<BaseStore<gz::rendering::Node, T>>(
           this->Children());
       if (!children_)
       {
-        ignerr << "Cast failed in BaseVisual::Clone\n";
+        gzerr << "Cast failed in BaseVisual::Clone\n";
         scene_->DestroyVisual(result);
         return nullptr;
       }
@@ -532,7 +532,7 @@ namespace ignition
         // retrieved, or if cloning the child visual failed
         if (!visual || !visual->Clone("", result))
         {
-          ignerr << "Cloning a child visual failed.\n";
+          gzerr << "Cloning a child visual failed.\n";
           scene_->DestroyVisual(result, true);
           return nullptr;
         }
diff --git a/include/gz/rendering/base/BaseWideAngleCamera.hh b/include/gz/rendering/base/BaseWideAngleCamera.hh
index 70dd17c83..c40861960 100644
--- a/include/gz/rendering/base/BaseWideAngleCamera.hh
+++ b/include/gz/rendering/base/BaseWideAngleCamera.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/CameraLens.hh"
 #include "gz/rendering/WideAngleCamera.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     template <class T>
     class BaseWideAngleCamera :
       public virtual WideAngleCamera,
@@ -101,7 +101,7 @@ namespace ignition
     math::Vector3d BaseWideAngleCamera<T>:: Project3d(const math::Vector3d &)
         const
     {
-      ignerr << "Project3d is not supported for "
+      gzerr << "Project3d is not supported for "
              << "render engine: " << this->Scene()->Engine()->Name()
              << std::endl;
       return math::Vector3d();
diff --git a/include/gz/rendering/base/BaseWireBox.hh b/include/gz/rendering/base/BaseWireBox.hh
index 4ac7f1061..8d42100af 100644
--- a/include/gz/rendering/base/BaseWireBox.hh
+++ b/include/gz/rendering/base/BaseWireBox.hh
@@ -20,11 +20,11 @@
 #include <string>
 #include "gz/rendering/WireBox.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Base implementation of a wireframe box.
     template <class T>
@@ -45,13 +45,13 @@ namespace ignition
       public: virtual void Destroy();
 
       // Documentation inherited.
-      public: virtual void SetBox(const ignition::math::AxisAlignedBox &_box);
+      public: virtual void SetBox(const gz::math::AxisAlignedBox &_box);
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox Box() const;
+      public: virtual gz::math::AxisAlignedBox Box() const;
 
       // \brief Underlying axis aligned box that the wire box reflects.
-      protected: ignition::math::AxisAlignedBox box;
+      protected: gz::math::AxisAlignedBox box;
 
       /// \brief Flag to indicate WireBox properties have changed
       protected: bool wireBoxDirty = false;
@@ -87,7 +87,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    void BaseWireBox<T>::SetBox(const ignition::math::AxisAlignedBox &_box)
+    void BaseWireBox<T>::SetBox(const gz::math::AxisAlignedBox &_box)
     {
       this->box = _box;
       this->wireBoxDirty = true;
@@ -95,7 +95,7 @@ namespace ignition
 
     //////////////////////////////////////////////////
     template <class T>
-    ignition::math::AxisAlignedBox BaseWireBox<T>::Box() const
+    gz::math::AxisAlignedBox BaseWireBox<T>::Box() const
     {
       return this->box;
     }
diff --git a/include/gz/rendering/config.hh.in b/include/gz/rendering/config.hh.in
index fd052ebf6..948032d94 100644
--- a/include/gz/rendering/config.hh.in
+++ b/include/gz/rendering/config.hh.in
@@ -1,26 +1,45 @@
+/*
+ * Copyright (C) 2022 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
 /* Config.hh. Generated by CMake for @PROJECT_NAME@. */
 
+#ifndef GZ_RENDERING_CONFIG_HH_
+#define GZ_RENDERING_CONFIG_HH_
+
 /* Version number */
-#define IGNITION_RENDERING_MAJOR_VERSION ${PROJECT_VERSION_MAJOR}
-#define IGNITION_RENDERING_MINOR_VERSION ${PROJECT_VERSION_MINOR}
-#define IGNITION_RENDERING_PATCH_VERSION ${PROJECT_VERSION_PATCH}
+#define GZ_RENDERING_MAJOR_VERSION ${PROJECT_VERSION_MAJOR}
+#define GZ_RENDERING_MINOR_VERSION ${PROJECT_VERSION_MINOR}
+#define GZ_RENDERING_PATCH_VERSION ${PROJECT_VERSION_PATCH}
 
-#define IGNITION_RENDERING_VERSION "${PROJECT_VERSION}"
-#define IGNITION_RENDERING_VERSION_FULL "${PROJECT_VERSION_FULL}"
+#define GZ_RENDERING_VERSION "${PROJECT_VERSION}"
+#define GZ_RENDERING_VERSION_FULL "${PROJECT_VERSION_FULL}"
 
-#define IGNITION_RENDERING_VERSION_NAMESPACE v${PROJECT_VERSION_MAJOR}
+#define GZ_RENDERING_VERSION_NAMESPACE v${PROJECT_VERSION_MAJOR}
 
-#define IGNITION_RENDERING_VERSION_HEADER "Ignition ${IGN_PROJECT_NAME}, version ${PROJECT_VERSION_FULL}\nCopyright (C) 2014 Open Source Robotics Foundation.\nReleased under the Apache 2.0 License.\n\n"
+#define GZ_RENDERING_VERSION_HEADER "Gazebo Rendering, version ${PROJECT_VERSION_FULL}\nCopyright (C) 2014 Open Source Robotics Foundation.\nReleased under the Apache 2.0 License.\n\n"
 
-#define IGN_RENDERING_RESOURCE_PATH "${IGN_RENDERING_RESOURCE_PATH}"
+#define GZ_RENDERING_RESOURCE_PATH "${GZ_RENDERING_RESOURCE_PATH}"
 
-#define IGNITION_RENDERING_ENGINE_INSTALL_DIR "${IGNITION_RENDERING_ENGINE_INSTALL_DIR}"
+#define GZ_RENDERING_ENGINE_INSTALL_DIR "${GZ_RENDERING_ENGINE_INSTALL_DIR}"
 
-#cmakedefine BUILD_TYPE_PROFILE 1
-#cmakedefine BUILD_TYPE_DEBUG 1
-#cmakedefine BUILD_TYPE_RELEASE 1
 #cmakedefine HAVE_OGRE 1
 #cmakedefine HAVE_OGRE2 1
 #cmakedefine HAVE_OPTIX 1
 #cmakedefine HAVE_GAZEBO 1
 #cmakedefine INCLUDE_RTSHADER 1
+
+#endif
diff --git a/include/ignition/rendering.hh b/include/ignition/rendering.hh
index 60ce766d6..c7494084f 100644
--- a/include/ignition/rendering.hh
+++ b/include/ignition/rendering.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ArrowVisual.hh b/include/ignition/rendering/ArrowVisual.hh
index 2aade9765..4d1b9c041 100644
--- a/include/ignition/rendering/ArrowVisual.hh
+++ b/include/ignition/rendering/ArrowVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ArrowVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/AxisVisual.hh b/include/ignition/rendering/AxisVisual.hh
index 9c15d7b7c..872981f14 100644
--- a/include/ignition/rendering/AxisVisual.hh
+++ b/include/ignition/rendering/AxisVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/AxisVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/BoundingBox.hh b/include/ignition/rendering/BoundingBox.hh
index 0f8125928..911d351e4 100644
--- a/include/ignition/rendering/BoundingBox.hh
+++ b/include/ignition/rendering/BoundingBox.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/BoundingBox.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/BoundingBoxCamera.hh b/include/ignition/rendering/BoundingBoxCamera.hh
index 44f3d57d0..0010e5f27 100644
--- a/include/ignition/rendering/BoundingBoxCamera.hh
+++ b/include/ignition/rendering/BoundingBoxCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/BoundingBoxCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/COMVisual.hh b/include/ignition/rendering/COMVisual.hh
index 2fdd9e6e1..83ac5746f 100644
--- a/include/ignition/rendering/COMVisual.hh
+++ b/include/ignition/rendering/COMVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/COMVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Camera.hh b/include/ignition/rendering/Camera.hh
index 3c407324c..4c615f0d2 100644
--- a/include/ignition/rendering/Camera.hh
+++ b/include/ignition/rendering/Camera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Camera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/CameraLens.hh b/include/ignition/rendering/CameraLens.hh
index ec504a3da..b28d34668 100644
--- a/include/ignition/rendering/CameraLens.hh
+++ b/include/ignition/rendering/CameraLens.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/CameraLens.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Capsule.hh b/include/ignition/rendering/Capsule.hh
index cc4a29394..5d51cd0af 100644
--- a/include/ignition/rendering/Capsule.hh
+++ b/include/ignition/rendering/Capsule.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Capsule.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/CompositeVisual.hh b/include/ignition/rendering/CompositeVisual.hh
index e3f7c325e..fd36a6794 100644
--- a/include/ignition/rendering/CompositeVisual.hh
+++ b/include/ignition/rendering/CompositeVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/CompositeVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/DepthCamera.hh b/include/ignition/rendering/DepthCamera.hh
index 9ccb6499b..f0aa1b6af 100644
--- a/include/ignition/rendering/DepthCamera.hh
+++ b/include/ignition/rendering/DepthCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/DepthCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/DistortionPass.hh b/include/ignition/rendering/DistortionPass.hh
index 5e7abaa00..573e01fc2 100644
--- a/include/ignition/rendering/DistortionPass.hh
+++ b/include/ignition/rendering/DistortionPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/DistortionPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Export.hh b/include/ignition/rendering/Export.hh
index f2cd7f018..d6119ebf2 100644
--- a/include/ignition/rendering/Export.hh
+++ b/include/ignition/rendering/Export.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Export.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/GaussianNoisePass.hh b/include/ignition/rendering/GaussianNoisePass.hh
index d35190f26..b182f7438 100644
--- a/include/ignition/rendering/GaussianNoisePass.hh
+++ b/include/ignition/rendering/GaussianNoisePass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/GaussianNoisePass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Geometry.hh b/include/ignition/rendering/Geometry.hh
index 30b310bd4..fb35700b8 100644
--- a/include/ignition/rendering/Geometry.hh
+++ b/include/ignition/rendering/Geometry.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Geometry.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/GizmoVisual.hh b/include/ignition/rendering/GizmoVisual.hh
index 8334d5bd7..6d8dbc247 100644
--- a/include/ignition/rendering/GizmoVisual.hh
+++ b/include/ignition/rendering/GizmoVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/GizmoVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/GpuRays.hh b/include/ignition/rendering/GpuRays.hh
index 6eef1b3c0..dbbf31f69 100644
--- a/include/ignition/rendering/GpuRays.hh
+++ b/include/ignition/rendering/GpuRays.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/GpuRays.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/GraphicsAPI.hh b/include/ignition/rendering/GraphicsAPI.hh
index 2913f32c6..766a23854 100644
--- a/include/ignition/rendering/GraphicsAPI.hh
+++ b/include/ignition/rendering/GraphicsAPI.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/GraphicsAPI.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Grid.hh b/include/ignition/rendering/Grid.hh
index bdda075a1..5a8c071c1 100644
--- a/include/ignition/rendering/Grid.hh
+++ b/include/ignition/rendering/Grid.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Grid.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Heightmap.hh b/include/ignition/rendering/Heightmap.hh
index 3930486e4..45046abd7 100644
--- a/include/ignition/rendering/Heightmap.hh
+++ b/include/ignition/rendering/Heightmap.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Heightmap.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/HeightmapDescriptor.hh b/include/ignition/rendering/HeightmapDescriptor.hh
index ad13431db..c0d3b5f86 100644
--- a/include/ignition/rendering/HeightmapDescriptor.hh
+++ b/include/ignition/rendering/HeightmapDescriptor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/HeightmapDescriptor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Image.hh b/include/ignition/rendering/Image.hh
index 1f0da6f9b..79d33e605 100644
--- a/include/ignition/rendering/Image.hh
+++ b/include/ignition/rendering/Image.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Image.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/InertiaVisual.hh b/include/ignition/rendering/InertiaVisual.hh
index d4d617e7e..613f10afc 100644
--- a/include/ignition/rendering/InertiaVisual.hh
+++ b/include/ignition/rendering/InertiaVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/InertiaVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/JointVisual.hh b/include/ignition/rendering/JointVisual.hh
index 249625958..602c8cd80 100644
--- a/include/ignition/rendering/JointVisual.hh
+++ b/include/ignition/rendering/JointVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/JointVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/LidarVisual.hh b/include/ignition/rendering/LidarVisual.hh
index afd68b6c4..0f42e9fa4 100644
--- a/include/ignition/rendering/LidarVisual.hh
+++ b/include/ignition/rendering/LidarVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/LidarVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Light.hh b/include/ignition/rendering/Light.hh
index 728a8fbab..6d91de0b3 100644
--- a/include/ignition/rendering/Light.hh
+++ b/include/ignition/rendering/Light.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Light.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/LightVisual.hh b/include/ignition/rendering/LightVisual.hh
index 94119044c..7fa0bc1c5 100644
--- a/include/ignition/rendering/LightVisual.hh
+++ b/include/ignition/rendering/LightVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/LightVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Marker.hh b/include/ignition/rendering/Marker.hh
index 18776c274..08b0526c6 100644
--- a/include/ignition/rendering/Marker.hh
+++ b/include/ignition/rendering/Marker.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Marker.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Material.hh b/include/ignition/rendering/Material.hh
index 7d84d0adb..4793df59e 100644
--- a/include/ignition/rendering/Material.hh
+++ b/include/ignition/rendering/Material.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Material.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Mesh.hh b/include/ignition/rendering/Mesh.hh
index fc660e6de..80122cdeb 100644
--- a/include/ignition/rendering/Mesh.hh
+++ b/include/ignition/rendering/Mesh.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Mesh.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/MeshDescriptor.hh b/include/ignition/rendering/MeshDescriptor.hh
index af3c6cc58..22fcd1b00 100644
--- a/include/ignition/rendering/MeshDescriptor.hh
+++ b/include/ignition/rendering/MeshDescriptor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/MeshDescriptor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/MoveToHelper.hh b/include/ignition/rendering/MoveToHelper.hh
index 358078858..815102069 100644
--- a/include/ignition/rendering/MoveToHelper.hh
+++ b/include/ignition/rendering/MoveToHelper.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/MoveToHelper.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Node.hh b/include/ignition/rendering/Node.hh
index f5aba2fc5..9c0f410a8 100644
--- a/include/ignition/rendering/Node.hh
+++ b/include/ignition/rendering/Node.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Node.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Object.hh b/include/ignition/rendering/Object.hh
index d45bc4ad2..94d801836 100644
--- a/include/ignition/rendering/Object.hh
+++ b/include/ignition/rendering/Object.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Object.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/OrbitViewController.hh b/include/ignition/rendering/OrbitViewController.hh
index 210df15eb..379903871 100644
--- a/include/ignition/rendering/OrbitViewController.hh
+++ b/include/ignition/rendering/OrbitViewController.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/OrbitViewController.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/OrthoViewController.hh b/include/ignition/rendering/OrthoViewController.hh
index 8ea0fb60e..087c2e774 100644
--- a/include/ignition/rendering/OrthoViewController.hh
+++ b/include/ignition/rendering/OrthoViewController.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/OrthoViewController.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ParticleEmitter.hh b/include/ignition/rendering/ParticleEmitter.hh
index 715f25c7c..be1d3e5d7 100644
--- a/include/ignition/rendering/ParticleEmitter.hh
+++ b/include/ignition/rendering/ParticleEmitter.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ParticleEmitter.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/PixelFormat.hh b/include/ignition/rendering/PixelFormat.hh
index 76a345a8e..f32cef2a5 100644
--- a/include/ignition/rendering/PixelFormat.hh
+++ b/include/ignition/rendering/PixelFormat.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/PixelFormat.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RayQuery.hh b/include/ignition/rendering/RayQuery.hh
index 520e02147..a4e5d14c2 100644
--- a/include/ignition/rendering/RayQuery.hh
+++ b/include/ignition/rendering/RayQuery.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RayQuery.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderEngine.hh b/include/ignition/rendering/RenderEngine.hh
index e834d2bcd..452b93d8d 100644
--- a/include/ignition/rendering/RenderEngine.hh
+++ b/include/ignition/rendering/RenderEngine.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderEngine.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderEngineManager.hh b/include/ignition/rendering/RenderEngineManager.hh
index c0bd0430c..ad5282b3b 100644
--- a/include/ignition/rendering/RenderEngineManager.hh
+++ b/include/ignition/rendering/RenderEngineManager.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderEngineManager.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderEnginePlugin.hh b/include/ignition/rendering/RenderEnginePlugin.hh
index edcf3c0c4..5273d6c12 100644
--- a/include/ignition/rendering/RenderEnginePlugin.hh
+++ b/include/ignition/rendering/RenderEnginePlugin.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderEnginePlugin.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderPass.hh b/include/ignition/rendering/RenderPass.hh
index 6d0adf380..45beea741 100644
--- a/include/ignition/rendering/RenderPass.hh
+++ b/include/ignition/rendering/RenderPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderPassSystem.hh b/include/ignition/rendering/RenderPassSystem.hh
index bdc3df1c1..921e85712 100644
--- a/include/ignition/rendering/RenderPassSystem.hh
+++ b/include/ignition/rendering/RenderPassSystem.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderPassSystem.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderTarget.hh b/include/ignition/rendering/RenderTarget.hh
index 24af82981..601152a3d 100644
--- a/include/ignition/rendering/RenderTarget.hh
+++ b/include/ignition/rendering/RenderTarget.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderTarget.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderTypes.hh b/include/ignition/rendering/RenderTypes.hh
index e4f7df84c..0ac4d32b5 100644
--- a/include/ignition/rendering/RenderTypes.hh
+++ b/include/ignition/rendering/RenderTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/RenderingIface.hh b/include/ignition/rendering/RenderingIface.hh
index 9ced1bff1..c8e5d9e2c 100644
--- a/include/ignition/rendering/RenderingIface.hh
+++ b/include/ignition/rendering/RenderingIface.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/RenderingIface.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Scene.hh b/include/ignition/rendering/Scene.hh
index ecd278ee7..da6d5cc4b 100644
--- a/include/ignition/rendering/Scene.hh
+++ b/include/ignition/rendering/Scene.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Scene.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/SegmentationCamera.hh b/include/ignition/rendering/SegmentationCamera.hh
index 67b16b6a7..7290bbc35 100644
--- a/include/ignition/rendering/SegmentationCamera.hh
+++ b/include/ignition/rendering/SegmentationCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/SegmentationCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Sensor.hh b/include/ignition/rendering/Sensor.hh
index bab0e7873..447e75956 100644
--- a/include/ignition/rendering/Sensor.hh
+++ b/include/ignition/rendering/Sensor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Sensor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ShaderParam.hh b/include/ignition/rendering/ShaderParam.hh
index c8008db57..8fb346e43 100644
--- a/include/ignition/rendering/ShaderParam.hh
+++ b/include/ignition/rendering/ShaderParam.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ShaderParam.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ShaderParams.hh b/include/ignition/rendering/ShaderParams.hh
index ede4e92f9..d1ab460d9 100644
--- a/include/ignition/rendering/ShaderParams.hh
+++ b/include/ignition/rendering/ShaderParams.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ShaderParams.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ShaderType.hh b/include/ignition/rendering/ShaderType.hh
index 83e93fdb9..be1e87686 100644
--- a/include/ignition/rendering/ShaderType.hh
+++ b/include/ignition/rendering/ShaderType.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ShaderType.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Storage.hh b/include/ignition/rendering/Storage.hh
index 9b8d79257..63c0ce614 100644
--- a/include/ignition/rendering/Storage.hh
+++ b/include/ignition/rendering/Storage.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Storage.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Text.hh b/include/ignition/rendering/Text.hh
index 6ac966297..80f5ca9a7 100644
--- a/include/ignition/rendering/Text.hh
+++ b/include/ignition/rendering/Text.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Text.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ThermalCamera.hh b/include/ignition/rendering/ThermalCamera.hh
index 30f953e79..5b79dc87f 100644
--- a/include/ignition/rendering/ThermalCamera.hh
+++ b/include/ignition/rendering/ThermalCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ThermalCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/TransformController.hh b/include/ignition/rendering/TransformController.hh
index e5f9dfa64..b5b3e2d66 100644
--- a/include/ignition/rendering/TransformController.hh
+++ b/include/ignition/rendering/TransformController.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/TransformController.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/TransformType.hh b/include/ignition/rendering/TransformType.hh
index ddd5c38f3..e202b455e 100644
--- a/include/ignition/rendering/TransformType.hh
+++ b/include/ignition/rendering/TransformType.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/TransformType.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Utils.hh b/include/ignition/rendering/Utils.hh
index 58b2642af..fde07aa59 100644
--- a/include/ignition/rendering/Utils.hh
+++ b/include/ignition/rendering/Utils.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Utils.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/ViewController.hh b/include/ignition/rendering/ViewController.hh
index 6f299c271..46645ee04 100644
--- a/include/ignition/rendering/ViewController.hh
+++ b/include/ignition/rendering/ViewController.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ViewController.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/Visual.hh b/include/ignition/rendering/Visual.hh
index 0a2efcf53..e83c01c27 100644
--- a/include/ignition/rendering/Visual.hh
+++ b/include/ignition/rendering/Visual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/Visual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/WideAngleCamera.hh b/include/ignition/rendering/WideAngleCamera.hh
index c3cc71bf3..7fc992c39 100644
--- a/include/ignition/rendering/WideAngleCamera.hh
+++ b/include/ignition/rendering/WideAngleCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/WideAngleCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/WireBox.hh b/include/ignition/rendering/WireBox.hh
index ffedd1b5a..927ee4a3d 100644
--- a/include/ignition/rendering/WireBox.hh
+++ b/include/ignition/rendering/WireBox.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/WireBox.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseArrowVisual.hh b/include/ignition/rendering/base/BaseArrowVisual.hh
index 0930e06dc..9031500f4 100644
--- a/include/ignition/rendering/base/BaseArrowVisual.hh
+++ b/include/ignition/rendering/base/BaseArrowVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseArrowVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseAxisVisual.hh b/include/ignition/rendering/base/BaseAxisVisual.hh
index 1889e6d79..a702944d9 100644
--- a/include/ignition/rendering/base/BaseAxisVisual.hh
+++ b/include/ignition/rendering/base/BaseAxisVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseAxisVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseBoundingBoxCamera.hh b/include/ignition/rendering/base/BaseBoundingBoxCamera.hh
index 6e04ed9dc..59f279e9b 100644
--- a/include/ignition/rendering/base/BaseBoundingBoxCamera.hh
+++ b/include/ignition/rendering/base/BaseBoundingBoxCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseBoundingBoxCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseCOMVisual.hh b/include/ignition/rendering/base/BaseCOMVisual.hh
index 52d29a43b..45e87252f 100644
--- a/include/ignition/rendering/base/BaseCOMVisual.hh
+++ b/include/ignition/rendering/base/BaseCOMVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseCOMVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseCamera.hh b/include/ignition/rendering/base/BaseCamera.hh
index b4582eff7..72226b017 100644
--- a/include/ignition/rendering/base/BaseCamera.hh
+++ b/include/ignition/rendering/base/BaseCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseCapsule.hh b/include/ignition/rendering/base/BaseCapsule.hh
index a6f34357d..8bca8fd06 100644
--- a/include/ignition/rendering/base/BaseCapsule.hh
+++ b/include/ignition/rendering/base/BaseCapsule.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseCapsule.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseDepthCamera.hh b/include/ignition/rendering/base/BaseDepthCamera.hh
index ec7999326..961d27105 100644
--- a/include/ignition/rendering/base/BaseDepthCamera.hh
+++ b/include/ignition/rendering/base/BaseDepthCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseDepthCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseDistortionPass.hh b/include/ignition/rendering/base/BaseDistortionPass.hh
index fc5710f16..3cb04fcf7 100644
--- a/include/ignition/rendering/base/BaseDistortionPass.hh
+++ b/include/ignition/rendering/base/BaseDistortionPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseDistortionPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseGaussianNoisePass.hh b/include/ignition/rendering/base/BaseGaussianNoisePass.hh
index 3244bf2fb..bd2b9146e 100644
--- a/include/ignition/rendering/base/BaseGaussianNoisePass.hh
+++ b/include/ignition/rendering/base/BaseGaussianNoisePass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseGaussianNoisePass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseGeometry.hh b/include/ignition/rendering/base/BaseGeometry.hh
index 0bd6b9980..cfc08fa80 100644
--- a/include/ignition/rendering/base/BaseGeometry.hh
+++ b/include/ignition/rendering/base/BaseGeometry.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseGeometry.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseGizmoVisual.hh b/include/ignition/rendering/base/BaseGizmoVisual.hh
index a3c7bee9a..b7b717fb5 100644
--- a/include/ignition/rendering/base/BaseGizmoVisual.hh
+++ b/include/ignition/rendering/base/BaseGizmoVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseGizmoVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseGpuRays.hh b/include/ignition/rendering/base/BaseGpuRays.hh
index 00f6c62a6..68b4fc94f 100644
--- a/include/ignition/rendering/base/BaseGpuRays.hh
+++ b/include/ignition/rendering/base/BaseGpuRays.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseGpuRays.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseGrid.hh b/include/ignition/rendering/base/BaseGrid.hh
index 3bd886b7f..85f675189 100644
--- a/include/ignition/rendering/base/BaseGrid.hh
+++ b/include/ignition/rendering/base/BaseGrid.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseGrid.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseHeightmap.hh b/include/ignition/rendering/base/BaseHeightmap.hh
index 313631963..062111b83 100644
--- a/include/ignition/rendering/base/BaseHeightmap.hh
+++ b/include/ignition/rendering/base/BaseHeightmap.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseHeightmap.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseInertiaVisual.hh b/include/ignition/rendering/base/BaseInertiaVisual.hh
index 26ce47b77..6b40d9069 100644
--- a/include/ignition/rendering/base/BaseInertiaVisual.hh
+++ b/include/ignition/rendering/base/BaseInertiaVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseInertiaVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseJointVisual.hh b/include/ignition/rendering/base/BaseJointVisual.hh
index 7f0f6600d..abedbee9b 100644
--- a/include/ignition/rendering/base/BaseJointVisual.hh
+++ b/include/ignition/rendering/base/BaseJointVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseJointVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseLidarVisual.hh b/include/ignition/rendering/base/BaseLidarVisual.hh
index 25b1b44e4..2b9ab332b 100644
--- a/include/ignition/rendering/base/BaseLidarVisual.hh
+++ b/include/ignition/rendering/base/BaseLidarVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseLidarVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseLight.hh b/include/ignition/rendering/base/BaseLight.hh
index b2b087603..02f22c5f8 100644
--- a/include/ignition/rendering/base/BaseLight.hh
+++ b/include/ignition/rendering/base/BaseLight.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseLight.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseLightVisual.hh b/include/ignition/rendering/base/BaseLightVisual.hh
index 7fae37d1a..b13630ec3 100644
--- a/include/ignition/rendering/base/BaseLightVisual.hh
+++ b/include/ignition/rendering/base/BaseLightVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseLightVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseMarker.hh b/include/ignition/rendering/base/BaseMarker.hh
index 8cd23b360..33d20c14c 100644
--- a/include/ignition/rendering/base/BaseMarker.hh
+++ b/include/ignition/rendering/base/BaseMarker.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseMarker.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseMaterial.hh b/include/ignition/rendering/base/BaseMaterial.hh
index 6d5982829..3f34d4a67 100644
--- a/include/ignition/rendering/base/BaseMaterial.hh
+++ b/include/ignition/rendering/base/BaseMaterial.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseMaterial.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseMesh.hh b/include/ignition/rendering/base/BaseMesh.hh
index 76a9f9d1f..11fb402e6 100644
--- a/include/ignition/rendering/base/BaseMesh.hh
+++ b/include/ignition/rendering/base/BaseMesh.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseMesh.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseNode.hh b/include/ignition/rendering/base/BaseNode.hh
index df8cd7644..fc07c2cbf 100644
--- a/include/ignition/rendering/base/BaseNode.hh
+++ b/include/ignition/rendering/base/BaseNode.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseNode.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseObject.hh b/include/ignition/rendering/base/BaseObject.hh
index 3e0bbed40..7ef101427 100644
--- a/include/ignition/rendering/base/BaseObject.hh
+++ b/include/ignition/rendering/base/BaseObject.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseObject.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseParticleEmitter.hh b/include/ignition/rendering/base/BaseParticleEmitter.hh
index a65bdeed3..641c96c72 100644
--- a/include/ignition/rendering/base/BaseParticleEmitter.hh
+++ b/include/ignition/rendering/base/BaseParticleEmitter.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseParticleEmitter.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseRayQuery.hh b/include/ignition/rendering/base/BaseRayQuery.hh
index becf4be5b..15ef83885 100644
--- a/include/ignition/rendering/base/BaseRayQuery.hh
+++ b/include/ignition/rendering/base/BaseRayQuery.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseRayQuery.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseRenderEngine.hh b/include/ignition/rendering/base/BaseRenderEngine.hh
index 18530dbfc..99f29e4cf 100644
--- a/include/ignition/rendering/base/BaseRenderEngine.hh
+++ b/include/ignition/rendering/base/BaseRenderEngine.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseRenderEngine.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseRenderPass.hh b/include/ignition/rendering/base/BaseRenderPass.hh
index 5ee7ba6d4..0b35cbfc8 100644
--- a/include/ignition/rendering/base/BaseRenderPass.hh
+++ b/include/ignition/rendering/base/BaseRenderPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseRenderPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseRenderTarget.hh b/include/ignition/rendering/base/BaseRenderTarget.hh
index 25221fcaa..97408d518 100644
--- a/include/ignition/rendering/base/BaseRenderTarget.hh
+++ b/include/ignition/rendering/base/BaseRenderTarget.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseRenderTarget.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseRenderTypes.hh b/include/ignition/rendering/base/BaseRenderTypes.hh
index f6acf8090..1073564b1 100644
--- a/include/ignition/rendering/base/BaseRenderTypes.hh
+++ b/include/ignition/rendering/base/BaseRenderTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseRenderTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseScene.hh b/include/ignition/rendering/base/BaseScene.hh
index d0afebe8c..92f7ca659 100644
--- a/include/ignition/rendering/base/BaseScene.hh
+++ b/include/ignition/rendering/base/BaseScene.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseScene.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseSegmentationCamera.hh b/include/ignition/rendering/base/BaseSegmentationCamera.hh
index 867c5da2c..35c80f622 100644
--- a/include/ignition/rendering/base/BaseSegmentationCamera.hh
+++ b/include/ignition/rendering/base/BaseSegmentationCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseSegmentationCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseSensor.hh b/include/ignition/rendering/base/BaseSensor.hh
index bcb0cb415..3748de4dd 100644
--- a/include/ignition/rendering/base/BaseSensor.hh
+++ b/include/ignition/rendering/base/BaseSensor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseSensor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseStorage.hh b/include/ignition/rendering/base/BaseStorage.hh
index 7350a6ba1..549dcf449 100644
--- a/include/ignition/rendering/base/BaseStorage.hh
+++ b/include/ignition/rendering/base/BaseStorage.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseStorage.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseText.hh b/include/ignition/rendering/base/BaseText.hh
index 722fb3470..fcce50f62 100644
--- a/include/ignition/rendering/base/BaseText.hh
+++ b/include/ignition/rendering/base/BaseText.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseText.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseThermalCamera.hh b/include/ignition/rendering/base/BaseThermalCamera.hh
index ef9b84413..138f8cd61 100644
--- a/include/ignition/rendering/base/BaseThermalCamera.hh
+++ b/include/ignition/rendering/base/BaseThermalCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseThermalCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseVisual.hh b/include/ignition/rendering/base/BaseVisual.hh
index 4ef4761bb..98a51aac8 100644
--- a/include/ignition/rendering/base/BaseVisual.hh
+++ b/include/ignition/rendering/base/BaseVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseWideAngleCamera.hh b/include/ignition/rendering/base/BaseWideAngleCamera.hh
index 7615095e4..39f8b6c80 100644
--- a/include/ignition/rendering/base/BaseWideAngleCamera.hh
+++ b/include/ignition/rendering/base/BaseWideAngleCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseWideAngleCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/base/BaseWireBox.hh b/include/ignition/rendering/base/BaseWireBox.hh
index c667b6cc7..105855fa9 100644
--- a/include/ignition/rendering/base/BaseWireBox.hh
+++ b/include/ignition/rendering/base/BaseWireBox.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/base/BaseWireBox.hh>
+#include <ignition/rendering/config.hh>
diff --git a/include/ignition/rendering/config.hh b/include/ignition/rendering/config.hh
index 9c6996b7a..28329742e 100644
--- a/include/ignition/rendering/config.hh
+++ b/include/ignition/rendering/config.hh
@@ -15,4 +15,36 @@
  *
  */
 
+#ifndef IGNITION_RENDERING__CONFIG_HH_
+#define IGNITION_RENDERING__CONFIG_HH_
+
 #include <gz/rendering/config.hh>
+
+#define IGNITION_RENDERING_MAJOR_VERSION GZ_RENDERING_MAJOR_VERSION
+#define IGNITION_RENDERING_MINOR_VERSION GZ_RENDERING_MINOR_VERSION
+#define IGNITION_RENDERING_PATCH_VERSION GZ_RENDERING_PATCH_VERSION
+
+#define IGNITION_RENDERING_VERSION GZ_RENDERING_VERSION
+#define IGNITION_RENDERING_VERSION_FULL GZ_RENDERING_VERSION_FULL
+
+#define IGNITION_RENDERING_VERSION_NAMESPACE GZ_RENDERING_VERSION_NAMESPACE
+
+#define IGNITION_RENDERING_VERSION_HEADER GZ_RENDERING_VERSION_HEADER
+
+#define IGNITION_RENDERING_RESOURCE_PATH GZ_RENDERING_RESOURCE_PATH
+
+#define IGNITION_RENDERING_ENGINE_INSTALL_DIR GZ_RENDERING_ENGINE_INSTALL_DIR
+
+namespace gz
+{
+}
+
+namespace ignition
+{
+  #ifndef SUPPRESS_IGNITION_HEADER_DEPRECATION
+    #pragma message("ignition namespace is deprecated! Use gz instead!")
+  #endif
+  using namespace gz;
+}
+
+#endif
diff --git a/ogre/include/gz/rendering/ogre/OgreArrowVisual.hh b/ogre/include/gz/rendering/ogre/OgreArrowVisual.hh
index 9bdb05a61..2cd481e19 100644
--- a/ogre/include/gz/rendering/ogre/OgreArrowVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreArrowVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseArrowVisual.hh"
 #include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreArrowVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreArrowVisual :
       public BaseArrowVisual<OgreVisual>
     {
       protected: OgreArrowVisual();
diff --git a/ogre/include/gz/rendering/ogre/OgreAxisVisual.hh b/ogre/include/gz/rendering/ogre/OgreAxisVisual.hh
index aa4277a98..d2f1fb338 100644
--- a/ogre/include/gz/rendering/ogre/OgreAxisVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreAxisVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseAxisVisual.hh"
 #include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreAxisVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreAxisVisual :
       public BaseAxisVisual<OgreVisual>
     {
       protected: OgreAxisVisual();
diff --git a/ogre/include/gz/rendering/ogre/OgreCOMVisual.hh b/ogre/include/gz/rendering/ogre/OgreCOMVisual.hh
index 6f451dea4..42f38c7cc 100644
--- a/ogre/include/gz/rendering/ogre/OgreCOMVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreCOMVisual.hh
@@ -30,16 +30,16 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     // Forward declaration
     class OgreCOMVisualPrivate;
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreCOMVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreCOMVisual :
       public BaseCOMVisual<OgreVisual>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreCamera.hh b/ogre/include/gz/rendering/ogre/OgreCamera.hh
index c9ec433b5..3cca75551 100644
--- a/ogre/include/gz/rendering/ogre/OgreCamera.hh
+++ b/ogre/include/gz/rendering/ogre/OgreCamera.hh
@@ -30,16 +30,16 @@ namespace Ogre
   class Camera;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreSelectionBuffer;
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreCamera :
+    class GZ_RENDERING_OGRE_VISIBLE OgreCamera :
       public virtual BaseCamera<OgreSensor>,
       public virtual OgreObjectInterface
     {
@@ -103,7 +103,7 @@ namespace ignition
       public: double FarClip() const;
 
       // Documentation inherited
-      public: virtual VisualPtr VisualAt(const ignition::math::Vector2i
+      public: virtual VisualPtr VisualAt(const gz::math::Vector2i
                   &_mousePos) override;
 
       // Documentation Inherited.
diff --git a/ogre/include/gz/rendering/ogre/OgreCapsule.hh b/ogre/include/gz/rendering/ogre/OgreCapsule.hh
index ef1d035c3..e77cf167b 100644
--- a/ogre/include/gz/rendering/ogre/OgreCapsule.hh
+++ b/ogre/include/gz/rendering/ogre/OgreCapsule.hh
@@ -28,16 +28,16 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
       // Forward declaration
       class OgreCapsulePrivate;
 
       /// \brief Ogre 2.x implementation of a Capsule Visual.
-      class IGNITION_RENDERING_OGRE_VISIBLE OgreCapsule
+      class GZ_RENDERING_OGRE_VISIBLE OgreCapsule
         : public BaseCapsule<OgreGeometry>
       {
         /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreConversions.hh b/ogre/include/gz/rendering/ogre/OgreConversions.hh
index 1783addda..73bb8f9ff 100644
--- a/ogre/include/gz/rendering/ogre/OgreConversions.hh
+++ b/ogre/include/gz/rendering/ogre/OgreConversions.hh
@@ -26,11 +26,11 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \addtogroup ign_rendering
     /// \{
@@ -38,7 +38,7 @@ namespace ignition
     /// \brief Conversions Conversions.hh rendering/Conversions.hh
     /// \brief A set of utility function to convert between Gazebo and Ogre
     /// data types
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreConversions
+    class GZ_RENDERING_OGRE_VISIBLE OgreConversions
     {
       /// \brief Return the equivalent ogre color
       /// \param[in] _color ign-math color to convert
diff --git a/ogre/include/gz/rendering/ogre/OgreDepthCamera.hh b/ogre/include/gz/rendering/ogre/OgreDepthCamera.hh
index 8527a7580..a6710b054 100644
--- a/ogre/include/gz/rendering/ogre/OgreDepthCamera.hh
+++ b/ogre/include/gz/rendering/ogre/OgreDepthCamera.hh
@@ -50,11 +50,11 @@ namespace Ogre
   class Viewport;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreDepthCameraPrivate;
@@ -63,7 +63,7 @@ namespace ignition
      * rendering/ogre/OgreDepthCamera.hh
     **/
     /// \brief Depth camera used to render depth data into an image buffer
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreDepthCamera :
+    class GZ_RENDERING_OGRE_VISIBLE OgreDepthCamera :
       public virtual BaseDepthCamera<OgreSensor>,
       public virtual OgreObjectInterface
     {
@@ -89,14 +89,14 @@ namespace ignition
       /// \brief Connect a to the new depth image signal
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewDepthFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewDepthFrame(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
       /// \brief Connect a to the new rgb point cloud signal
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewRgbPointCloud(
+      public: virtual gz::common::ConnectionPtr ConnectNewRgbPointCloud(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
diff --git a/ogre/include/gz/rendering/ogre/OgreDistortionPass.hh b/ogre/include/gz/rendering/ogre/OgreDistortionPass.hh
index be91fa75d..7bf7290bd 100644
--- a/ogre/include/gz/rendering/ogre/OgreDistortionPass.hh
+++ b/ogre/include/gz/rendering/ogre/OgreDistortionPass.hh
@@ -28,11 +28,11 @@
 #include "gz/rendering/ogre/OgreRenderPass.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class DistortionCompositorListener;
@@ -41,7 +41,7 @@ namespace ignition
      * gz/rendering/ogre/OgreDistortionPass.hh
      */
     /// \brief Ogre implementation of the DistortionPass class
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreDistortionPass :
+    class GZ_RENDERING_OGRE_VISIBLE OgreDistortionPass :
       public BaseDistortionPass<OgreRenderPass>
     {
       /// \brief Constructor
@@ -70,9 +70,9 @@ namespace ignition
       /// \param[in] _width Width of the image texture in pixels.
       /// \param[in] _f Focal length in pixels.
       /// \return Distorted coordinate.
-      public: static ignition::math::Vector2d Distort(
-                  const ignition::math::Vector2d &_in,
-                  const ignition::math::Vector2d &_center,
+      public: static gz::math::Vector2d Distort(
+                  const gz::math::Vector2d &_in,
+                  const gz::math::Vector2d &_center,
                   double _k1, double _k2, double _k3,
                   double _p1, double _p2,
                   unsigned int _width, double _f);
@@ -81,7 +81,7 @@ namespace ignition
       /// \param[in] _x X component of map.
       /// \param[in] _y Y component of map.
       /// \return the distortion map value at the specified index.
-      protected: ignition::math::Vector2d
+      protected: gz::math::Vector2d
         DistortionMapValueClamped(int _x, int _y) const;
 
       /// \brief calculate the correct scale factor to "zoom" the render,
diff --git a/ogre/include/gz/rendering/ogre/OgreDynamicLines.hh b/ogre/include/gz/rendering/ogre/OgreDynamicLines.hh
index a76bac50e..c0bd4d963 100644
--- a/ogre/include/gz/rendering/ogre/OgreDynamicLines.hh
+++ b/ogre/include/gz/rendering/ogre/OgreDynamicLines.hh
@@ -26,11 +26,11 @@
 #include "gz/rendering/ogre/OgreConversions.hh"
 #include "gz/rendering/ogre/OgreDynamicRenderable.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \brief Forward declaration
     class OgreDynamicLinesPrivate;
 
@@ -38,7 +38,7 @@ namespace ignition
      *  gz/rendering/ogre/OgreDynamicLines.hh
      */
     /// \brief Class for drawing lines that can change
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreDynamicLines :
+    class GZ_RENDERING_OGRE_VISIBLE OgreDynamicLines :
       public OgreDynamicRenderable
     {
       /// \brief Constructor
@@ -50,39 +50,39 @@ namespace ignition
       public: virtual ~OgreDynamicLines();
 
       /// \brief Add a point to the point list
-      /// \param[in] _pt ignition::math::Vector3d point
-      /// \param[in] _color ignition::math::Color Point color
-      public: void AddPoint(const ignition::math::Vector3d &_pt,
-            const ignition::math::Color &_color = ignition::math::Color::White);
+      /// \param[in] _pt gz::math::Vector3d point
+      /// \param[in] _color gz::math::Color Point color
+      public: void AddPoint(const gz::math::Vector3d &_pt,
+            const gz::math::Color &_color = gz::math::Color::White);
 
       /// \brief Add a point to the point list.
       /// \param[in] _x X position
       /// \param[in] _y Y position
       /// \param[in] _z Z position
-      /// \param[in] _color ignition::math::Color Point color
+      /// \param[in] _color gz::math::Color Point color
       public: void AddPoint(const double _x, const double _y, const double _z,
-            const ignition::math::Color &_color = ignition::math::Color::White);
+            const gz::math::Color &_color = gz::math::Color::White);
 
       /// \brief Change the location of an existing point in the point list
       /// \param[in] _index Index of the point to set
-      /// \param[in] _value ignition::math::Vector3d value to set the point to
+      /// \param[in] _value gz::math::Vector3d value to set the point to
       public: void SetPoint(unsigned int _index,
-                  const ignition::math::Vector3d &_value);
+                  const gz::math::Vector3d &_value);
 
       /// \brief Change the color of an existing point in the point list
       /// \param[in] _index Index of the point to set
-      /// \param[in] _color ignition::math::Color Pixelcolor color to set the
+      /// \param[in] _color gz::math::Color Pixelcolor color to set the
       /// point to
       public: void SetColor(unsigned int _index,
-                            const ignition::math::Color &_color);
+                            const gz::math::Color &_color);
 
       /// \brief Return the location of an existing point in the point list
       /// \param[in] _index Number of the point to return
-      /// \return ignition::math::Vector3d value of the point. A vector of
-      /// [ignition::math::INF_D, ignition::math::INF_D, ignition::math::INF_D]
+      /// \return gz::math::Vector3d value of the point. A vector of
+      /// [gz::math::INF_D, gz::math::INF_D, gz::math::INF_D]
       /// is returned when then the _index is out of bounds.
-      /// ignition::math::INF_D==std::numeric_limits<double>::infinity()
-      public: ignition::math::Vector3d Point(unsigned int _index) const;
+      /// gz::math::INF_D==std::numeric_limits<double>::infinity()
+      public: gz::math::Vector3d Point(unsigned int _index) const;
 
       /// \brief Return the total number of points in the point list
       /// \return Number of points
diff --git a/ogre/include/gz/rendering/ogre/OgreDynamicRenderable.hh b/ogre/include/gz/rendering/ogre/OgreDynamicRenderable.hh
index 7596bd94c..e390c3c9f 100644
--- a/ogre/include/gz/rendering/ogre/OgreDynamicRenderable.hh
+++ b/ogre/include/gz/rendering/ogre/OgreDynamicRenderable.hh
@@ -23,17 +23,17 @@
 #include "gz/rendering/ogre/OgreRenderTypes.hh"
 #include "gz/rendering/Marker.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /*  \class OgreDynamicRenderable OgreDynamicRenderable.hh \
      *  gz/rendering/ogre/OgreDynamicRenderable.hh
      */
     /// \brief Abstract base class providing mechanisms for dynamically
     /// growing hardware buffers.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreDynamicRenderable :
+    class GZ_RENDERING_OGRE_VISIBLE OgreDynamicRenderable :
       public Ogre::SimpleRenderable
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreGaussianNoisePass.hh b/ogre/include/gz/rendering/ogre/OgreGaussianNoisePass.hh
index 8ef26cefd..d4e2583f9 100644
--- a/ogre/include/gz/rendering/ogre/OgreGaussianNoisePass.hh
+++ b/ogre/include/gz/rendering/ogre/OgreGaussianNoisePass.hh
@@ -26,11 +26,11 @@
 #include "gz/rendering/ogre/OgreRenderPass.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class GaussianNoiseCompositorListener;
@@ -39,7 +39,7 @@ namespace ignition
      * gz/rendering/ogre/OgreGaussianNoisePass.hh
      */
     /// \brief Ogre implementation of the GaussianNoisePass class
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreGaussianNoisePass :
+    class GZ_RENDERING_OGRE_VISIBLE OgreGaussianNoisePass :
       public BaseGaussianNoisePass<OgreRenderPass>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreGeometry.hh b/ogre/include/gz/rendering/ogre/OgreGeometry.hh
index 8ede3a0b2..7de62ebaa 100644
--- a/ogre/include/gz/rendering/ogre/OgreGeometry.hh
+++ b/ogre/include/gz/rendering/ogre/OgreGeometry.hh
@@ -27,13 +27,13 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreGeometry :
+    class GZ_RENDERING_OGRE_VISIBLE OgreGeometry :
       public BaseGeometry<OgreObject>
     {
       protected: OgreGeometry();
diff --git a/ogre/include/gz/rendering/ogre/OgreGizmoVisual.hh b/ogre/include/gz/rendering/ogre/OgreGizmoVisual.hh
index c871c3703..5bebb9f74 100644
--- a/ogre/include/gz/rendering/ogre/OgreGizmoVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreGizmoVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseGizmoVisual.hh"
 #include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreGizmoVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreGizmoVisual :
       public BaseGizmoVisual<OgreVisual>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreGpuRays.hh b/ogre/include/gz/rendering/ogre/OgreGpuRays.hh
index 589283327..5ade68c51 100644
--- a/ogre/include/gz/rendering/ogre/OgreGpuRays.hh
+++ b/ogre/include/gz/rendering/ogre/OgreGpuRays.hh
@@ -41,11 +41,11 @@
   #include <Winsock2.h>
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class OgreGpuRaysPrivate;
@@ -54,7 +54,7 @@ namespace ignition
      * rendering/ogre/OgreGpuRays.hh
     **/
     /// \brief Gpu Rays used to render depth data into an image buffer
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreGpuRays :
+    class GZ_RENDERING_OGRE_VISIBLE OgreGpuRays :
       public BaseGpuRays<OgreSensor>, public Ogre::RenderObjectListener
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreGrid.hh b/ogre/include/gz/rendering/ogre/OgreGrid.hh
index 6a577051b..e79c56731 100644
--- a/ogre/include/gz/rendering/ogre/OgreGrid.hh
+++ b/ogre/include/gz/rendering/ogre/OgreGrid.hh
@@ -28,17 +28,17 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class OgreGridPrivate;
 
     /// \brief Ogre implementation of a grid geometry.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreGrid
+    class GZ_RENDERING_OGRE_VISIBLE OgreGrid
       : public BaseGrid<OgreGeometry>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreHeightmap.hh b/ogre/include/gz/rendering/ogre/OgreHeightmap.hh
index 286edc2bb..2763d597b 100644
--- a/ogre/include/gz/rendering/ogre/OgreHeightmap.hh
+++ b/ogre/include/gz/rendering/ogre/OgreHeightmap.hh
@@ -27,24 +27,24 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 
 // Ignoring warning: "non dll-interface class
-// 'ignition::rendering::v5::Heightmap' used as base for dll-interface class"
+// 'gz::rendering::v5::Heightmap' used as base for dll-interface class"
 // because `Heightmap` and `BaseHeightmap` are header-only
 #ifdef _MSC_VER
  #pragma warning(push)
  #pragma warning(disable:4275)
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class OgreHeightmapPrivate;
 
     /// \brief Ogre implementation of a heightmap geometry.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreHeightmap
+    class GZ_RENDERING_OGRE_VISIBLE OgreHeightmap
       : public BaseHeightmap<OgreGeometry>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreInertiaVisual.hh b/ogre/include/gz/rendering/ogre/OgreInertiaVisual.hh
index 770df2c8a..accd45c62 100644
--- a/ogre/include/gz/rendering/ogre/OgreInertiaVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreInertiaVisual.hh
@@ -30,16 +30,16 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     // Forward declaration
     class OgreInertiaVisualPrivate;
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreInertiaVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreInertiaVisual :
       public BaseInertiaVisual<OgreVisual>
     {
       /// \brief Constructor
@@ -60,8 +60,8 @@ namespace ignition
       /// \brief Load the Inertia visual from its pose and scale
       /// \param[in] _pose Pose of the Inertia visual
       /// \param[in] _scale Scale factor of the box visual
-      public: void Load(const ignition::math::Pose3d &_pose,
-          const ignition::math::Vector3d &_scale) override;
+      public: void Load(const gz::math::Pose3d &_pose,
+          const gz::math::Vector3d &_scale) override;
 
       /// \brief Get the box visual
       /// \return Pointer to the box visual
diff --git a/ogre/include/gz/rendering/ogre/OgreJointVisual.hh b/ogre/include/gz/rendering/ogre/OgreJointVisual.hh
index 567e6869e..a33bda633 100644
--- a/ogre/include/gz/rendering/ogre/OgreJointVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreJointVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseJointVisual.hh"
 #include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreJointVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreJointVisual :
       public BaseJointVisual<OgreVisual>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreLidarVisual.hh b/ogre/include/gz/rendering/ogre/OgreLidarVisual.hh
index 24b616120..dd53a36ac 100644
--- a/ogre/include/gz/rendering/ogre/OgreLidarVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreLidarVisual.hh
@@ -25,17 +25,17 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 #include "gz/rendering/ogre/OgreScene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class OgreLidarVisualPrivate;
 
     /// \brief Ogre implementation of a Lidar Visual.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreLidarVisual
+    class GZ_RENDERING_OGRE_VISIBLE OgreLidarVisual
       : public BaseLidarVisual<OgreVisual>
     {
       /// \brief Constructor
@@ -63,7 +63,7 @@ namespace ignition
       // Documentation inherited
       // This only affects lidar visuals with type LVT_POINTS
       public: virtual void SetPoints(const std::vector<double> &_points,
-                        const std::vector<ignition::math::Color> &_colors)
+                        const std::vector<gz::math::Color> &_colors)
                                     override;
 
       // Documentation inherited
diff --git a/ogre/include/gz/rendering/ogre/OgreLight.hh b/ogre/include/gz/rendering/ogre/OgreLight.hh
index 0274f9139..51ee3df38 100644
--- a/ogre/include/gz/rendering/ogre/OgreLight.hh
+++ b/ogre/include/gz/rendering/ogre/OgreLight.hh
@@ -26,13 +26,13 @@ namespace Ogre
   class Light;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreLight :
+    class GZ_RENDERING_OGRE_VISIBLE OgreLight :
       public BaseLight<OgreNode>
     {
       protected: OgreLight();
@@ -97,7 +97,7 @@ namespace ignition
       protected: Ogre::Light::LightTypes ogreLightType;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreDirectionalLight :
+    class GZ_RENDERING_OGRE_VISIBLE OgreDirectionalLight :
       public BaseDirectionalLight<OgreLight>
     {
       protected: OgreDirectionalLight();
@@ -111,7 +111,7 @@ namespace ignition
       private: friend class OgreScene;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgrePointLight :
+    class GZ_RENDERING_OGRE_VISIBLE OgrePointLight :
       public BasePointLight<OgreLight>
     {
       protected: OgrePointLight();
@@ -121,7 +121,7 @@ namespace ignition
       private: friend class OgreScene;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreSpotLight :
+    class GZ_RENDERING_OGRE_VISIBLE OgreSpotLight :
       public BaseSpotLight<OgreLight>
     {
       protected: OgreSpotLight();
diff --git a/ogre/include/gz/rendering/ogre/OgreLightVisual.hh b/ogre/include/gz/rendering/ogre/OgreLightVisual.hh
index 9a6305e3d..f37867225 100644
--- a/ogre/include/gz/rendering/ogre/OgreLightVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreLightVisual.hh
@@ -30,16 +30,16 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     // Forward declaration
     class OgreLightVisualPrivate;
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreLightVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreLightVisual :
       public BaseLightVisual<OgreVisual>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreMarker.hh b/ogre/include/gz/rendering/ogre/OgreMarker.hh
index 14dba9757..b1d798f6c 100644
--- a/ogre/include/gz/rendering/ogre/OgreMarker.hh
+++ b/ogre/include/gz/rendering/ogre/OgreMarker.hh
@@ -23,17 +23,17 @@
 #include "gz/rendering/ogre/OgreGeometry.hh"
 #include "gz/rendering/ogre/OgreIncludes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class OgreMarkerPrivate;
 
     /// \brief Ogre implementation of a marker geometry.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreMarker
+    class GZ_RENDERING_OGRE_VISIBLE OgreMarker
       : public BaseMarker<OgreGeometry>
     {
       /// \brief Constructor
@@ -63,11 +63,11 @@ namespace ignition
 
       // Documentation inherited
       public: virtual void SetPoint(unsigned int _index,
-                           const ignition::math::Vector3d &_value) override;
+                           const gz::math::Vector3d &_value) override;
 
       // Documentation inherited
-      public: virtual void AddPoint(const ignition::math::Vector3d &_pt,
-                           const ignition::math::Color &_color) override;
+      public: virtual void AddPoint(const gz::math::Vector3d &_pt,
+                           const gz::math::Color &_color) override;
 
       // Documentation inherited
       public: virtual void ClearPoints() override;
diff --git a/ogre/include/gz/rendering/ogre/OgreMaterial.hh b/ogre/include/gz/rendering/ogre/OgreMaterial.hh
index 9627c456f..199c0cb3d 100644
--- a/ogre/include/gz/rendering/ogre/OgreMaterial.hh
+++ b/ogre/include/gz/rendering/ogre/OgreMaterial.hh
@@ -25,18 +25,18 @@
 #include "gz/rendering/ogre/OgreObject.hh"
 #include "gz/rendering/ogre/OgreIncludes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     // TODO(anyone): use a better way to find shader configurations
     const std::string depth_vertex_shader_file =
       "depth_vertex_shader.glsl";
     const std::string depth_fragment_shader_file =
       "depth_fragment_shader.glsl";
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreMaterial :
+    class GZ_RENDERING_OGRE_VISIBLE OgreMaterial :
       public BaseMaterial<OgreObject>
     {
       protected: OgreMaterial();
diff --git a/ogre/include/gz/rendering/ogre/OgreMaterialSwitcher.hh b/ogre/include/gz/rendering/ogre/OgreMaterialSwitcher.hh
index 1498adc22..64d011e5f 100644
--- a/ogre/include/gz/rendering/ogre/OgreMaterialSwitcher.hh
+++ b/ogre/include/gz/rendering/ogre/OgreMaterialSwitcher.hh
@@ -28,17 +28,17 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 #include "gz/rendering/ogre/OgreRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations
     class OgreSelectionBuffer;
 
     /// \brief Helper class to assign unique colors to renderables
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreMaterialSwitcher :
+    class GZ_RENDERING_OGRE_VISIBLE OgreMaterialSwitcher :
 // Ogre::MaterialManager::Listener isn't a dll-interface class, this may cause
 // issues
 #ifdef _MSC_VER
@@ -60,7 +60,7 @@ namespace ignition
       /// \brief Get the entity with a specific color
       /// \param[in] _color The entity's color.
       public: std::string EntityName(
-              const ignition::math::Color &_color) const;
+              const gz::math::Color &_color) const;
 
       /// \brief Reset the color value incrementor
       public: void Reset();
@@ -93,7 +93,7 @@ namespace ignition
                   const Ogre::RenderTargetEvent &_evt);
 
       /// \brief Current unique color value
-      private: ignition::math::Color currentColor;
+      private: gz::math::Color currentColor;
 
       /// \brief last entity assigned an unique color value
       private: std::string lastEntity;
diff --git a/ogre/include/gz/rendering/ogre/OgreMesh.hh b/ogre/include/gz/rendering/ogre/OgreMesh.hh
index c2328bca8..c1b262e42 100644
--- a/ogre/include/gz/rendering/ogre/OgreMesh.hh
+++ b/ogre/include/gz/rendering/ogre/OgreMesh.hh
@@ -33,16 +33,16 @@ namespace Ogre
   class SubEntity;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations
     class OgreMeshPrivate;
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreMesh :
+    class GZ_RENDERING_OGRE_VISIBLE OgreMesh :
       public BaseMesh<OgreGeometry>
     {
       typedef std::vector<std::string> NameList;
@@ -101,7 +101,7 @@ namespace ignition
       private: std::unique_ptr<OgreMeshPrivate> dataPtr;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreSubMesh :
+    class GZ_RENDERING_OGRE_VISIBLE OgreSubMesh :
       public BaseSubMesh<OgreObject>
     {
       protected: OgreSubMesh();
diff --git a/ogre/include/gz/rendering/ogre/OgreMeshFactory.hh b/ogre/include/gz/rendering/ogre/OgreMeshFactory.hh
index 92eb9f041..9a62da97b 100644
--- a/ogre/include/gz/rendering/ogre/OgreMeshFactory.hh
+++ b/ogre/include/gz/rendering/ogre/OgreMeshFactory.hh
@@ -29,13 +29,13 @@ namespace Ogre
   class Entity;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreMeshFactory
+    class GZ_RENDERING_OGRE_VISIBLE OgreMeshFactory
     {
       public: explicit OgreMeshFactory(OgreScenePtr _scene);
 
@@ -67,7 +67,7 @@ namespace ignition
       protected: std::vector<MaterialPtr> materialCache;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreSubMeshStoreFactory
+    class GZ_RENDERING_OGRE_VISIBLE OgreSubMeshStoreFactory
     {
       typedef std::vector<std::string> NameList;
 
diff --git a/ogre/include/gz/rendering/ogre/OgreNode.hh b/ogre/include/gz/rendering/ogre/OgreNode.hh
index 558086e89..d780b1593 100644
--- a/ogre/include/gz/rendering/ogre/OgreNode.hh
+++ b/ogre/include/gz/rendering/ogre/OgreNode.hh
@@ -28,13 +28,13 @@ namespace Ogre
   class SceneNode;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreNode :
+    class GZ_RENDERING_OGRE_VISIBLE OgreNode :
       public BaseNode<OgreObject>
     {
       protected: OgreNode();
diff --git a/ogre/include/gz/rendering/ogre/OgreObject.hh b/ogre/include/gz/rendering/ogre/OgreObject.hh
index b2414e848..0005cb912 100644
--- a/ogre/include/gz/rendering/ogre/OgreObject.hh
+++ b/ogre/include/gz/rendering/ogre/OgreObject.hh
@@ -23,13 +23,13 @@
 #include "gz/rendering/ogre/OgreRenderTypes.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreObject :
+    class GZ_RENDERING_OGRE_VISIBLE OgreObject :
       public BaseObject
     {
       protected: OgreObject();
diff --git a/ogre/include/gz/rendering/ogre/OgreObjectInterface.hh b/ogre/include/gz/rendering/ogre/OgreObjectInterface.hh
index a51720d02..49397ddb5 100644
--- a/ogre/include/gz/rendering/ogre/OgreObjectInterface.hh
+++ b/ogre/include/gz/rendering/ogre/OgreObjectInterface.hh
@@ -21,14 +21,14 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     /// \brief Mixin class to provide direct access to Ogre objects.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreObjectInterface
+    class GZ_RENDERING_OGRE_VISIBLE OgreObjectInterface
     {
       public: virtual ~OgreObjectInterface();
 
diff --git a/ogre/include/gz/rendering/ogre/OgreParticleEmitter.hh b/ogre/include/gz/rendering/ogre/OgreParticleEmitter.hh
index bb42768a4..a29f05f71 100644
--- a/ogre/include/gz/rendering/ogre/OgreParticleEmitter.hh
+++ b/ogre/include/gz/rendering/ogre/OgreParticleEmitter.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseParticleEmitter.hh"
 #include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     /// \brief Class to manage a particle emitter.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreParticleEmitter :
+    class GZ_RENDERING_OGRE_VISIBLE OgreParticleEmitter :
       public BaseParticleEmitter<OgreVisual>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreRTShaderSystem.hh b/ogre/include/gz/rendering/ogre/OgreRTShaderSystem.hh
index 1e4d1611b..2bcfd3280 100644
--- a/ogre/include/gz/rendering/ogre/OgreRTShaderSystem.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRTShaderSystem.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/ogre/OgreRenderTypes.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreRTShaderSystemPrivate;
@@ -42,7 +42,7 @@ namespace ignition
     ///
     /// This class allows Gazebo to generate per-pixel shaders for every
     /// material at run-time.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRTShaderSystem :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRTShaderSystem :
       public common::SingletonT<OgreRTShaderSystem>
     {
       /// \enum LightingModel
diff --git a/ogre/include/gz/rendering/ogre/OgreRayQuery.hh b/ogre/include/gz/rendering/ogre/OgreRayQuery.hh
index df9b9cedf..113eb2a82 100644
--- a/ogre/include/gz/rendering/ogre/OgreRayQuery.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRayQuery.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/ogre/OgreObject.hh"
 #include "gz/rendering/ogre/OgreRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreRayQueryPrivate;
@@ -36,7 +36,7 @@ namespace ignition
     /// \class OgreRayQuery OgreRayQuery.hh
     /// gz/rendering/base/OgreRayQuery.hh
     /// \brief A Ray Query class used for computing ray object intersections
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRayQuery :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRayQuery :
         public BaseRayQuery<OgreObject>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreRenderEngine.hh b/ogre/include/gz/rendering/ogre/OgreRenderEngine.hh
index efcf0e225..978deddd3 100644
--- a/ogre/include/gz/rendering/ogre/OgreRenderEngine.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRenderEngine.hh
@@ -37,17 +37,17 @@ namespace Ogre
   class Root;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreRenderEnginePrivate;
 
     /// \brief Plugin for loading ogre render engine
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRenderEnginePlugin :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRenderEnginePlugin :
       public RenderEnginePlugin
     {
       /// \brief Constructor
@@ -65,7 +65,7 @@ namespace ignition
       public: RenderEngine *Engine() const;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRenderEngine :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRenderEngine :
       public virtual BaseRenderEngine,
       public common::SingletonT<OgreRenderEngine>
     {
diff --git a/ogre/include/gz/rendering/ogre/OgreRenderPass.hh b/ogre/include/gz/rendering/ogre/OgreRenderPass.hh
index 8dbe49d0d..c5c3ae645 100644
--- a/ogre/include/gz/rendering/ogre/OgreRenderPass.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRenderPass.hh
@@ -22,17 +22,17 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 #include "gz/rendering/ogre/OgreObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /* \class OgreRenderPass OgreRenderPass.hh \
      * gz/rendering/ogre/OgreRenderPass.hh
      */
     /// \brief Ogre implementation of the RenderPass class
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRenderPass :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRenderPass :
       public BaseRenderPass<OgreObject>
     {
       /// \brief Constructor
diff --git a/ogre/include/gz/rendering/ogre/OgreRenderTarget.hh b/ogre/include/gz/rendering/ogre/OgreRenderTarget.hh
index cbda9cc91..e94581fd0 100644
--- a/ogre/include/gz/rendering/ogre/OgreRenderTarget.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRenderTarget.hh
@@ -33,13 +33,13 @@ namespace Ogre
   class Texture;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRenderTarget :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRenderTarget :
       public virtual BaseRenderTarget<OgreObject>
     {
       protected: OgreRenderTarget();
@@ -128,7 +128,7 @@ namespace ignition
       protected: uint32_t visibilityMask = IGN_VISIBILITY_ALL;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRenderTexture :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRenderTexture :
       public virtual BaseRenderTexture<OgreRenderTarget>
     {
       protected: OgreRenderTexture();
@@ -161,7 +161,7 @@ namespace ignition
       private: friend class OgreScene;
     };
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreRenderWindow :
+    class GZ_RENDERING_OGRE_VISIBLE OgreRenderWindow :
       public virtual BaseRenderWindow<OgreRenderTarget>
     {
       protected: OgreRenderWindow();
diff --git a/ogre/include/gz/rendering/ogre/OgreRenderTargetMaterial.hh b/ogre/include/gz/rendering/ogre/OgreRenderTargetMaterial.hh
index 627709d86..4b2c803fb 100644
--- a/ogre/include/gz/rendering/ogre/OgreRenderTargetMaterial.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRenderTargetMaterial.hh
@@ -31,11 +31,11 @@
   #pragma warning(disable:4275)
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Causes all objects in a scene to be rendered with the same
     /// material when rendered by a given RenderTarget.
@@ -49,7 +49,7 @@ namespace ignition
     /// Every time ogre tries to get a technique for a material it will call
     /// handleSchemeNotFound which returns the first supported technique on the
     /// material provided to this class's constructor.
-    class IGNITION_RENDERING_OGRE_VISIBLE  OgreRenderTargetMaterial :
+    class GZ_RENDERING_OGRE_VISIBLE  OgreRenderTargetMaterial :
       public Ogre::RenderTargetListener,
       public Ogre::MaterialManager::Listener
     {
diff --git a/ogre/include/gz/rendering/ogre/OgreRenderTypes.hh b/ogre/include/gz/rendering/ogre/OgreRenderTypes.hh
index 752477af0..9f9005b6c 100644
--- a/ogre/include/gz/rendering/ogre/OgreRenderTypes.hh
+++ b/ogre/include/gz/rendering/ogre/OgreRenderTypes.hh
@@ -20,11 +20,11 @@
 #include <memory>
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class OgreArrowVisual;
     class OgreAxisVisual;
diff --git a/ogre/include/gz/rendering/ogre/OgreScene.hh b/ogre/include/gz/rendering/ogre/OgreScene.hh
index 2bcb93f56..cdd9e9ed5 100644
--- a/ogre/include/gz/rendering/ogre/OgreScene.hh
+++ b/ogre/include/gz/rendering/ogre/OgreScene.hh
@@ -30,13 +30,13 @@ namespace Ogre
   class SceneManager;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreScene :
+    class GZ_RENDERING_OGRE_VISIBLE OgreScene :
       public BaseScene
     {
       protected: OgreScene(unsigned int _id, const std::string &_name);
diff --git a/ogre/include/gz/rendering/ogre/OgreSelectionBuffer.hh b/ogre/include/gz/rendering/ogre/OgreSelectionBuffer.hh
index 3a6932018..6bceb7d94 100644
--- a/ogre/include/gz/rendering/ogre/OgreSelectionBuffer.hh
+++ b/ogre/include/gz/rendering/ogre/OgreSelectionBuffer.hh
@@ -30,11 +30,11 @@ namespace Ogre
   class SceneManager;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreSelectionBufferPrivate;
@@ -44,7 +44,7 @@ namespace ignition
     /// color is assigned to each entity. Whenever a selection request is made,
     /// the selection buffer camera renders to a 1x1 sized offscreen buffer.
     /// The color value of that pixel gives the identity of the entity.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreSelectionBuffer
+    class GZ_RENDERING_OGRE_VISIBLE OgreSelectionBuffer
     {
       /// \brief Constructor
       /// \param[in] _cameraName Name of the camera to generate a selection
diff --git a/ogre/include/gz/rendering/ogre/OgreSensor.hh b/ogre/include/gz/rendering/ogre/OgreSensor.hh
index af5643099..e3238f102 100644
--- a/ogre/include/gz/rendering/ogre/OgreSensor.hh
+++ b/ogre/include/gz/rendering/ogre/OgreSensor.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseSensor.hh"
 #include "gz/rendering/ogre/OgreNode.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreSensor :
+    class GZ_RENDERING_OGRE_VISIBLE OgreSensor :
       public BaseSensor<OgreNode>
     {
       protected: OgreSensor();
diff --git a/ogre/include/gz/rendering/ogre/OgreStorage.hh b/ogre/include/gz/rendering/ogre/OgreStorage.hh
index 50db5882b..fa2b3b92e 100644
--- a/ogre/include/gz/rendering/ogre/OgreStorage.hh
+++ b/ogre/include/gz/rendering/ogre/OgreStorage.hh
@@ -29,15 +29,15 @@
 #include "gz/rendering/ogre/OgreSensor.hh"
 #include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
 // armhf failed to build with this code. It can not be removed for the rest
 // of arches to keep ABI but should be removed in major versions unreleased
-// see https://github.com/ignitionrobotics/ign-rendering/pull/457
+// see https://github.com/gazebosim/gz-rendering/pull/457
 #ifndef __ARM_PCS_VFP
     template class BaseSceneStore<OgreScene>;
     template class BaseNodeStore<OgreNode>;
diff --git a/ogre/include/gz/rendering/ogre/OgreText.hh b/ogre/include/gz/rendering/ogre/OgreText.hh
index 7b8cab572..a14a9e125 100644
--- a/ogre/include/gz/rendering/ogre/OgreText.hh
+++ b/ogre/include/gz/rendering/ogre/OgreText.hh
@@ -29,17 +29,17 @@
 #include "gz/rendering/ogre/OgreIncludes.hh"
 #include "gz/rendering/ogre/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class OgreMovableText;
     class OgreTextPrivate;
 
     /// \brief Ogre implementation of text geometry
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreText
+    class GZ_RENDERING_OGRE_VISIBLE OgreText
         : public BaseText<OgreGeometry>
     {
       /// \brief Constructor
@@ -71,7 +71,7 @@ namespace ignition
       public: virtual void SetTextString(const std::string &_text) override;
 
       // Documentation inherited.
-      public: virtual void SetColor(const ignition::math::Color &_color)
+      public: virtual void SetColor(const gz::math::Color &_color)
           override;
 
       // Documentation inherited.
@@ -91,7 +91,7 @@ namespace ignition
       public: virtual void SetShowOnTop(const bool _onTop) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox AABB() const override;
+      public: virtual gz::math::AxisAlignedBox AABB() const override;
 
       /// \brief Set material to text geometry.
       /// \param[in] _material Ogre material.
diff --git a/ogre/include/gz/rendering/ogre/OgreThermalCamera.hh b/ogre/include/gz/rendering/ogre/OgreThermalCamera.hh
index 54fd1987e..e10eb70d7 100644
--- a/ogre/include/gz/rendering/ogre/OgreThermalCamera.hh
+++ b/ogre/include/gz/rendering/ogre/OgreThermalCamera.hh
@@ -48,11 +48,11 @@ namespace Ogre
   class Camera;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreThermalCameraPrivate;
@@ -61,7 +61,7 @@ namespace ignition
      * rendering/ogre/OgreThermalCamera.hh
     **/
     /// \brief Depth camera used to render thermal data into an image buffer
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreThermalCamera :
+    class GZ_RENDERING_OGRE_VISIBLE OgreThermalCamera :
       public virtual BaseThermalCamera<OgreSensor>,
       public virtual OgreObjectInterface
     {
@@ -83,7 +83,7 @@ namespace ignition
       /// \brief Connect to the new thermal image signal
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewThermalFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewThermalFrame(
           std::function<void(const uint16_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
diff --git a/ogre/include/gz/rendering/ogre/OgreVisual.hh b/ogre/include/gz/rendering/ogre/OgreVisual.hh
index c07fffe52..71c58e491 100644
--- a/ogre/include/gz/rendering/ogre/OgreVisual.hh
+++ b/ogre/include/gz/rendering/ogre/OgreVisual.hh
@@ -24,16 +24,16 @@
 #include "gz/rendering/ogre/OgreNode.hh"
 #include "gz/rendering/ogre/OgreRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class OgreVisualPrivate;
 
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreVisual :
+    class GZ_RENDERING_OGRE_VISIBLE OgreVisual :
       public BaseVisual<OgreNode>
     {
       protected: OgreVisual();
@@ -53,11 +53,11 @@ namespace ignition
       public: virtual void SetVisibilityFlags(uint32_t _flags) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox LocalBoundingBox()
+      public: virtual gz::math::AxisAlignedBox LocalBoundingBox()
               const override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox BoundingBox()
+      public: virtual gz::math::AxisAlignedBox BoundingBox()
               const override;
 
       /// \brief Recursively loop through this visual's children
@@ -67,8 +67,8 @@ namespace ignition
       /// be calculated.
       /// \param[in] _pose World pose of the visual.
       private: virtual void BoundsHelper(
-                     ignition::math::AxisAlignedBox &_box, bool _local,
-                     const ignition::math::Pose3d &_pose) const;
+                     gz::math::AxisAlignedBox &_box, bool _local,
+                     const gz::math::Pose3d &_pose) const;
 
       /// \brief Wrapper function for BoundsHelper to reduce redundant
       /// world pose access
@@ -76,7 +76,7 @@ namespace ignition
       /// \param[in] _local A flag indicating if the local bounding box is to
       /// be calculated.
       private: virtual void BoundsHelper(
-                     ignition::math::AxisAlignedBox &_box, bool _local) const;
+                     gz::math::AxisAlignedBox &_box, bool _local) const;
 
       protected: virtual GeometryStorePtr Geometries() const override;
 
diff --git a/ogre/include/gz/rendering/ogre/OgreWideAngleCamera.hh b/ogre/include/gz/rendering/ogre/OgreWideAngleCamera.hh
index 587f7a55e..8db96dd60 100644
--- a/ogre/include/gz/rendering/ogre/OgreWideAngleCamera.hh
+++ b/ogre/include/gz/rendering/ogre/OgreWideAngleCamera.hh
@@ -36,14 +36,14 @@ namespace Ogre
   class Viewport;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre implementation of WideAngleCamera
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreWideAngleCamera :
+    class GZ_RENDERING_OGRE_VISIBLE OgreWideAngleCamera :
         public BaseWideAngleCamera<OgreSensor>,
         protected Ogre::CompositorInstance::Listener
     {
diff --git a/ogre/include/gz/rendering/ogre/OgreWireBox.hh b/ogre/include/gz/rendering/ogre/OgreWireBox.hh
index 1284a3ffd..e975a44d1 100644
--- a/ogre/include/gz/rendering/ogre/OgreWireBox.hh
+++ b/ogre/include/gz/rendering/ogre/OgreWireBox.hh
@@ -28,17 +28,17 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class OgreWireBoxPrivate;
 
     /// \brief Ogre implementation of a wire box geometry.
-    class IGNITION_RENDERING_OGRE_VISIBLE OgreWireBox
+    class GZ_RENDERING_OGRE_VISIBLE OgreWireBox
       : public BaseWireBox<OgreGeometry>
     {
       /// \brief Constructor
diff --git a/ogre/include/ignition/rendering/ogre.hh b/ogre/include/ignition/rendering/ogre.hh
index 78f899898..4e6486152 100644
--- a/ogre/include/ignition/rendering/ogre.hh
+++ b/ogre/include/ignition/rendering/ogre.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/Export.hh b/ogre/include/ignition/rendering/ogre/Export.hh
index 1a647d09e..e47fd1851 100644
--- a/ogre/include/ignition/rendering/ogre/Export.hh
+++ b/ogre/include/ignition/rendering/ogre/Export.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/Export.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreArrowVisual.hh b/ogre/include/ignition/rendering/ogre/OgreArrowVisual.hh
index 1619d9cc9..842651249 100644
--- a/ogre/include/ignition/rendering/ogre/OgreArrowVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreArrowVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreArrowVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreAxisVisual.hh b/ogre/include/ignition/rendering/ogre/OgreAxisVisual.hh
index 5707a56be..7d17bf355 100644
--- a/ogre/include/ignition/rendering/ogre/OgreAxisVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreAxisVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreAxisVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreCOMVisual.hh b/ogre/include/ignition/rendering/ogre/OgreCOMVisual.hh
index 6c23e809c..aa885b8f3 100644
--- a/ogre/include/ignition/rendering/ogre/OgreCOMVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreCOMVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreCOMVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreCamera.hh b/ogre/include/ignition/rendering/ogre/OgreCamera.hh
index fecaf460d..3ec22b6ec 100644
--- a/ogre/include/ignition/rendering/ogre/OgreCamera.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreCapsule.hh b/ogre/include/ignition/rendering/ogre/OgreCapsule.hh
index 2877db0ab..f92315852 100644
--- a/ogre/include/ignition/rendering/ogre/OgreCapsule.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreCapsule.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreCapsule.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreConversions.hh b/ogre/include/ignition/rendering/ogre/OgreConversions.hh
index b5ee364b1..323112c5e 100644
--- a/ogre/include/ignition/rendering/ogre/OgreConversions.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreConversions.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreConversions.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreDepthCamera.hh b/ogre/include/ignition/rendering/ogre/OgreDepthCamera.hh
index 7d5567a68..fecb3ba5b 100644
--- a/ogre/include/ignition/rendering/ogre/OgreDepthCamera.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreDepthCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreDepthCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreDistortionPass.hh b/ogre/include/ignition/rendering/ogre/OgreDistortionPass.hh
index ba878e3d5..b9f780c38 100644
--- a/ogre/include/ignition/rendering/ogre/OgreDistortionPass.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreDistortionPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreDistortionPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreDynamicLines.hh b/ogre/include/ignition/rendering/ogre/OgreDynamicLines.hh
index 3618af370..68dc0ede6 100644
--- a/ogre/include/ignition/rendering/ogre/OgreDynamicLines.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreDynamicLines.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreDynamicLines.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreDynamicRenderable.hh b/ogre/include/ignition/rendering/ogre/OgreDynamicRenderable.hh
index 1cfce8577..6dd37e36b 100644
--- a/ogre/include/ignition/rendering/ogre/OgreDynamicRenderable.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreDynamicRenderable.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreDynamicRenderable.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreGaussianNoisePass.hh b/ogre/include/ignition/rendering/ogre/OgreGaussianNoisePass.hh
index 6135ccab3..6091cab11 100644
--- a/ogre/include/ignition/rendering/ogre/OgreGaussianNoisePass.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreGaussianNoisePass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreGaussianNoisePass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreGeometry.hh b/ogre/include/ignition/rendering/ogre/OgreGeometry.hh
index a231efee5..cbfc5a354 100644
--- a/ogre/include/ignition/rendering/ogre/OgreGeometry.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreGeometry.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreGeometry.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreGizmoVisual.hh b/ogre/include/ignition/rendering/ogre/OgreGizmoVisual.hh
index 153b629ae..fdbd85675 100644
--- a/ogre/include/ignition/rendering/ogre/OgreGizmoVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreGizmoVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreGizmoVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreGpuRays.hh b/ogre/include/ignition/rendering/ogre/OgreGpuRays.hh
index f54805b0b..ef3beb8a0 100644
--- a/ogre/include/ignition/rendering/ogre/OgreGpuRays.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreGpuRays.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreGpuRays.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreGrid.hh b/ogre/include/ignition/rendering/ogre/OgreGrid.hh
index f3e57c229..a8c5c889a 100644
--- a/ogre/include/ignition/rendering/ogre/OgreGrid.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreGrid.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreGrid.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreHeightmap.hh b/ogre/include/ignition/rendering/ogre/OgreHeightmap.hh
index fdcf89dc5..2ff58d541 100644
--- a/ogre/include/ignition/rendering/ogre/OgreHeightmap.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreHeightmap.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreHeightmap.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreIncludes.hh b/ogre/include/ignition/rendering/ogre/OgreIncludes.hh
index 7095c4513..1d8d37a02 100644
--- a/ogre/include/ignition/rendering/ogre/OgreIncludes.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreIncludes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreIncludes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreInertiaVisual.hh b/ogre/include/ignition/rendering/ogre/OgreInertiaVisual.hh
index 495a3948e..834893282 100644
--- a/ogre/include/ignition/rendering/ogre/OgreInertiaVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreInertiaVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreInertiaVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreJointVisual.hh b/ogre/include/ignition/rendering/ogre/OgreJointVisual.hh
index d2483b8ae..92195c245 100644
--- a/ogre/include/ignition/rendering/ogre/OgreJointVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreJointVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreJointVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreLidarVisual.hh b/ogre/include/ignition/rendering/ogre/OgreLidarVisual.hh
index 82fbbc2a9..5e6b6521d 100644
--- a/ogre/include/ignition/rendering/ogre/OgreLidarVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreLidarVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreLidarVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreLight.hh b/ogre/include/ignition/rendering/ogre/OgreLight.hh
index dfee3cfbb..a70fb1363 100644
--- a/ogre/include/ignition/rendering/ogre/OgreLight.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreLight.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreLight.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreLightVisual.hh b/ogre/include/ignition/rendering/ogre/OgreLightVisual.hh
index 11d1064bc..42575592e 100644
--- a/ogre/include/ignition/rendering/ogre/OgreLightVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreLightVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreLightVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreMarker.hh b/ogre/include/ignition/rendering/ogre/OgreMarker.hh
index 028d98a61..65d68d7a7 100644
--- a/ogre/include/ignition/rendering/ogre/OgreMarker.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreMarker.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreMarker.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreMaterial.hh b/ogre/include/ignition/rendering/ogre/OgreMaterial.hh
index 2444134e7..71c391cf4 100644
--- a/ogre/include/ignition/rendering/ogre/OgreMaterial.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreMaterial.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreMaterial.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreMaterialSwitcher.hh b/ogre/include/ignition/rendering/ogre/OgreMaterialSwitcher.hh
index 2188b81c5..1a48a91e3 100644
--- a/ogre/include/ignition/rendering/ogre/OgreMaterialSwitcher.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreMaterialSwitcher.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreMaterialSwitcher.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreMesh.hh b/ogre/include/ignition/rendering/ogre/OgreMesh.hh
index ed9895aad..f4f319524 100644
--- a/ogre/include/ignition/rendering/ogre/OgreMesh.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreMesh.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreMesh.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreMeshFactory.hh b/ogre/include/ignition/rendering/ogre/OgreMeshFactory.hh
index 3c5c4d516..c0c941734 100644
--- a/ogre/include/ignition/rendering/ogre/OgreMeshFactory.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreMeshFactory.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreMeshFactory.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreNode.hh b/ogre/include/ignition/rendering/ogre/OgreNode.hh
index d9ae86fae..dd6c717a6 100644
--- a/ogre/include/ignition/rendering/ogre/OgreNode.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreNode.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreNode.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreObject.hh b/ogre/include/ignition/rendering/ogre/OgreObject.hh
index c31c16db0..9befac037 100644
--- a/ogre/include/ignition/rendering/ogre/OgreObject.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreObject.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreObject.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreObjectInterface.hh b/ogre/include/ignition/rendering/ogre/OgreObjectInterface.hh
index bcee4cf37..6e0917abb 100644
--- a/ogre/include/ignition/rendering/ogre/OgreObjectInterface.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreObjectInterface.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreObjectInterface.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreParticleEmitter.hh b/ogre/include/ignition/rendering/ogre/OgreParticleEmitter.hh
index 3ed883106..781f80810 100644
--- a/ogre/include/ignition/rendering/ogre/OgreParticleEmitter.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreParticleEmitter.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreParticleEmitter.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRTShaderSystem.hh b/ogre/include/ignition/rendering/ogre/OgreRTShaderSystem.hh
index f393a4c88..7296a4e54 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRTShaderSystem.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRTShaderSystem.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRTShaderSystem.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRayQuery.hh b/ogre/include/ignition/rendering/ogre/OgreRayQuery.hh
index 379e63c50..7ec752549 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRayQuery.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRayQuery.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRayQuery.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRenderEngine.hh b/ogre/include/ignition/rendering/ogre/OgreRenderEngine.hh
index 2b06a12d7..08d597cb0 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRenderEngine.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRenderEngine.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRenderEngine.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRenderPass.hh b/ogre/include/ignition/rendering/ogre/OgreRenderPass.hh
index c46b24099..c48e101ea 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRenderPass.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRenderPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRenderPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRenderTarget.hh b/ogre/include/ignition/rendering/ogre/OgreRenderTarget.hh
index 60ade6617..79aac88d5 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRenderTarget.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRenderTarget.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRenderTarget.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRenderTargetMaterial.hh b/ogre/include/ignition/rendering/ogre/OgreRenderTargetMaterial.hh
index 86cc0b45f..ec66361c2 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRenderTargetMaterial.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRenderTargetMaterial.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRenderTargetMaterial.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreRenderTypes.hh b/ogre/include/ignition/rendering/ogre/OgreRenderTypes.hh
index f7ca3e945..b864d59e6 100644
--- a/ogre/include/ignition/rendering/ogre/OgreRenderTypes.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreRenderTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreRenderTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreScene.hh b/ogre/include/ignition/rendering/ogre/OgreScene.hh
index 65747dc95..2d59f7ad8 100644
--- a/ogre/include/ignition/rendering/ogre/OgreScene.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreScene.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreScene.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreSelectionBuffer.hh b/ogre/include/ignition/rendering/ogre/OgreSelectionBuffer.hh
index b9278840f..57fb384fe 100644
--- a/ogre/include/ignition/rendering/ogre/OgreSelectionBuffer.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreSelectionBuffer.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreSelectionBuffer.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreSensor.hh b/ogre/include/ignition/rendering/ogre/OgreSensor.hh
index 61099c554..01c45a674 100644
--- a/ogre/include/ignition/rendering/ogre/OgreSensor.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreSensor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreSensor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreStorage.hh b/ogre/include/ignition/rendering/ogre/OgreStorage.hh
index 5fde14130..791887621 100644
--- a/ogre/include/ignition/rendering/ogre/OgreStorage.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreStorage.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreStorage.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreText.hh b/ogre/include/ignition/rendering/ogre/OgreText.hh
index 5b888733f..8ed59eaf8 100644
--- a/ogre/include/ignition/rendering/ogre/OgreText.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreText.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreText.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreThermalCamera.hh b/ogre/include/ignition/rendering/ogre/OgreThermalCamera.hh
index b7c23df05..d31f9fd7a 100644
--- a/ogre/include/ignition/rendering/ogre/OgreThermalCamera.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreThermalCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreThermalCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreVisual.hh b/ogre/include/ignition/rendering/ogre/OgreVisual.hh
index 900d43f7b..6e7a288df 100644
--- a/ogre/include/ignition/rendering/ogre/OgreVisual.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreWideAngleCamera.hh b/ogre/include/ignition/rendering/ogre/OgreWideAngleCamera.hh
index 7f41505dc..31d7eddcc 100644
--- a/ogre/include/ignition/rendering/ogre/OgreWideAngleCamera.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreWideAngleCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreWideAngleCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/include/ignition/rendering/ogre/OgreWireBox.hh b/ogre/include/ignition/rendering/ogre/OgreWireBox.hh
index 7bbba0ba8..637b89c0e 100644
--- a/ogre/include/ignition/rendering/ogre/OgreWireBox.hh
+++ b/ogre/include/ignition/rendering/ogre/OgreWireBox.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre/OgreWireBox.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre/src/CMakeLists.txt b/ogre/src/CMakeLists.txt
index 2ea299b35..877586865 100644
--- a/ogre/src/CMakeLists.txt
+++ b/ogre/src/CMakeLists.txt
@@ -27,7 +27,7 @@ find_package(OpenGL)
 set_property(
   SOURCE OgreRenderEngine.cc OgreRTShaderSystem.cc OgreGpuRays.cc OgreMaterial.cc OgreDepthCamera.cc OgreThermalCamera.cc
   PROPERTY COMPILE_DEFINITIONS
-  IGN_RENDERING_RESOURCE_PATH="${IGN_RENDERING_RESOURCE_PATH}"
+  GZ_RENDERING_RESOURCE_PATH="${GZ_RENDERING_RESOURCE_PATH}"
   OGRE_RESOURCE_PATH="${OGRE_RESOURCE_PATH}"
 )
 
@@ -44,7 +44,7 @@ target_link_libraries(${ogre_target}
 ign_build_tests(TYPE UNIT SOURCES ${gtest_sources} LIB_DEPS ${ogre_target})
 
 # Note that plugins are currently being installed in 2 places: /lib and the engine-plugins dir
-install(TARGETS ${ogre_target} DESTINATION ${IGNITION_RENDERING_ENGINE_INSTALL_DIR})
+install(TARGETS ${ogre_target} DESTINATION ${GZ_RENDERING_ENGINE_INSTALL_DIR})
 
 if(WIN32)
   # tests needs .dll in the same directory
@@ -60,11 +60,11 @@ if (WIN32)
   # disable MSVC inherit via dominance warning
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /wd4250")
   INSTALL(CODE "EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E copy
-  ${IGNITION_RENDERING_ENGINE_INSTALL_DIR}\/${versioned}
-  ${IGNITION_RENDERING_ENGINE_INSTALL_DIR}\/${unversioned})")
+  ${GZ_RENDERING_ENGINE_INSTALL_DIR}\/${versioned}
+  ${GZ_RENDERING_ENGINE_INSTALL_DIR}\/${unversioned})")
 else()
   EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E create_symlink ${versioned} ${unversioned})
-  INSTALL(FILES ${PROJECT_BINARY_DIR}/${unversioned} DESTINATION ${IGNITION_RENDERING_ENGINE_INSTALL_DIR})
+  INSTALL(FILES ${PROJECT_BINARY_DIR}/${unversioned} DESTINATION ${GZ_RENDERING_ENGINE_INSTALL_DIR})
 endif()
 
 add_subdirectory(media)
diff --git a/ogre/src/OgreArrowVisual.cc b/ogre/src/OgreArrowVisual.cc
index d32693a05..809ec73ae 100644
--- a/ogre/src/OgreArrowVisual.cc
+++ b/ogre/src/OgreArrowVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreArrowVisual.hh"
+#include "gz/rendering/ogre/OgreArrowVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreAxisVisual.cc b/ogre/src/OgreAxisVisual.cc
index 22e98e888..e612276cd 100644
--- a/ogre/src/OgreAxisVisual.cc
+++ b/ogre/src/OgreAxisVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreAxisVisual.hh"
+#include "gz/rendering/ogre/OgreAxisVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreCOMVisual.cc b/ogre/src/OgreCOMVisual.cc
index 6b4845596..39100d29b 100644
--- a/ogre/src/OgreCOMVisual.cc
+++ b/ogre/src/OgreCOMVisual.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include "ignition/rendering/ogre/OgreCOMVisual.hh"
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/rendering/ogre/OgreCOMVisual.hh"
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
 
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-class ignition::rendering::OgreCOMVisualPrivate
+class gz::rendering::OgreCOMVisualPrivate
 {
   /// \brief Grid materal
   public: OgreMaterialPtr material = nullptr;
@@ -32,7 +32,7 @@ class ignition::rendering::OgreCOMVisualPrivate
   public: VisualPtr sphereVis = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -98,14 +98,14 @@ void OgreCOMVisual::CreateVisual()
   }
 
   double sphereRadius = this->SphereRadius();
-  this->dataPtr->sphereVis->SetLocalScale(ignition::math::Vector3d(
+  this->dataPtr->sphereVis->SetLocalScale(gz::math::Vector3d(
       sphereRadius*2, sphereRadius*2, sphereRadius*2));
   this->dataPtr->sphereVis->SetLocalPosition(this->InertiaPose().Pos());
   this->dataPtr->sphereVis->SetLocalRotation(this->InertiaPose().Rot());
 
   // Get the bounding box of the parent visual
   VisualPtr vis = this->Scene()->VisualByName(this->parentName);
-  ignition::math::AxisAlignedBox box;
+  gz::math::AxisAlignedBox box;
   if (vis)
     box = vis->LocalBoundingBox();
 
@@ -114,19 +114,19 @@ void OgreCOMVisual::CreateVisual()
   this->dataPtr->crossLines->Update();
 
   // CoM position indicator
-  ignition::math::Vector3d p1(0, 0,
+  gz::math::Vector3d p1(0, 0,
       box.Min().Z() - this->InertiaPose().Pos().Z());
-  ignition::math::Vector3d p2(0, 0,
+  gz::math::Vector3d p2(0, 0,
       box.Max().Z() - this->InertiaPose().Pos().Z());
 
-  ignition::math::Vector3d p3(0,
+  gz::math::Vector3d p3(0,
       box.Min().Y() - this->InertiaPose().Pos().Y(), 0);
-  ignition::math::Vector3d p4(0,
+  gz::math::Vector3d p4(0,
       box.Max().Y() - this->InertiaPose().Pos().Y(), 0);
 
-  ignition::math::Vector3d p5(
+  gz::math::Vector3d p5(
       box.Min().X() - this->InertiaPose().Pos().X(), 0, 0);
-  ignition::math::Vector3d p6(
+  gz::math::Vector3d p6(
       box.Max().X() - this->InertiaPose().Pos().X(), 0, 0);
 
   p1 += this->InertiaPose().Pos();
@@ -157,7 +157,7 @@ void OgreCOMVisual::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/OgreCamera.cc b/ogre/src/OgreCamera.cc
index 6a8ea4423..f44a5b9dd 100644
--- a/ogre/src/OgreCamera.cc
+++ b/ogre/src/OgreCamera.cc
@@ -15,16 +15,16 @@
  *
  */
 
-#include "ignition/rendering/ogre/OgreCamera.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreRenderTarget.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreSelectionBuffer.hh"
-#include "ignition/rendering/Utils.hh"
-
-using namespace ignition;
+#include "gz/rendering/ogre/OgreCamera.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreRenderTarget.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreSelectionBuffer.hh"
+#include "gz/rendering/Utils.hh"
+
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -48,7 +48,7 @@ void OgreCamera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   else
   {
@@ -142,13 +142,13 @@ void OgreCamera::CreateCamera()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
 
   this->ogreCamera = ogreSceneManager->createCamera(this->name);
   if (ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
   }
 
   this->ogreNode->attachObject(this->ogreCamera);
@@ -201,7 +201,7 @@ void OgreCamera::SetSelectionBuffer()
 }
 
 //////////////////////////////////////////////////
-VisualPtr OgreCamera::VisualAt(const ignition::math::Vector2i
+VisualPtr OgreCamera::VisualAt(const gz::math::Vector2i
     &_mousePos)
 {
   VisualPtr result;
@@ -217,7 +217,7 @@ VisualPtr OgreCamera::VisualAt(const ignition::math::Vector2i
   }
 
   float ratio = screenScalingFactor();
-  ignition::math::Vector2i mousePos(
+  gz::math::Vector2i mousePos(
       static_cast<int>(std::rint(ratio * _mousePos.X())),
       static_cast<int>(std::rint(ratio * _mousePos.Y())));
 
@@ -237,7 +237,7 @@ VisualPtr OgreCamera::VisualAt(const ignition::math::Vector2i
       }
       catch(Ogre::Exception &e)
       {
-        ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+        gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
       }
     }
   }
diff --git a/ogre/src/OgreCapsule.cc b/ogre/src/OgreCapsule.cc
index c481149b1..a89acd030 100644
--- a/ogre/src/OgreCapsule.cc
+++ b/ogre/src/OgreCapsule.cc
@@ -17,16 +17,16 @@
 
 #include <cmath>
 
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
 
-#include "ignition/rendering/ogre/OgreCapsule.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreMesh.hh"
-#include "ignition/rendering/ogre/OgreVisual.hh"
+#include "gz/rendering/ogre/OgreCapsule.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreMesh.hh"
+#include "gz/rendering/ogre/OgreVisual.hh"
 
-class ignition::rendering::OgreCapsulePrivate
+class gz::rendering::OgreCapsulePrivate
 {
   /// \brief Capsule materal
   public: OgreMaterialPtr material{nullptr};
@@ -35,7 +35,7 @@ class ignition::rendering::OgreCapsulePrivate
   public: OgreMeshPtr ogreMesh{nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -106,7 +106,7 @@ void OgreCapsule::Update()
   meshDescriptor.mesh = meshMgr->MeshByName(capsuleMeshName);
   if (meshDescriptor.mesh == nullptr)
   {
-    ignerr << "Capsule mesh is unavailable in the Mesh Manager" << std::endl;
+    gzerr << "Capsule mesh is unavailable in the Mesh Manager" << std::endl;
     return;
   }
 
@@ -145,7 +145,7 @@ void OgreCapsule::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/OgreConversions.cc b/ogre/src/OgreConversions.cc
index e03e5ea4e..1362cfe38 100644
--- a/ogre/src/OgreConversions.cc
+++ b/ogre/src/OgreConversions.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreDepthCamera.cc b/ogre/src/OgreDepthCamera.cc
index 716c7be1b..eb449d979 100644
--- a/ogre/src/OgreDepthCamera.cc
+++ b/ogre/src/OgreDepthCamera.cc
@@ -22,13 +22,13 @@
   #endif
   #include <windows.h>
 #endif
-#include <ignition/math/Helpers.hh>
-#include "ignition/rendering/ogre/OgreDepthCamera.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
+#include <gz/math/Helpers.hh>
+#include "gz/rendering/ogre/OgreDepthCamera.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
 
 /// \internal
 /// \brief Private data for the OgreDepthCamera class
-class ignition::rendering::OgreDepthCameraPrivate
+class gz::rendering::OgreDepthCameraPrivate
 {
   /// \brief The depth buffer
   public: float *depthBuffer = nullptr;
@@ -58,23 +58,23 @@ class ignition::rendering::OgreDepthCameraPrivate
   public: bool outputPoints = false;
 
   /// \brief maximum value used for data outside sensor range
-  public: float dataMaxVal = ignition::math::INF_D;
+  public: float dataMaxVal = gz::math::INF_D;
 
   /// \brief minimum value used for data outside sensor range
-  public: float dataMinVal = -ignition::math::INF_D;
+  public: float dataMinVal = -gz::math::INF_D;
 
   /// \brief Event used to signal rgb point cloud data
-  public: ignition::common::EventT<void(const float *,
+  public: gz::common::EventT<void(const float *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newRgbPointCloud;
 
   /// \brief Event used to signal depth data
-  public: ignition::common::EventT<void(const float *,
+  public: gz::common::EventT<void(const float *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newDepthFrame;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -117,7 +117,7 @@ void OgreDepthCamera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   else
   {
@@ -146,7 +146,7 @@ void OgreDepthCamera::CreateCamera()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
@@ -154,7 +154,7 @@ void OgreDepthCamera::CreateCamera()
       this->name);
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -205,9 +205,10 @@ void OgreDepthCamera::CreatePointCloudTexture()
 
   this->dataPtr->pcdMaterial = this->scene->CreateMaterial();
 
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
 
   // path to look for vertex and fragment shader parameters
   std::string pcdVSPath = common::joinPaths(
@@ -228,7 +229,7 @@ void OgreDepthCamera::CreateDepthTexture()
 {
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
   }
 
   if (this->depthTexture == nullptr)
@@ -490,16 +491,16 @@ void OgreDepthCamera::PostRender()
         "PF_FLOAT32_RGBA");
 
     // Uncomment to debug xyz output
-    // igndbg << "wxh: " << width << " x " << height << std::endl;
+    // gzdbg << "wxh: " << width << " x " << height << std::endl;
     // for (unsigned int i = 0; i < height; ++i)
     // {
     //   for (unsigned int j = 0; j < width; ++j)
     //   {
-    //     igndbg << "[" << this->dataPtr->pcdBuffer[i*width*4+j*4] << "]"
+    //     gzdbg << "[" << this->dataPtr->pcdBuffer[i*width*4+j*4] << "]"
     //       << "[" << this->dataPtr->pcdBuffer[i*width*4+j*4+1] << "]"
     //       << "[" << this->dataPtr->pcdBuffer[i*width*4+j*4+2] << "],";
     //   }
-    //   igndbg << std::endl;
+    //   gzdbg << std::endl;
     // }
 
     // Uncommnet to debug color output
@@ -512,11 +513,11 @@ void OgreDepthCamera::PostRender()
     //     unsigned int r = *rgba >> 24 & 0xFF;
     //     unsigned int g = *rgba >> 16 & 0xFF;
     //     unsigned int b = *rgba >> 8 & 0xFF;
-    //     igndbg << "[" << r << "]"
+    //     gzdbg << "[" << r << "]"
     //            << "[" << g << "]"
     //            << "[" << b << "],";
     //   }
-    //   igndbg << std::endl;
+    //   gzdbg << std::endl;
     // }
   }
 }
@@ -528,7 +529,7 @@ const float *OgreDepthCamera::DepthData() const
 }
 
 //////////////////////////////////////////////////
-ignition::common::ConnectionPtr OgreDepthCamera::ConnectNewDepthFrame(
+gz::common::ConnectionPtr OgreDepthCamera::ConnectNewDepthFrame(
     std::function<void(const float *, unsigned int, unsigned int,
       unsigned int, const std::string &)>  _subscriber)
 {
@@ -536,7 +537,7 @@ ignition::common::ConnectionPtr OgreDepthCamera::ConnectNewDepthFrame(
 }
 
 //////////////////////////////////////////////////
-ignition::common::ConnectionPtr OgreDepthCamera::ConnectNewRgbPointCloud(
+gz::common::ConnectionPtr OgreDepthCamera::ConnectNewRgbPointCloud(
     std::function<void(const float *, unsigned int, unsigned int,
       unsigned int, const std::string &)>  _subscriber)
 {
diff --git a/ogre/src/OgreDistortionPass.cc b/ogre/src/OgreDistortionPass.cc
index 278747f10..3d9bf7250 100644
--- a/ogre/src/OgreDistortionPass.cc
+++ b/ogre/src/OgreDistortionPass.cc
@@ -16,21 +16,21 @@
  */
 
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreDistortionPass.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreDistortionPass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     class OgreDistortionPass::Implementation
     {
       /// \brief Scale applied to distorted image.
-      public: ignition::math::Vector2d distortionScale = {1.0, 1.0};
+      public: gz::math::Vector2d distortionScale = {1.0, 1.0};
 
       /// \brief True if the distorted image will be cropped to remove the
       /// black pixels at the corners of the image.
@@ -46,7 +46,7 @@ namespace ignition
       public: Ogre::TexturePtr distortionTexture;
 
       /// \brief Mapping of distorted to undistorted normalized pixels
-      public: std::vector<ignition::math::Vector2d> distortionMap;
+      public: std::vector<gz::math::Vector2d> distortionMap;
 
       /// \brief Width of distortion texture map
       public: unsigned int distortionTexWidth = 0u;
@@ -55,7 +55,7 @@ namespace ignition
       public: unsigned int distortionTexHeight = 0u;
 
       /// \brief Distortion compositor listener
-      /// uses <ignition/utils/ImplPtr.hh> from ign-rendering7
+      /// uses <gz/utils/ImplPtr.hh> from ign-rendering7
       IGN_UTILS_WARN_IGNORE__DLL_INTERFACE_MISSING
       public: std::shared_ptr<DistortionCompositorListener>
           distortionCompositorListener;
@@ -68,7 +68,7 @@ namespace ignition
       /// \brief Constructor, setting mean and standard deviation.
       public: DistortionCompositorListener(
           const Ogre::TexturePtr &_distortionTexture,
-          const ignition::math::Vector2d &_distortionScale):
+          const gz::math::Vector2d &_distortionScale):
           distortionTexture(_distortionTexture),
           distortionScale(_distortionScale) {}
 
@@ -99,13 +99,13 @@ namespace ignition
 
       private: const Ogre::TexturePtr &distortionTexture;
 
-      private: const ignition::math::Vector2d &distortionScale;
+      private: const gz::math::Vector2d &distortionScale;
     };
     }
   }
 }
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -133,22 +133,22 @@ void OgreDistortionPass::CreateRenderPass()
 {
   if (!this->ogreCamera)
   {
-    ignerr << "No camera set for applying Distortion Pass" << std::endl;
+    gzerr << "No camera set for applying Distortion Pass" << std::endl;
     return;
   }
 
   if (this->dataPtr->distortionInstance)
   {
-    ignerr << "Distortion pass already created. " << std::endl;
+    gzerr << "Distortion pass already created. " << std::endl;
     return;
   }
 
   // If no distortion is required, immediately return.
-  if (ignition::math::equal(this->k1, 0.0) &&
-      ignition::math::equal(this->k2, 0.0) &&
-      ignition::math::equal(this->k3, 0.0) &&
-      ignition::math::equal(this->p1, 0.0) &&
-      ignition::math::equal(this->p2, 0.0))
+  if (gz::math::equal(this->k1, 0.0) &&
+      gz::math::equal(this->k2, 0.0) &&
+      gz::math::equal(this->k3, 0.0) &&
+      gz::math::equal(this->p1, 0.0) &&
+      gz::math::equal(this->p2, 0.0))
   {
     return;
   }
@@ -177,7 +177,7 @@ void OgreDistortionPass::CreateRenderPass()
   // Half step-size vector to add to the value being placed in distortion map.
   // Necessary for compositor to correctly interpolate pixel values.
   const auto halfTexelSize =
-      0.5 * ignition::math::Vector2d(rowStepSize, colStepSize);
+      0.5 * gz::math::Vector2d(rowStepSize, colStepSize);
 
   // initialize distortion map
   this->dataPtr->distortionMap.resize(imageSize);
@@ -186,13 +186,13 @@ void OgreDistortionPass::CreateRenderPass()
     this->dataPtr->distortionMap[i] = -1;
   }
 
-  ignition::math::Vector2d distortionCenterCoordinates(
+  gz::math::Vector2d distortionCenterCoordinates(
       this->lensCenter.X() * this->dataPtr->distortionTexWidth,
       this->lensCenter.Y() * this->dataPtr->distortionTexWidth);
 
   // declare variables before the loop
-  const auto unsetPixelVector =  ignition::math::Vector2d(-1, -1);
-  ignition::math::Vector2d normalizedLocation,
+  const auto unsetPixelVector =  gz::math::Vector2d(-1, -1);
+  gz::math::Vector2d normalizedLocation,
       distortedLocation,
       newDistortedCoordinates,
       currDistortedCoordinates;
@@ -313,7 +313,7 @@ void OgreDistortionPass::CreateRenderPass()
   {
     for (unsigned int j = 0; j < this->dataPtr->distortionTexWidth; ++j)
     {
-      ignition::math::Vector2d vec =
+      gz::math::Vector2d vec =
           this->dataPtr->distortionMap[i *
               this->dataPtr->distortionTexWidth + j];
 
@@ -323,25 +323,25 @@ void OgreDistortionPass::CreateRenderPass()
 
       if (vec.X() < -0.5 && vec.Y() < -0.5)
       {
-        ignition::math::Vector2d left =
+        gz::math::Vector2d left =
             this->DistortionMapValueClamped(j - 1, i);
-        ignition::math::Vector2d right =
+        gz::math::Vector2d right =
             this->DistortionMapValueClamped(j + 1, i);
-        ignition::math::Vector2d bottom =
+        gz::math::Vector2d bottom =
             this->DistortionMapValueClamped(j, i + 1);
-        ignition::math::Vector2d top =
+        gz::math::Vector2d top =
             this->DistortionMapValueClamped(j, i - 1);
 
-        ignition::math::Vector2d topLeft =
+        gz::math::Vector2d topLeft =
             this->DistortionMapValueClamped(j - 1, i - 1);
-        ignition::math::Vector2d topRight =
+        gz::math::Vector2d topRight =
             this->DistortionMapValueClamped(j + 1, i - 1);
-        ignition::math::Vector2d bottomLeft =
+        gz::math::Vector2d bottomLeft =
             this->DistortionMapValueClamped(j - 1, i + 1);
-        ignition::math::Vector2d bottomRight =
+        gz::math::Vector2d bottomRight =
             this->DistortionMapValueClamped(j + 1, i + 1);
 
-        ignition::math::Vector2d interpolated;
+        gz::math::Vector2d interpolated;
         double divisor = 0;
         if (right.X() > -0.5)
         {
@@ -389,8 +389,8 @@ void OgreDistortionPass::CreateRenderPass()
         {
           interpolated /= divisor;
         }
-        *pDest++ = ignition::math::clamp(interpolated.X(), 0.0, 1.0);
-        *pDest++ = ignition::math::clamp(interpolated.Y(), 0.0, 1.0);
+        *pDest++ = gz::math::clamp(interpolated.X(), 0.0, 1.0);
+        *pDest++ = gz::math::clamp(interpolated.Y(), 0.0, 1.0);
       }
       else
       {
@@ -447,21 +447,21 @@ void OgreDistortionPass::Destroy()
 }
 
 //////////////////////////////////////////////////
-ignition::math::Vector2d OgreDistortionPass::Distort(
-    const ignition::math::Vector2d &_in,
-    const ignition::math::Vector2d &_center, double _k1, double _k2, double _k3,
+gz::math::Vector2d OgreDistortionPass::Distort(
+    const gz::math::Vector2d &_in,
+    const gz::math::Vector2d &_center, double _k1, double _k2, double _k3,
     double _p1, double _p2, unsigned int _width, double _f)
 {
   // apply Brown's distortion model, see
   // http://en.wikipedia.org/wiki/Distortion_%28optics%29#Software_correction
 
-  ignition::math::Vector2d normalized2d = (_in - _center) * (_width / _f);
-  ignition::math::Vector3d normalized(normalized2d.X(), normalized2d.Y(), 0);
+  gz::math::Vector2d normalized2d = (_in - _center) * (_width / _f);
+  gz::math::Vector3d normalized(normalized2d.X(), normalized2d.Y(), 0);
   double rSq = normalized.X() * normalized.X() +
                normalized.Y() * normalized.Y();
 
   // radial
-  ignition::math::Vector3d dist = normalized * (1.0 +
+  gz::math::Vector3d dist = normalized * (1.0 +
       _k1 * rSq +
       _k2 * rSq * rSq +
       _k3 * rSq * rSq * rSq);
@@ -473,20 +473,20 @@ ignition::math::Vector2d OgreDistortionPass::Distort(
       2 * _p2 * normalized.X() * normalized.Y();
 
   return ((_center * _width) +
-    ignition::math::Vector2d(dist.X(), dist.Y()) *_f) / _width;
+    gz::math::Vector2d(dist.X(), dist.Y()) *_f) / _width;
 }
 
 //////////////////////////////////////////////////
-ignition::math::Vector2d
+gz::math::Vector2d
     OgreDistortionPass::DistortionMapValueClamped(
     int _x, int _y) const
 {
   if (_x < 0 || _x >= static_cast<int>(this->dataPtr->distortionTexWidth) ||
       _y < 0 || _y >= static_cast<int>(this->dataPtr->distortionTexHeight))
   {
-    return ignition::math::Vector2d(-1, -1);
+    return gz::math::Vector2d(-1, -1);
   }
-  ignition::math::Vector2d res =
+  gz::math::Vector2d res =
       this->dataPtr->distortionMap[_y * this->dataPtr->distortionTexWidth + _x];
   return res;
 }
@@ -517,23 +517,23 @@ void OgreDistortionPass::CalculateAndApplyDistortionScale()
 
     // I believe that if not used with a square distortion texture, this
     // calculation will result in stretching of the final output image.
-    ignition::math::Vector2d boundA = this->Distort(
-        ignition::math::Vector2d(0, 0),
+    gz::math::Vector2d boundA = this->Distort(
+        gz::math::Vector2d(0, 0),
         this->lensCenter,
         this->k1, this->k2, this->k3,
         this->p1, this->p2, this->dataPtr->distortionTexWidth,
         focalLength);
-    ignition::math::Vector2d boundB = this->Distort(
-        ignition::math::Vector2d(1, 1),
+    gz::math::Vector2d boundB = this->Distort(
+        gz::math::Vector2d(1, 1),
         this->lensCenter,
         this->k1, this->k2, this->k3,
         this->p1, this->p2, this->dataPtr->distortionTexWidth,
         focalLength);
-    ignition::math::Vector2d newScale = boundB - boundA;
+    gz::math::Vector2d newScale = boundB - boundA;
     // If distortionScale is extremely small, don't crop
     if (newScale.X() < 1e-7 || newScale.Y() < 1e-7)
     {
-       ignerr << "Distortion model attempted to apply a scale parameter of ("
+       gzerr << "Distortion model attempted to apply a scale parameter of ("
              << this->dataPtr->distortionScale.X() << ", "
              << this->dataPtr->distortionScale.Y()
              << ", which is invalid.\n";
@@ -543,7 +543,7 @@ void OgreDistortionPass::CalculateAndApplyDistortionScale()
   }
   // Otherwise no scaling
   else
-    this->dataPtr->distortionScale = ignition::math::Vector2d(1, 1);
+    this->dataPtr->distortionScale = gz::math::Vector2d(1, 1);
 }
 
 IGN_RENDERING_REGISTER_RENDER_PASS(OgreDistortionPass, DistortionPass)
diff --git a/ogre/src/OgreDynamicLines.cc b/ogre/src/OgreDynamicLines.cc
index d19c6b8e1..f5b92cf45 100644
--- a/ogre/src/OgreDynamicLines.cc
+++ b/ogre/src/OgreDynamicLines.cc
@@ -18,25 +18,25 @@
 
 #include <cmath>
 #include <sstream>
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
-#include "ignition/common/Console.hh"
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/common/Console.hh"
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 enum {POSITION_BINDING, TEXCOORD_BINDING};
 
 
 /// \brief Private implementation
-class ignition::rendering::OgreDynamicLinesPrivate
+class gz::rendering::OgreDynamicLinesPrivate
 {
   /// \brief list of colors at each point
-  public: std::vector<ignition::math::Color> colors;
+  public: std::vector<gz::math::Color> colors;
 
   /// \brief List of points for the line
-  public: std::vector<ignition::math::Vector3d> points;
+  public: std::vector<gz::math::Vector3d> points;
 
   /// \brief Used to indicate if the lines require an update
   public: bool dirty = false;
@@ -57,8 +57,8 @@ OgreDynamicLines::~OgreDynamicLines()
 }
 
 /////////////////////////////////////////////////
-void OgreDynamicLines::AddPoint(const ignition::math::Vector3d &_pt,
-                            const ignition::math::Color &_color)
+void OgreDynamicLines::AddPoint(const gz::math::Vector3d &_pt,
+                            const gz::math::Color &_color)
 {
   this->dataPtr->points.push_back(_pt);
   this->dataPtr->colors.push_back(_color);
@@ -67,18 +67,18 @@ void OgreDynamicLines::AddPoint(const ignition::math::Vector3d &_pt,
 
 /////////////////////////////////////////////////
 void OgreDynamicLines::AddPoint(double _x, double _y,
-                double _z, const ignition::math::Color &_color)
+                double _z, const gz::math::Color &_color)
 {
-  this->AddPoint(ignition::math::Vector3d(_x, _y, _z), _color);
+  this->AddPoint(gz::math::Vector3d(_x, _y, _z), _color);
 }
 
 /////////////////////////////////////////////////
 void OgreDynamicLines::SetPoint(unsigned int _index,
-                            const ignition::math::Vector3d &_value)
+                            const gz::math::Vector3d &_value)
 {
   if (_index >= this->dataPtr->points.size())
   {
-    ignerr << "Point index[" << _index << "] is out of bounds[0-"
+    gzerr << "Point index[" << _index << "] is out of bounds[0-"
            << this->dataPtr->points.size()-1 << "]\n";
     return;
   }
@@ -90,24 +90,24 @@ void OgreDynamicLines::SetPoint(unsigned int _index,
 
 /////////////////////////////////////////////////
 void OgreDynamicLines::SetColor(unsigned int _index,
-                            const ignition::math::Color &_color)
+                            const gz::math::Color &_color)
 {
   this->dataPtr->colors[_index] = _color;
   this->dataPtr->dirty = true;
 }
 
 /////////////////////////////////////////////////
-ignition::math::Vector3d OgreDynamicLines::Point(
+gz::math::Vector3d OgreDynamicLines::Point(
     const unsigned int _index) const
 {
   if (_index >= this->dataPtr->points.size())
   {
-    ignerr << "Point index[" << _index << "] is out of bounds[0-"
+    gzerr << "Point index[" << _index << "] is out of bounds[0-"
            << this->dataPtr->points.size()-1 << "]\n";
 
-    return ignition::math::Vector3d(ignition::math::INF_D,
-                                    ignition::math::INF_D,
-                                    ignition::math::INF_D);
+    return gz::math::Vector3d(gz::math::INF_D,
+                                    gz::math::INF_D,
+                                    gz::math::INF_D);
   }
 
   return this->dataPtr->points[_index];
diff --git a/ogre/src/OgreDynamicRenderable.cc b/ogre/src/OgreDynamicRenderable.cc
index cca6792da..412ef7b3b 100644
--- a/ogre/src/OgreDynamicRenderable.cc
+++ b/ogre/src/OgreDynamicRenderable.cc
@@ -15,10 +15,10 @@
  *
 */
 
-#include "ignition/common/Console.hh"
-#include "ignition/rendering/ogre/OgreDynamicRenderable.hh"
+#include "gz/common/Console.hh"
+#include "gz/rendering/ogre/OgreDynamicRenderable.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -95,7 +95,7 @@ void OgreDynamicRenderable::SetOperationType(MarkerType _opType)
       break;
 
     default:
-      ignerr << "Unknown render operation type[" << _opType << "]\n";
+      gzerr << "Unknown render operation type[" << _opType << "]\n";
       break;
   }
 }
diff --git a/ogre/src/OgreGaussianNoisePass.cc b/ogre/src/OgreGaussianNoisePass.cc
index 082c89f18..6c8f2480e 100644
--- a/ogre/src/OgreGaussianNoisePass.cc
+++ b/ogre/src/OgreGaussianNoisePass.cc
@@ -16,17 +16,17 @@
  */
 
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreGaussianNoisePass.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreGaussianNoisePass.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // We'll create an instance of this class for each camera, to be used to
     // inject random values on each render call.
@@ -55,9 +55,9 @@ namespace ignition
         // Sample three values within the range [0,1.0] and set them for use in
         // the fragment shader, which will interpret them as offsets from (0,0)
         // to use when computing pseudo-random values.
-        Ogre::Vector3 offsets(ignition::math::Rand::DblUniform(0.0, 1.0),
-                              ignition::math::Rand::DblUniform(0.0, 1.0),
-                              ignition::math::Rand::DblUniform(0.0, 1.0));
+        Ogre::Vector3 offsets(gz::math::Rand::DblUniform(0.0, 1.0),
+                              gz::math::Rand::DblUniform(0.0, 1.0),
+                              gz::math::Rand::DblUniform(0.0, 1.0));
         // These calls are setting parameters that are declared in two places:
         // 1. media/materials/scripts/gaussian_noise.material, in
         //    fragment_program GaussianNoiseFS
@@ -89,7 +89,7 @@ namespace ignition
   }
 }
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -116,13 +116,13 @@ void OgreGaussianNoisePass::CreateRenderPass()
 {
   if (!this->ogreCamera)
   {
-    ignerr << "No camera set for applying Gaussian Noise Pass" << std::endl;
+    gzerr << "No camera set for applying Gaussian Noise Pass" << std::endl;
     return;
   }
 
   if (this->gaussianNoiseInstance || this->gaussianNoiseCompositorListener)
   {
-    ignerr << "Gaussian Noise pass already created. " << std::endl;
+    gzerr << "Gaussian Noise pass already created. " << std::endl;
     return;
   }
 
diff --git a/ogre/src/OgreGeometry.cc b/ogre/src/OgreGeometry.cc
index 821967c35..787dff754 100644
--- a/ogre/src/OgreGeometry.cc
+++ b/ogre/src/OgreGeometry.cc
@@ -14,12 +14,12 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreGeometry.hh"
+#include "gz/rendering/ogre/OgreGeometry.hh"
 
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreVisual.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreGizmoVisual.cc b/ogre/src/OgreGizmoVisual.cc
index 8cbfc67ff..6e3310acf 100644
--- a/ogre/src/OgreGizmoVisual.cc
+++ b/ogre/src/OgreGizmoVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreGizmoVisual.hh"
+#include "gz/rendering/ogre/OgreGizmoVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreGpuRays.cc b/ogre/src/OgreGpuRays.cc
index 32e0e4d31..61df6ef77 100644
--- a/ogre/src/OgreGpuRays.cc
+++ b/ogre/src/OgreGpuRays.cc
@@ -15,21 +15,21 @@
  *
 */
 
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
-#include <ignition/common/SubMesh.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
+#include <gz/common/SubMesh.hh>
 
-#include <ignition/math/Color.hh>
-#include <ignition/math/Helpers.hh>
-#include <ignition/math/Vector3.hh>
+#include <gz/math/Color.hh>
+#include <gz/math/Helpers.hh>
+#include <gz/math/Vector3.hh>
 
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre/OgreCamera.hh"
-#include "ignition/rendering/ogre/OgreGpuRays.hh"
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre/OgreCamera.hh"
+#include "gz/rendering/ogre/OgreGpuRays.hh"
 
 /// \internal
 /// \brief Private data for the OgreGpuRays class
-class ignition::rendering::OgreGpuRaysPrivate
+class gz::rendering::OgreGpuRaysPrivate
 {
   /// \brief Event triggered when new gpu rays range data are available.
   /// \param[in] _frame New frame containing raw gpu rays data.
@@ -37,7 +37,7 @@ class ignition::rendering::OgreGpuRaysPrivate
   /// \param[in] _height Height of frame.
   /// \param[in] _channels Number of channels
   /// \param[in] _format Format of frame.
-  public: ignition::common::EventT<void(const float *,
+  public: gz::common::EventT<void(const float *,
                unsigned int, unsigned int, unsigned int,
                const std::string &)> newGpuRaysFrame;
 
@@ -129,7 +129,7 @@ class ignition::rendering::OgreGpuRaysPrivate
   public: const math::Angle kMinAllowedAngle = 1e-4;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -225,7 +225,7 @@ void OgreGpuRays::CreateCamera()
   Ogre::SceneManager *ogreSceneManager  = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
@@ -233,7 +233,7 @@ void OgreGpuRays::CreateCamera()
       this->Name() + "_Camera");
   if (this->dataPtr->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -255,7 +255,7 @@ void OgreGpuRays::ConfigureCameras()
   if (this->HFOV().Radian() > 2.0 * IGN_PI)
   {
     this->SetHFOV(2.0 * IGN_PI);
-    ignwarn << "Horizontal FOV for GPU rays is capped at 180 degrees.\n";
+    gzwarn << "Horizontal FOV for GPU rays is capped at 180 degrees.\n";
   }
 
   this->SetHorzHalfAngle((this->AngleMax() + this->AngleMin()).Radian() / 2.0);
@@ -302,7 +302,7 @@ void OgreGpuRays::ConfigureCameras()
 
     if (this->VerticalAngleMax() != this->VerticalAngleMin())
     {
-      ignwarn << "Only one vertical ray but vertical min. and max. angle "
+      gzwarn << "Only one vertical ray but vertical min. and max. angle "
           "are not equal. Min. angle is used.\n";
       this->SetVerticalAngleMax(this->VerticalAngleMin().Radian());
     }
@@ -311,7 +311,7 @@ void OgreGpuRays::ConfigureCameras()
   if (vfovAngle > IGN_PI / 2.0)
   {
     vfovAngle = IGN_PI / 2.0;
-    ignwarn << "Vertical FOV for GPU laser is capped at 90 degrees.\n";
+    gzwarn << "Vertical FOV for GPU laser is capped at 90 degrees.\n";
   }
 
   this->SetVFOV(vfovAngle);
@@ -332,7 +332,7 @@ void OgreGpuRays::ConfigureCameras()
 
   if (vfovCamera > 2.8)
   {
-    ignerr << "Vertical FOV of internal camera exceeds 2.8 radians.\n";
+    gzerr << "Vertical FOV of internal camera exceeds 2.8 radians.\n";
   }
 
   this->SetCosVertFOV(vfovCamera);
@@ -703,7 +703,7 @@ void OgreGpuRays::CreateOrthoCam()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
@@ -711,12 +711,12 @@ void OgreGpuRays::CreateOrthoCam()
       this->Name() + "_Ortho_Camera");
   if (this->dataPtr->orthoCam == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
   Ogre::SceneNode *rootSceneNode = std::dynamic_pointer_cast<
-      ignition::rendering::OgreNode>(this->scene->RootVisual())->Node();
+      gz::rendering::OgreNode>(this->scene->RootVisual())->Node();
   this->dataPtr->pitchNodeOrtho = rootSceneNode->createChildSceneNode();
   this->dataPtr->pitchNodeOrtho->attachObject(this->dataPtr->orthoCam);
 
@@ -899,7 +899,7 @@ void OgreGpuRays::CreateCanvas()
       this->Name() + "second_pass_canvas");
 
   Ogre::SceneNode *visualSceneNode =  std::dynamic_pointer_cast<
-    ignition::rendering::OgreNode>(this->dataPtr->visual)->Node();
+    gz::rendering::OgreNode>(this->dataPtr->visual)->Node();
 
   Ogre::Node *visualParent = visualSceneNode->getParent();
   if (visualParent != nullptr)
@@ -919,7 +919,7 @@ void OgreGpuRays::CreateCanvas()
 
   MaterialPtr canvasMaterial =
     this->scene->CreateMaterial(this->Name() + "_green");
-  canvasMaterial->SetAmbient(ignition::math::Color(0, 1, 0, 1));
+  canvasMaterial->SetAmbient(gz::math::Color(0, 1, 0, 1));
   this->dataPtr->visual->SetMaterial(canvasMaterial);
 
   this->dataPtr->visual->SetVisible(true);
@@ -981,7 +981,7 @@ void OgreGpuRays::notifyRenderSingleObject(Ogre::Renderable *_rend,
 }
 
 //////////////////////////////////////////////////
-ignition::common::ConnectionPtr OgreGpuRays::ConnectNewGpuRaysFrame(
+gz::common::ConnectionPtr OgreGpuRays::ConnectNewGpuRaysFrame(
     std::function<void(const float *_frame, unsigned int _width,
     unsigned int _height, unsigned int _channels,
     const std::string &/*_format*/)> _subscriber)
diff --git a/ogre/src/OgreGrid.cc b/ogre/src/OgreGrid.cc
index 168ab96ea..a2052186b 100644
--- a/ogre/src/OgreGrid.cc
+++ b/ogre/src/OgreGrid.cc
@@ -15,13 +15,13 @@
  *
 */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreGrid.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreGrid.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-class ignition::rendering::OgreGridPrivate
+class gz::rendering::OgreGridPrivate
 {
   /// \brief Grid materal
   public: OgreMaterialPtr material;
@@ -30,7 +30,7 @@ class ignition::rendering::OgreGridPrivate
   public: Ogre::ManualObject *manualObject = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -168,7 +168,7 @@ void OgreGrid::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/OgreHeightmap.cc b/ogre/src/OgreHeightmap.cc
index 1d26e0001..7c9efef40 100644
--- a/ogre/src/OgreHeightmap.cc
+++ b/ogre/src/OgreHeightmap.cc
@@ -17,17 +17,17 @@
 
 #include <chrono>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Util.hh>
-
-#include "ignition/rendering/ogre/OgreCamera.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreHeightmap.hh"
-#include "ignition/rendering/ogre/OgreLight.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include <gz/common/Console.hh>
+#include <gz/common/Util.hh>
+
+#include "gz/rendering/ogre/OgreCamera.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreHeightmap.hh"
+#include "gz/rendering/ogre/OgreLight.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
 #if OGRE_VERSION_MAJOR == 1 && OGRE_VERSION_MINOR >= 11
 // Since OGRE 1.11, the once public
@@ -310,7 +310,7 @@ class DummyPageProvider : public Ogre::PageProvider
 };
 
 //////////////////////////////////////////////////
-class ignition::rendering::OgreHeightmapPrivate
+class gz::rendering::OgreHeightmapPrivate
 {
   /// \brief Global options - in some Ogre versions, this is enforced as a
   /// singleton.
@@ -409,9 +409,9 @@ class ignition::rendering::OgreHeightmapPrivate
 };
 
 Ogre::TerrainGlobalOptions
-    *ignition::rendering::OgreHeightmapPrivate::terrainGlobals = nullptr;
+    *gz::rendering::OgreHeightmapPrivate::terrainGlobals = nullptr;
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -419,7 +419,7 @@ OgreHeightmap::OgreHeightmap(const HeightmapDescriptor &_desc)
     : BaseHeightmap(_desc), dataPtr(std::make_unique<OgreHeightmapPrivate>())
 {
   std::string home;
-  ignition::common::env(IGN_HOMEDIR, home);
+  gz::common::env(IGN_HOMEDIR, home);
 
   this->dataPtr->pagingDir =
       common::joinPaths(home, ".ignition", "rendering",
@@ -438,7 +438,7 @@ void OgreHeightmap::Init()
 
   if (this->descriptor.Data() == nullptr)
   {
-    ignerr << "Failed to initialize: null heightmap data." << std::endl;
+    gzerr << "Failed to initialize: null heightmap data." << std::endl;
     return;
   }
 
@@ -504,13 +504,13 @@ void OgreHeightmap::Init()
 
   if (this->dataPtr->heights.empty())
   {
-    ignerr << "Failed to load terrain. Heightmap data is empty" << std::endl;
+    gzerr << "Failed to load terrain. Heightmap data is empty" << std::endl;
     return;
   }
 
   if (!math::isPowerOfTwo(this->dataPtr->dataSize - 1))
   {
-    ignerr << "Heightmap final sampling must satisfy 2^n+1."
+    gzerr << "Heightmap final sampling must satisfy 2^n+1."
            << std::endl << "size = (width * sampling) = sampling + 1"
            << std::endl << "[" << this->dataPtr->dataSize << "] = (["
            << this->descriptor.Data()->Width() << "] * ["
@@ -567,7 +567,7 @@ void OgreHeightmap::Init()
         this->dataPtr->numTerrainSubdivisions = 16u;
       nTerrains = this->dataPtr->numTerrainSubdivisions;
 
-      ignmsg << "Large heightmap used with LOD. It will be subdivided into " <<
+      gzmsg << "Large heightmap used with LOD. It will be subdivided into " <<
           this->dataPtr->numTerrainSubdivisions << " terrains." << std::endl;
     }
     std::string terrainName = "gazebo_terrain" + terrainNameSuffix;
@@ -672,7 +672,7 @@ void OgreHeightmap::Init()
         static_cast<unsigned int>(sqrtN) - 1);
   }
 
-  ignmsg << "Loading heightmap: " << this->descriptor.Name() << std::endl;
+  gzmsg << "Loading heightmap: " << this->descriptor.Name() << std::endl;
   auto time = std::chrono::steady_clock::now();
 
   for (int y = 0; y <= sqrtN - 1; ++y)
@@ -685,7 +685,7 @@ void OgreHeightmap::Init()
   // Sync load since we want everything in place when we start
   this->dataPtr->terrainGroup->loadAllTerrains(true);
 
-  ignmsg << "Heightmap loaded. Process took "
+  gzmsg << "Heightmap loaded. Process took "
         <<  std::chrono::duration_cast<std::chrono::milliseconds>(
             std::chrono::steady_clock::now() - time).count()
         << " ms." << std::endl;
@@ -738,7 +738,7 @@ void OgreHeightmap::PreRender()
 
   // saving an ogre terrain data file can take quite some time for large
   // terrains.
-  ignmsg << "Saving heightmap cache data to "
+  gzmsg << "Saving heightmap cache data to "
          << common::joinPaths(this->dataPtr->pagingDir, this->descriptor.Name())
          << std::endl;
   auto time = std::chrono::steady_clock::now();
@@ -751,12 +751,12 @@ void OgreHeightmap::PreRender()
   }
   catch(Ogre::Exception &_e)
   {
-    ignerr << "Failed to save heightmap: " << _e.what() << std::endl;
+    gzerr << "Failed to save heightmap: " << _e.what() << std::endl;
   }
 
   if (saved)
   {
-    ignmsg << "Heightmap cache data saved. Process took "
+    gzmsg << "Heightmap cache data saved. Process took "
           <<  std::chrono::duration_cast<std::chrono::milliseconds>(
               std::chrono::steady_clock::now() - time).count()
           << " ms." << std::endl;
@@ -858,7 +858,7 @@ bool OgreHeightmap::PrepareTerrain(
     }
     catch(std::ifstream::failure &_e)
     {
-      ignerr << "Terrain paging error: Unable to read terrain hash ["
+      gzerr << "Terrain paging error: Unable to read terrain hash ["
              << _e.what() << "]" << std::endl;
     }
   }
@@ -894,7 +894,7 @@ void OgreHeightmap::UpdateTerrainHash(const std::string &_hash,
   }
   else
   {
-    ignerr << "Unable to open file for creating a terrain hash: [" +
+    gzerr << "Unable to open file for creating a terrain hash: [" +
         terrainHashFullPath + "]" << std::endl;
   }
 }
@@ -906,7 +906,7 @@ void OgreHeightmap::SplitHeights(const std::vector<float> &_heightmap,
   // We support splitting the terrain in 4 or 16 pieces
   if (_n != 4 && _n != 16)
   {
-    ignerr << "Invalid number of terrain divisions [" << _n
+    gzerr << "Invalid number of terrain divisions [" << _n
            << "]. It should be 4 or 16." << std::endl;
     return;
   }
@@ -961,7 +961,7 @@ void OgreHeightmap::DefineTerrain(int _x, int _y)
 
   if (resourceExists && !this->dataPtr->terrainHashChanged)
   {
-    ignmsg << "Loading heightmap cache data: " << filename << std::endl;
+    gzmsg << "Loading heightmap cache data: " << filename << std::endl;
 
     this->dataPtr->terrainGroup->defineTerrain(_x, _y);
     this->dataPtr->loadedFromCache = true;
@@ -1075,7 +1075,7 @@ bool OgreHeightmap::InitBlendMaps(Ogre::Terrain *_terrain)
 {
   if (nullptr == _terrain)
   {
-    ignerr << "Invalid terrain\n";
+    gzerr << "Invalid terrain\n";
     return false;
   }
 
@@ -1087,7 +1087,7 @@ bool OgreHeightmap::InitBlendMaps(Ogre::Terrain *_terrain)
   // Bounds check for following loop
   if (_terrain->getLayerCount() < this->descriptor.BlendCount() + 1)
   {
-    ignerr << "Invalid terrain, too few layers ["
+    gzerr << "Invalid terrain, too few layers ["
            << unsigned(_terrain->getLayerCount())
            << "] for the number of blends ["
            << this->descriptor.BlendCount() << "] to initialize blend map"
@@ -1225,7 +1225,7 @@ void IgnTerrainMatGen::SM2Profile::addTechnique(
     }
     else
     {
-      ignerr << "No supported shader languages" << std::endl;
+      gzerr << "No supported shader languages" << std::endl;
       return;
     }
 
@@ -1791,7 +1791,7 @@ void IgnTerrainMatGen::SM2Profile::ShaderHelperGLSL::generateVpHeader(
         _outStream << "  worldPos.x += uv1.x * toMorph * lodMorph.x;\n";
         break;
       default:
-        ignerr << "Invalid alignment\n";
+        gzerr << "Invalid alignment\n";
     };
   }
 
@@ -2154,7 +2154,7 @@ void IgnTerrainMatGen::SM2Profile::ShaderHelperGLSL::generateFpHeader(
           _outStream << "  vec3 tangent = vec3(0.0, 0.0, -1.0);\n";
           break;
         default:
-          ignerr << "Invalid terrain alignment\n";
+          gzerr << "Invalid terrain alignment\n";
           break;
       };
 
@@ -2694,7 +2694,7 @@ void TerrainMaterial::setGridSize(const unsigned int _size)
 {
   if (_size == 0)
   {
-    ignerr << "Unable to set a grid size of zero" << std::endl;
+    gzerr << "Unable to set a grid size of zero" << std::endl;
     return;
   }
 
diff --git a/ogre/src/OgreInertiaVisual.cc b/ogre/src/OgreInertiaVisual.cc
index d95571bc7..a2b070d46 100644
--- a/ogre/src/OgreInertiaVisual.cc
+++ b/ogre/src/OgreInertiaVisual.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include "ignition/rendering/ogre/OgreInertiaVisual.hh"
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/rendering/ogre/OgreInertiaVisual.hh"
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
 
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-class ignition::rendering::OgreInertiaVisualPrivate
+class gz::rendering::OgreInertiaVisualPrivate
 {
   /// \brief Grid materal
   public: OgreMaterialPtr material = nullptr;
@@ -32,7 +32,7 @@ class ignition::rendering::OgreInertiaVisualPrivate
   public: VisualPtr boxVis = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -66,8 +66,8 @@ Ogre::MovableObject *OgreInertiaVisual::OgreObject() const
 }
 
 //////////////////////////////////////////////////
-void OgreInertiaVisual::Load(const ignition::math::Pose3d &_pose,
-                             const ignition::math::Vector3d &_scale)
+void OgreInertiaVisual::Load(const gz::math::Pose3d &_pose,
+                             const gz::math::Vector3d &_scale)
 {
   if (!this->dataPtr->crossLines)
   {
@@ -88,12 +88,12 @@ void OgreInertiaVisual::Load(const ignition::math::Pose3d &_pose,
   }
 
   // Inertia position indicator
-  ignition::math::Vector3d p1(0, 0, -2*_scale.Z());
-  ignition::math::Vector3d p2(0, 0, 2*_scale.Z());
-  ignition::math::Vector3d p3(0, -2*_scale.Y(), 0);
-  ignition::math::Vector3d p4(0, 2*_scale.Y(), 0);
-  ignition::math::Vector3d p5(-2*_scale.X(), 0, 0);
-  ignition::math::Vector3d p6(2*_scale.X(), 0, 0);
+  gz::math::Vector3d p1(0, 0, -2*_scale.Z());
+  gz::math::Vector3d p2(0, 0, 2*_scale.Z());
+  gz::math::Vector3d p3(0, -2*_scale.Y(), 0);
+  gz::math::Vector3d p4(0, 2*_scale.Y(), 0);
+  gz::math::Vector3d p5(-2*_scale.X(), 0, 0);
+  gz::math::Vector3d p6(2*_scale.X(), 0, 0);
   p1 = _pose.Rot().RotateVector(p1);
   p2 = _pose.Rot().RotateVector(p2);
   p3 = _pose.Rot().RotateVector(p3);
@@ -138,7 +138,7 @@ void OgreInertiaVisual::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/OgreJointVisual.cc b/ogre/src/OgreJointVisual.cc
index 981fa8e35..c6a3f6245 100644
--- a/ogre/src/OgreJointVisual.cc
+++ b/ogre/src/OgreJointVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreJointVisual.hh"
+#include "gz/rendering/ogre/OgreJointVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreLidarVisual.cc b/ogre/src/OgreLidarVisual.cc
index 62c6b3800..f523da9bf 100644
--- a/ogre/src/OgreLidarVisual.cc
+++ b/ogre/src/OgreLidarVisual.cc
@@ -15,15 +15,15 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
-#include "ignition/rendering/ogre/OgreLidarVisual.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreMarker.hh"
-#include "ignition/rendering/ogre/OgreGeometry.hh"
+#include <gz/common/Console.hh>
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/rendering/ogre/OgreLidarVisual.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreMarker.hh"
+#include "gz/rendering/ogre/OgreGeometry.hh"
 
 
-class ignition::rendering::OgreLidarVisualPrivate
+class gz::rendering::OgreLidarVisualPrivate
 {
   /// \brief Non Hitting DynamicLines Object to display
   public: std::vector<std::shared_ptr<OgreDynamicLines>> noHitRayStrips;
@@ -51,7 +51,7 @@ class ignition::rendering::OgreLidarVisualPrivate
   public: std::vector<double> lidarPoints;
 
   /// \brief The colour of rendered points
-  public: std::vector<ignition::math::Color> pointColors;
+  public: std::vector<gz::math::Color> pointColors;
 
   /// \brief True if new points data is received
   public: bool receivedData = false;
@@ -60,7 +60,7 @@ class ignition::rendering::OgreLidarVisualPrivate
   public: bool visible = true;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -158,18 +158,18 @@ void OgreLidarVisual::SetPoints(const std::vector<double> &_points)
   this->dataPtr->pointColors.clear();
   for (unsigned int i = 0u; i < this->dataPtr->lidarPoints.size(); ++i)
   {
-    this->dataPtr->pointColors.push_back(ignition::math::Color::Blue);
+    this->dataPtr->pointColors.push_back(gz::math::Color::Blue);
   }
   this->dataPtr->receivedData = true;
 }
 
 //////////////////////////////////////////////////
 void OgreLidarVisual::SetPoints(const std::vector<double> &_points,
-                        const std::vector<ignition::math::Color> &_colors)
+                        const std::vector<gz::math::Color> &_colors)
 {
   if (_points.size() != _colors.size())
   {
-    ignerr << "Unequal size of point and color vector."
+    gzerr << "Unequal size of point and color vector."
            << "Setting all point colors blue." << std::endl;
     this->SetPoints(_points);
   }
@@ -189,7 +189,7 @@ void OgreLidarVisual::Update()
 
   if (!this->dataPtr->receivedData || this->dataPtr->lidarPoints.size() == 0)
   {
-    ignwarn << "New lidar data not received. Exiting update function"
+    gzwarn << "New lidar data not received. Exiting update function"
             << std::endl;
     return;
   }
@@ -236,7 +236,7 @@ void OgreLidarVisual::Update()
   if (this->dataPtr->lidarPoints.size() !=
                   this->verticalCount * this->horizontalCount)
   {
-    ignwarn << "Size of lidar data inconsistent with rays."
+    gzwarn << "Size of lidar data inconsistent with rays."
             << " Exiting update function."
             << std::endl;
     return;
@@ -314,7 +314,7 @@ void OgreLidarVisual::Update()
           this->Node()->attachObject(mv.get());
           this->dataPtr->deadZoneRayFans.push_back(line);
           this->dataPtr->deadZoneRayFans[j]->AddPoint(
-                      ignition::math::Vector3d::Zero);
+                      gz::math::Vector3d::Zero);
 
           line = std::shared_ptr<OgreDynamicLines>(
                       new OgreDynamicLines(MT_TRIANGLE_STRIP));
@@ -365,28 +365,28 @@ void OgreLidarVisual::Update()
       double r = this->dataPtr->lidarPoints[ j * this->horizontalCount + i];
 
       bool inf = (std::isinf(r) || r >= this->maxRange);
-      ignition::math::Quaterniond ray(
-        ignition::math::Vector3d(0.0, -verticalAngle, horizontalAngle));
+      gz::math::Quaterniond ray(
+        gz::math::Vector3d(0.0, -verticalAngle, horizontalAngle));
 
-      ignition::math::Vector3d axis = this->offset.Rot() * ray *
-        ignition::math::Vector3d(1.0, 0.0, 0.0);
+      gz::math::Vector3d axis = this->offset.Rot() * ray *
+        gz::math::Vector3d(1.0, 0.0, 0.0);
 
       // Check for infinite range, which indicates the ray did not
       // intersect an object.
       double hitRange = inf ? 0 : r;
 
       // Compute the start point of the ray
-      ignition::math::Vector3d startPt =
+      gz::math::Vector3d startPt =
                   (axis * this->minRange) + this->offset.Pos();
 
       // Compute the end point of the ray
-      ignition::math::Vector3d pt =
+      gz::math::Vector3d pt =
                   (axis * hitRange) + this->offset.Pos();
 
       double noHitRange = inf ? this->maxRange : hitRange;
 
       // Compute the end point of the no-hit ray
-      ignition::math::Vector3d noHitPt =
+      gz::math::Vector3d noHitPt =
                   (axis * noHitRange) + this->offset.Pos();
 
       // Update the lines and strips that represent each simulated ray.
diff --git a/ogre/src/OgreLight.cc b/ogre/src/OgreLight.cc
index 8c899e04a..c4d172082 100644
--- a/ogre/src/OgreLight.cc
+++ b/ogre/src/OgreLight.cc
@@ -15,15 +15,15 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreLight.hh"
+#include "gz/rendering/ogre/OgreLight.hh"
 
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -179,7 +179,7 @@ void OgreLight::CreateLight()
   }
   catch (Ogre::Exception &ex)
   {
-    ignerr << "Unabled to create light: " << ex.getFullDescription() <<
+    gzerr << "Unabled to create light: " << ex.getFullDescription() <<
         std::endl;
   }
 }
diff --git a/ogre/src/OgreLightVisual.cc b/ogre/src/OgreLightVisual.cc
index cfc5420c8..642fc53ac 100644
--- a/ogre/src/OgreLightVisual.cc
+++ b/ogre/src/OgreLightVisual.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include "ignition/rendering/ogre/OgreLightVisual.hh"
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/rendering/ogre/OgreLightVisual.hh"
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
 
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-class ignition::rendering::OgreLightVisualPrivate
+class gz::rendering::OgreLightVisualPrivate
 {
   /// \brief Grid materal
   public: OgreMaterialPtr material = nullptr;
@@ -28,7 +28,7 @@ class ignition::rendering::OgreLightVisualPrivate
   std::shared_ptr<OgreDynamicLines> line = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -79,7 +79,7 @@ void OgreLightVisual::CreateVisual()
       this->Scene()->Material("Default/TransGreen");
     this->SetMaterial(lightVisualMaterial, false);
   }
-  std::vector<ignition::math::Vector3d> positions = this->CreateVisualLines();
+  std::vector<gz::math::Vector3d> positions = this->CreateVisualLines();
 
   for (const auto &p : positions)
   {
@@ -99,7 +99,7 @@ void OgreLightVisual::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/OgreMarker.cc b/ogre/src/OgreMarker.cc
index e08f22952..e42526f83 100644
--- a/ogre/src/OgreMarker.cc
+++ b/ogre/src/OgreMarker.cc
@@ -15,16 +15,16 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreCapsule.hh"
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
-#include "ignition/rendering/ogre/OgreMarker.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreMesh.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreCapsule.hh"
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/rendering/ogre/OgreMarker.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreMesh.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-class ignition::rendering::OgreMarkerPrivate
+class gz::rendering::OgreMarkerPrivate
 {
   /// \brief Marker material
   public: OgreMaterialPtr material = nullptr;
@@ -36,7 +36,7 @@ class ignition::rendering::OgreMarkerPrivate
   public: OgreGeometryPtr geom{nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -125,7 +125,7 @@ Ogre::MovableObject *OgreMarker::OgreObject() const
       return std::dynamic_pointer_cast<Ogre::MovableObject>
         (this->dataPtr->dynamicRenderable).get();
     default:
-      ignerr << "Invalid Marker type " << this->markerType << "\n";
+      gzerr << "Invalid Marker type " << this->markerType << "\n";
       return nullptr;
   }
 }
@@ -154,7 +154,7 @@ void OgreMarker::SetMaterial(MaterialPtr _material, bool _unique)
 {
   if (nullptr == _material)
   {
-    ignerr << "Cannot assign null material" << std::endl;
+    gzerr << "Cannot assign null material" << std::endl;
     return;
   }
 
@@ -165,7 +165,7 @@ void OgreMarker::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
       << std::endl;
 
     return;
@@ -193,7 +193,7 @@ void OgreMarker::SetMaterial(MaterialPtr _material, bool _unique)
       }
       else
       {
-        ignerr << "Failed to set material, null geometry." << std::endl;
+        gzerr << "Failed to set material, null geometry." << std::endl;
       }
       break;
     }
@@ -210,7 +210,7 @@ void OgreMarker::SetMaterial(MaterialPtr _material, bool _unique)
 #endif
       break;
     default:
-      ignerr << "Invalid Marker type " << this->markerType << "\n";
+      gzerr << "Invalid Marker type " << this->markerType << "\n";
       break;
   }
 }
@@ -223,14 +223,14 @@ MaterialPtr OgreMarker::Material() const
 
 //////////////////////////////////////////////////
 void OgreMarker::SetPoint(unsigned int _index,
-    const ignition::math::Vector3d &_value)
+    const gz::math::Vector3d &_value)
 {
   this->dataPtr->dynamicRenderable->SetPoint(_index, _value);
 }
 
 //////////////////////////////////////////////////
-void OgreMarker::AddPoint(const ignition::math::Vector3d &_pt,
-    const ignition::math::Color &_color)
+void OgreMarker::AddPoint(const gz::math::Vector3d &_pt,
+    const gz::math::Color &_color)
 {
   this->dataPtr->dynamicRenderable->AddPoint(_pt, _color);
 }
@@ -274,7 +274,7 @@ void OgreMarker::SetType(MarkerType _markerType)
       this->dataPtr->dynamicRenderable->SetOperationType(_markerType);
       break;
     default:
-      ignerr << "Invalid Marker type\n";
+      gzerr << "Invalid Marker type\n";
       break;
   }
 }
diff --git a/ogre/src/OgreMaterial.cc b/ogre/src/OgreMaterial.cc
index fafa31891..096c6aa88 100644
--- a/ogre/src/OgreMaterial.cc
+++ b/ogre/src/OgreMaterial.cc
@@ -15,17 +15,17 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
 
-#include "ignition/rendering/ShaderParams.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ShaderParams.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -430,7 +430,7 @@ void OgreMaterial::SetVertexShader(const std::string &_path)
 
   if (!common::exists(_path))
   {
-    ignerr << "Vertex shader path does not exist: " << _path << std::endl;
+    gzerr << "Vertex shader path does not exist: " << _path << std::endl;
     return;
   }
 
@@ -479,7 +479,7 @@ void OgreMaterial::SetFragmentShader(const std::string &_path)
 
   if (!common::exists(_path))
   {
-    ignerr << "Fragment shader path does not exist: " << _path << std::endl;
+    gzerr << "Fragment shader path does not exist: " << _path << std::endl;
     return;
   }
 
@@ -548,12 +548,12 @@ void OgreMaterial::LoadOneImage(const std::string &_name, Ogre::Image &_image)
         _image.load(path, this->ogreGroup);
       }
       else
-        ignerr << "Unable to find texture image: " << _name << std::endl;
+        gzerr << "Unable to find texture image: " << _name << std::endl;
     }
   }
   catch (const Ogre::Exception &ex)
   {
-    ignerr << "Unable to load texture image: " << ex.what() << std::endl;
+    gzerr << "Unable to load texture image: " << ex.what() << std::endl;
   }
 }
 
@@ -660,9 +660,10 @@ void OgreMaterial::SetDepthMaterial(const double _far,
 
   // TODO(anyone): convert depth configuration into a ShaderType
   // Get shader parameters path
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
 
   // path to look for vertex and fragment shader parameters
   std::string depth_vertex_shader_path = common::joinPaths(
diff --git a/ogre/src/OgreMaterialSwitcher.cc b/ogre/src/OgreMaterialSwitcher.cc
index a75fd1768..f929503f5 100644
--- a/ogre/src/OgreMaterialSwitcher.cc
+++ b/ogre/src/OgreMaterialSwitcher.cc
@@ -15,12 +15,12 @@
  *
 */
 
-#include "ignition/common/Console.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreMaterialSwitcher.hh"
-#include "ignition/rendering/RenderTypes.hh"
+#include "gz/common/Console.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreMaterialSwitcher.hh"
+#include "gz/rendering/RenderTypes.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 
@@ -28,7 +28,7 @@ using namespace rendering;
 OgreMaterialSwitcher::OgreMaterialSwitcher()
   : lastTechnique(nullptr)
 {
-  this->currentColor = ignition::math::Color(0.0f, 0.0f, 0.1f);
+  this->currentColor = gz::math::Color(0.0f, 0.0f, 0.1f);
 }
 
 /////////////////////////////////////////////////
@@ -98,7 +98,7 @@ Ogre::Technique *OgreMaterialSwitcher::handleSchemeNotFound(
           overlayMaterial->getTechnique(0);
       if (!this->overlayTechnique || !this->overlayTechnique->getPass(0))
       {
-        ignerr << "Problem creating the selection buffer overlay material"
+        gzerr << "Problem creating the selection buffer overlay material"
             << std::endl;
         return nullptr;
       }
@@ -157,7 +157,7 @@ void OgreMaterialSwitcher::postRenderTargetUpdate(
 
 /////////////////////////////////////////////////
 std::string OgreMaterialSwitcher::EntityName(
-    const ignition::math::Color &_color) const
+    const gz::math::Color &_color) const
 {
   auto iter = this->colorDict.find(_color.AsRGBA());
 
@@ -178,7 +178,7 @@ void OgreMaterialSwitcher::NextColor()
 /////////////////////////////////////////////////
 void OgreMaterialSwitcher::Reset()
 {
-  this->currentColor = ignition::math::Color(0.0, 0.0, 0.0);
+  this->currentColor = gz::math::Color(0.0, 0.0, 0.0);
   this->lastTechnique = nullptr;
   this->lastEntity.clear();
   this->colorDict.clear();
diff --git a/ogre/src/OgreMesh.cc b/ogre/src/OgreMesh.cc
index 42910140a..cb7f11335 100644
--- a/ogre/src/OgreMesh.cc
+++ b/ogre/src/OgreMesh.cc
@@ -15,22 +15,22 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreMesh.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreStorage.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreMesh.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreStorage.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
 
 
 /// brief Private implementation of the OgreMesh class
-class ignition::rendering::OgreMeshPrivate
+class gz::rendering::OgreMeshPrivate
 {
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -92,7 +92,7 @@ bool OgreMesh::HasSkeleton() const
 std::map<std::string, math::Matrix4d>
         OgreMesh::SkeletonLocalTransforms() const
 {
-  std::map<std::string, ignition::math::Matrix4d> mapTfs;
+  std::map<std::string, gz::math::Matrix4d> mapTfs;
   if (this->ogreEntity->hasSkeleton())
   {
     Ogre::SkeletonInstance *skel = this->ogreEntity->getSkeleton();
@@ -102,10 +102,10 @@ std::map<std::string, math::Matrix4d>
       Ogre::Quaternion quat(bone->getOrientation());
       Ogre::Vector3 p(bone->getPosition());
 
-      ignition::math::Quaterniond tfQuat(quat.w, quat.x, quat.y, quat.z);
-      ignition::math::Vector3d tfTrans(p.x, p.y, p.z);
+      gz::math::Quaterniond tfQuat(quat.w, quat.x, quat.y, quat.z);
+      gz::math::Vector3d tfTrans(p.x, p.y, p.z);
 
-      ignition::math::Matrix4d tf(tfQuat);
+      gz::math::Matrix4d tf(tfQuat);
       tf.SetTranslation(tfTrans);
 
       mapTfs[bone->getName()] = tf;
@@ -144,7 +144,7 @@ void OgreMesh::SetSkeletonAnimationEnabled(const std::string &_name,
 {
   if (!this->ogreEntity->hasAnimationState(_name))
   {
-    ignerr << "Skeleton animation name not found: " << _name << std::endl;
+    gzerr << "Skeleton animation name not found: " << _name << std::endl;
     return;
   }
 
@@ -235,7 +235,7 @@ bool OgreMesh::SkeletonAnimationEnabled(const std::string &_name) const
 {
   if (!this->ogreEntity->hasAnimationState(_name))
   {
-    ignerr << "Skeleton animation name not found: " << _name << std::endl;
+    gzerr << "Skeleton animation name not found: " << _name << std::endl;
     return false;
   }
 
@@ -322,7 +322,7 @@ void OgreSubMesh::SetMaterialImpl(MaterialPtr _material)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/OgreMeshFactory.cc b/ogre/src/OgreMeshFactory.cc
index 431e3c832..95540ecb0 100644
--- a/ogre/src/OgreMeshFactory.cc
+++ b/ogre/src/OgreMeshFactory.cc
@@ -18,24 +18,24 @@
 
 #include <sstream>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Material.hh>
-#include <ignition/common/MeshManager.hh>
-#include <ignition/common/Skeleton.hh>
-#include <ignition/common/SkeletonAnimation.hh>
-#include <ignition/common/SubMesh.hh>
-
-#include <ignition/math/Matrix4.hh>
-
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreMesh.hh"
-#include "ignition/rendering/ogre/OgreMeshFactory.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreStorage.hh"
-
-using namespace ignition;
+#include <gz/common/Console.hh>
+#include <gz/common/Material.hh>
+#include <gz/common/MeshManager.hh>
+#include <gz/common/Skeleton.hh>
+#include <gz/common/SkeletonAnimation.hh>
+#include <gz/common/SubMesh.hh>
+
+#include <gz/math/Matrix4.hh>
+
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreMesh.hh"
+#include "gz/rendering/ogre/OgreMeshFactory.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreStorage.hh"
+
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -267,7 +267,7 @@ bool OgreMeshFactory::LoadImpl(const MeshDescriptor &_desc)
       else if (subMesh.SubMeshPrimitiveType() == common::SubMesh::POINTS)
         ogreSubMesh->operationType = Ogre::RenderOperation::OT_POINT_LIST;
       else
-        ignerr << "Unknown primitive type["
+        gzerr << "Unknown primitive type["
               << subMesh.SubMeshPrimitiveType() << "]\n";
 
       ogreSubMesh->vertexData = new Ogre::VertexData();
@@ -448,13 +448,13 @@ bool OgreMeshFactory::LoadImpl(const MeshDescriptor &_desc)
 
     if (!max.IsFinite())
     {
-      ignerr << "Max bounding box is not finite[" << max << "]" << std::endl;
+      gzerr << "Max bounding box is not finite[" << max << "]" << std::endl;
       return false;
     }
 
     if (!min.IsFinite())
     {
-      ignerr << "Min bounding box is not finite[" << min << "]" << std::endl;
+      gzerr << "Min bounding box is not finite[" << min << "]" << std::endl;
       return false;
     }
 
@@ -468,7 +468,7 @@ bool OgreMeshFactory::LoadImpl(const MeshDescriptor &_desc)
   }
   catch(Ogre::Exception &e)
   {
-    ignerr << "Unable to insert mesh[" << e.getDescription() << "]"
+    gzerr << "Unable to insert mesh[" << e.getDescription() << "]"
         << std::endl;
     return false;
   }
@@ -479,7 +479,7 @@ bool OgreMeshFactory::LoadImpl(const MeshDescriptor &_desc)
     if (!_desc.subMeshName.empty())
       msg += ", submesh: '" + _desc.subMeshName + "'";
     msg += ". Mesh will be empty.";
-    ignwarn << msg << std::endl;
+    gzwarn << msg << std::endl;
   }
 
   return true;
@@ -500,19 +500,19 @@ bool OgreMeshFactory::Validate(const MeshDescriptor &_desc)
 {
   if (!_desc.mesh && _desc.meshName.empty())
   {
-    ignerr << "Invalid mesh-descriptor, no mesh specified" << std::endl;
+    gzerr << "Invalid mesh-descriptor, no mesh specified" << std::endl;
     return false;
   }
 
   if (!_desc.mesh)
   {
-    ignerr << "Cannot load null mesh" << std::endl;
+    gzerr << "Cannot load null mesh" << std::endl;
     return false;
   }
 
   if (_desc.mesh->SubMeshCount() == 0)
   {
-    ignerr << "Cannot load mesh with zero sub-meshes" << std::endl;
+    gzerr << "Cannot load mesh with zero sub-meshes" << std::endl;
     return false;
   }
 
diff --git a/ogre/src/OgreNode.cc b/ogre/src/OgreNode.cc
index 0040201e8..fc415e590 100644
--- a/ogre/src/OgreNode.cc
+++ b/ogre/src/OgreNode.cc
@@ -15,15 +15,15 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreNode.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreStorage.hh"
+#include "gz/rendering/ogre/OgreNode.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreStorage.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -136,21 +136,21 @@ void OgreNode::Init()
 {
   if (nullptr == this->scene)
   {
-    ignerr << "Failed to initialize node: scene is NULL" << std::endl;
+    gzerr << "Failed to initialize node: scene is NULL" << std::endl;
     return;
   }
 
   auto sceneManager = this->scene->OgreSceneManager();
   if (nullptr == sceneManager)
   {
-    ignerr << "Failed to initialize node: scene manager is NULL" << std::endl;
+    gzerr << "Failed to initialize node: scene manager is NULL" << std::endl;
     return;
   }
 
   this->ogreNode = sceneManager->createSceneNode(this->name);
   if (nullptr == this->ogreNode)
   {
-    ignerr << "Failed to create Ogre node" << std::endl;
+    gzerr << "Failed to create Ogre node" << std::endl;
     return;
   }
   this->ogreNode->setInheritScale(true);
@@ -173,7 +173,7 @@ bool OgreNode::AttachChild(NodePtr _child)
 
   if (!derived)
   {
-    ignerr << "Cannot attach node created by another render-engine"
+    gzerr << "Cannot attach node created by another render-engine"
         << std::endl;
     return false;
   }
@@ -193,7 +193,7 @@ bool OgreNode::DetachChild(NodePtr _child)
 
   if (!derived)
   {
-    ignerr << "Cannot detach node created by another render-engine"
+    gzerr << "Cannot detach node created by another render-engine"
         << std::endl;
     return false;
   }
diff --git a/ogre/src/OgreObject.cc b/ogre/src/OgreObject.cc
index 2b2fed8b7..c543ea6cf 100644
--- a/ogre/src/OgreObject.cc
+++ b/ogre/src/OgreObject.cc
@@ -14,11 +14,11 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreObject.hh"
+#include "gz/rendering/ogre/OgreObject.hh"
 
-#include "ignition/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreObjectInterface.cc b/ogre/src/OgreObjectInterface.cc
index f1dea5605..1bf6d683e 100644
--- a/ogre/src/OgreObjectInterface.cc
+++ b/ogre/src/OgreObjectInterface.cc
@@ -15,9 +15,9 @@
  *
  */
 
-#include "ignition/rendering/ogre/OgreObjectInterface.hh"
+#include "gz/rendering/ogre/OgreObjectInterface.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreParticleEmitter.cc b/ogre/src/OgreParticleEmitter.cc
index 61a8e7471..b2c1759b5 100644
--- a/ogre/src/OgreParticleEmitter.cc
+++ b/ogre/src/OgreParticleEmitter.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreParticleEmitter.hh"
+#include "gz/rendering/ogre/OgreParticleEmitter.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreRTShaderSystem.cc b/ogre/src/OgreRTShaderSystem.cc
index a3094683d..a8f24606e 100644
--- a/ogre/src/OgreRTShaderSystem.cc
+++ b/ogre/src/OgreRTShaderSystem.cc
@@ -24,18 +24,18 @@
 #include <set>
 #include <vector>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Util.hh>
-
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreMesh.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-
-class ignition::rendering::OgreRTShaderSystemPrivate
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Util.hh>
+
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreMesh.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+
+class gz::rendering::OgreRTShaderSystemPrivate
 {
   /// \brief The shader generator.
   public: Ogre::RTShader::ShaderGenerator *shaderGenerator = nullptr;
@@ -75,7 +75,7 @@ class ignition::rendering::OgreRTShaderSystemPrivate
   public: std::thread::id threadId;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -117,7 +117,7 @@ bool OgreRTShaderSystem::Init()
     std::string coreLibsPath, cachePath;
     if (!this->Paths(coreLibsPath, cachePath))
     {
-      ignerr << "Cannot find OGRE rtshaderlib. "
+      gzerr << "Cannot find OGRE rtshaderlib. "
              << "Shadows will be disabled." << std::endl;
       return false;
     }
@@ -138,7 +138,7 @@ bool OgreRTShaderSystem::Init()
   }
   else
   {
-    ignerr << "RT Shader system failed to initialize" << std::endl;
+    gzerr << "RT Shader system failed to initialize" << std::endl;
     return false;
   }
   return false;
@@ -353,7 +353,7 @@ void OgreRTShaderSystem::RemoveShaders(OgreSubMesh *_subMesh)
     }
     catch(Ogre::Exception &e)
     {
-      ignerr << "Unable to remove shader technique for material["
+      gzerr << "Unable to remove shader technique for material["
         << curMaterialName << "]\n";
     }
   }
@@ -399,7 +399,7 @@ void OgreRTShaderSystem::GenerateShaders(OgreSubMesh *subMesh)
     }
     catch(Ogre::Exception &e)
     {
-      ignerr << "Unable to create shader technique for material["
+      gzerr << "Unable to create shader technique for material["
         << curMaterialName << "]\n";
       success = false;
     }
@@ -485,9 +485,10 @@ void OgreRTShaderSystem::GenerateShaders(OgreSubMesh *subMesh)
 bool OgreRTShaderSystem::Paths(std::string &coreLibsPath,
     std::string &cachePath)
 {
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
 
   // path to look for ogre media files
   std::vector<std::string> paths;
@@ -522,7 +523,7 @@ bool OgreRTShaderSystem::Paths(std::string &coreLibsPath,
       // Create the directory
       if (!common::createDirectories(cachePath))
       {
-        ignerr << "Unable to create ogre RTShader cache directories: "
+        gzerr << "Unable to create ogre RTShader cache directories: "
             << cachePath << std::endl;
       }
       break;
@@ -532,7 +533,7 @@ bool OgreRTShaderSystem::Paths(std::string &coreLibsPath,
   // Core shader lib not found -> shader generating will fail.
   if (coreLibsPath.empty())
   {
-    ignerr << "Unable to find shader lib. Shader generating will fail."
+    gzerr << "Unable to find shader lib. Shader generating will fail."
       << std::endl;
     return false;
   }
@@ -716,9 +717,9 @@ void OgreRTShaderSystem::Update()
 bool OgreRTShaderSystem::SetShadowTextureSize(const unsigned int _size)
 {
   // check if texture size is a power of 2
-  if (!ignition::math::isPowerOfTwo(_size))
+  if (!gz::math::isPowerOfTwo(_size))
   {
-    ignerr << "Shadow texture size must be a power of 2" << std::endl;
+    gzerr << "Shadow texture size must be a power of 2" << std::endl;
     return false;
   }
 
diff --git a/ogre/src/OgreRayQuery.cc b/ogre/src/OgreRayQuery.cc
index 34e5cf4d4..589f90666 100644
--- a/ogre/src/OgreRayQuery.cc
+++ b/ogre/src/OgreRayQuery.cc
@@ -17,24 +17,24 @@
 
 #include <typeinfo>
 
-#include <ignition/common/Console.hh>
-
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreCamera.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreDepthCamera.hh"
-#include "ignition/rendering/ogre/OgreObjectInterface.hh"
-#include "ignition/rendering/ogre/OgreRayQuery.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreThermalCamera.hh"
-
-class ignition::rendering::OgreRayQueryPrivate
+#include <gz/common/Console.hh>
+
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreCamera.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreDepthCamera.hh"
+#include "gz/rendering/ogre/OgreObjectInterface.hh"
+#include "gz/rendering/ogre/OgreRayQuery.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreThermalCamera.hh"
+
+class gz::rendering::OgreRayQueryPrivate
 {
   /// \brief Ogre ray scene query object for computing intersection.
   public: Ogre::RaySceneQuery *rayQuery = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -59,7 +59,7 @@ void OgreRayQuery::SetFromCamera(const CameraPtr &_camera,
       std::dynamic_pointer_cast<OgreObjectInterface>(_camera);
   if (!ogreObjectInterface)
   {
-    ignwarn << "Camera does not support ray query\n";
+    gzwarn << "Camera does not support ray query\n";
     return;
   }
 
@@ -242,7 +242,7 @@ void OgreRayQuery::MeshInformation(const Ogre::Mesh *_mesh,
            ++j, vertex += vbuf->getVertexSize())
      {
         posElem->baseVertexPointerToElement(vertex, &pReal);
-        ignition::math::Vector3d pt(pReal[0], pReal[1], pReal[2]);
+        gz::math::Vector3d pt(pReal[0], pReal[1], pReal[2]);
         _vertices[current_offset + j] =
             OgreConversions::Convert((_orient * (pt * _scale)) + _position);
       }
diff --git a/ogre/src/OgreRenderEngine.cc b/ogre/src/OgreRenderEngine.cc
index c3ddefd3d..bfad6f885 100644
--- a/ogre/src/OgreRenderEngine.cc
+++ b/ogre/src/OgreRenderEngine.cc
@@ -30,21 +30,21 @@
 
 # include <sstream>
 
-#include <ignition/plugin/Register.hh>
+#include <gz/plugin/Register.hh>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Util.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Util.hh>
 
-#include "ignition/rendering/RenderEngineManager.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreRenderTypes.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreStorage.hh"
+#include "gz/rendering/RenderEngineManager.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreRenderTypes.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreStorage.hh"
 
-class ignition::rendering::OgreRenderEnginePrivate
+class gz::rendering::OgreRenderEnginePrivate
 {
 #if !defined(__APPLE__) && !defined(_WIN32)
   public: XVisualInfo *dummyVisual = nullptr;
@@ -54,7 +54,7 @@ class ignition::rendering::OgreRenderEnginePrivate
   public: std::vector<unsigned int> fsaaLevels;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -167,7 +167,7 @@ void OgreRenderEngine::AddResourcePath(const std::string &_uri)
 
   if (path.empty())
   {
-    ignerr << "URI doesn't exist[" << _uri << "]\n";
+    gzerr << "URI doesn't exist[" << _uri << "]\n";
     return;
   }
 
@@ -230,7 +230,7 @@ void OgreRenderEngine::AddResourcePath(const std::string &_uri)
             }
             catch(Ogre::Exception& e)
             {
-              ignerr << "Unable to parse material file[" << fullPath << "]\n";
+              gzerr << "Unable to parse material file[" << fullPath << "]\n";
             }
             stream->close();
           }
@@ -240,7 +240,7 @@ void OgreRenderEngine::AddResourcePath(const std::string &_uri)
   }
   catch(Ogre::Exception &/*_e*/)
   {
-    ignerr << "Unable to load Ogre Resources.\nMake sure the"
+    gzerr << "Unable to load Ogre Resources.\nMake sure the"
         "resources path in the world file is set correctly." << std::endl;
   }
 }
@@ -288,12 +288,12 @@ bool OgreRenderEngine::LoadImpl(
   }
   catch (Ogre::Exception &ex)
   {
-    ignerr << ex.what() << std::endl;
+    gzerr << ex.what() << std::endl;
     return false;
   }
   catch (...)
   {
-    ignerr << "Failed to load render-engine" << std::endl;
+    gzerr << "Failed to load render-engine" << std::endl;
     return false;
   }
 }
@@ -308,7 +308,7 @@ bool OgreRenderEngine::InitImpl()
   }
   catch (...)
   {
-    ignerr << "Failed to initialize render-engine" << std::endl;
+    gzerr << "Failed to initialize render-engine" << std::endl;
     return false;
   }
 }
@@ -334,7 +334,7 @@ void OgreRenderEngine::CreateLogger()
 {
   // create log file path
   std::string logPath;
-  ignition::common::env(IGN_HOMEDIR, logPath);
+  gz::common::env(IGN_HOMEDIR, logPath);
   logPath = common::joinPaths(logPath, ".ignition", "rendering");
   common::createDirectories(logPath);
   logPath = common::joinPaths(logPath, "ogre.log");
@@ -354,7 +354,7 @@ void OgreRenderEngine::CreateContext()
 
   if (!this->dummyDisplay)
   {
-    ignerr << "Unable to open display: " << XDisplayName(0) << std::endl;
+    gzerr << "Unable to open display: " << XDisplayName(0) << std::endl;
     return;
   }
 
@@ -369,7 +369,7 @@ void OgreRenderEngine::CreateContext()
 
   if (!this->dataPtr->dummyVisual)
   {
-    ignerr << "Unable to create glx visual" << std::endl;
+    gzerr << "Unable to create glx visual" << std::endl;
     return;
   }
 
@@ -384,7 +384,7 @@ void OgreRenderEngine::CreateContext()
 
   if (!this->dummyContext)
   {
-    ignerr << "Unable to create glx context" << std::endl;
+    gzerr << "Unable to create glx context" << std::endl;
     return;
   }
 
@@ -402,7 +402,7 @@ void OgreRenderEngine::CreateRoot()
   }
   catch (Ogre::Exception &ex)
   {
-    ignerr << "Unable to create Ogre root" << std::endl;
+    gzerr << "Unable to create Ogre root" << std::endl;
   }
 }
 
@@ -465,7 +465,7 @@ void OgreRenderEngine::LoadPlugins()
         {
           if ((*piter).find("RenderSystem") != std::string::npos)
           {
-            ignerr << "Unable to load Ogre Plugin[" << *piter
+            gzerr << "Unable to load Ogre Plugin[" << *piter
                   << "]. Rendering will not be possible."
                   << "Make sure you have installed OGRE properly.\n";
           }
@@ -508,7 +508,7 @@ void OgreRenderEngine::CreateRenderSystem()
 
   if (renderSys == nullptr)
   {
-    ignerr << "unable to find OpenGL rendering system. OGRE is probably "
+    gzerr << "unable to find OpenGL rendering system. OGRE is probably "
             "installed incorrectly. Double check the OGRE cmake output, "
             "and make sure OpenGL is enabled." << std::endl;
   }
@@ -566,9 +566,10 @@ void OgreRenderEngine::CreateResources()
 
   // TODO(anyone) support loading resources from user specified paths
   std::list<std::string> paths;
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
   // install path
   std::string mediaPath = common::joinPaths(resourcePath, "ogre", "media");
   paths.push_back(mediaPath);
@@ -606,7 +607,7 @@ void OgreRenderEngine::CreateResources()
     }
     catch(Ogre::Exception &/*_e*/)
     {
-      ignerr << "Unable to load Ogre Resources. Make sure the resources "
+      gzerr << "Unable to load Ogre Resources. Make sure the resources "
           "path in the world file is set correctly." << std::endl;
     }
   }
@@ -620,7 +621,7 @@ void OgreRenderEngine::CreateRenderWindow()
       1, 0);
   if (res.empty())
   {
-    ignerr << "Failed to create dummy render window." << std::endl;
+    gzerr << "Failed to create dummy render window." << std::endl;
   }
 }
 
@@ -677,7 +678,7 @@ std::string OgreRenderEngine::CreateRenderWindow(const std::string &_handle,
     }
     catch(Ogre::Exception &_e)
     {
-      ignerr << "Unable to create the rendering window. Attempt [" << attempts
+      gzerr << "Unable to create the rendering window. Attempt [" << attempts
              << "]. Exception [" << _e.what() << "]" << std::endl;
       window = nullptr;
     }
@@ -686,7 +687,7 @@ std::string OgreRenderEngine::CreateRenderWindow(const std::string &_handle,
 
   if (attempts >= 10)
   {
-    ignerr << "Unable to create the rendering window after [" << attempts
+    gzerr << "Unable to create the rendering window after [" << attempts
            << "] attempts." << std::endl;
     return std::string();
   }
@@ -708,7 +709,7 @@ void OgreRenderEngine::CheckCapabilities()
 {
   if (nullptr == this->ogreRoot ||nullptr == this->ogreRoot->getRenderSystem())
   {
-    ignerr << "No ogreRoot or render system" << std::endl;
+    gzerr << "No ogreRoot or render system" << std::endl;
     return;
   }
 
@@ -719,7 +720,7 @@ void OgreRenderEngine::CheckCapabilities()
   capabilities = this->ogreRoot->getRenderSystem()->getCapabilities();
   if (nullptr == capabilities)
   {
-    ignerr << "Failed to get capabilities" << std::endl;
+    gzerr << "Failed to get capabilities" << std::endl;
     return;
   }
 
@@ -745,20 +746,20 @@ void OgreRenderEngine::CheckCapabilities()
 
   if (!hasFragmentPrograms || !hasVertexPrograms)
   {
-    ignwarn << "Vertex and fragment shaders are missing. "
+    gzwarn << "Vertex and fragment shaders are missing. "
            << "Fixed function rendering will be used.\n";
   }
 
   if (!hasGLSL)
   {
-    ignwarn << "GLSL is missing."
+    gzwarn << "GLSL is missing."
            << "Fixed function rendering will be used.\n";
   }
 
   // cppcheck-suppress knownConditionTrueFalse
   if (!hasFBO)
   {
-    ignwarn << "Frame Buffer Objects (FBO) is missing. "
+    gzwarn << "Frame Buffer Objects (FBO) is missing. "
            << "Rendering will be disabled.\n";
   }
 
@@ -779,7 +780,7 @@ void OgreRenderEngine::InitAttempt()
 {
   if (this->renderPathType == NONE)
   {
-    ignwarn << "Cannot initialize render engine since "
+    gzwarn << "Cannot initialize render engine since "
            << "render path type is NONE. Ignore this warning if"
            << "rendering has been turned off on purpose.\n";
     return;
@@ -822,5 +823,5 @@ Ogre::OverlaySystem *OgreRenderEngine::OverlaySystem() const
 #endif
 
 // Register this plugin
-IGNITION_ADD_PLUGIN(ignition::rendering::OgreRenderEnginePlugin,
-                    ignition::rendering::RenderEnginePlugin)
+IGNITION_ADD_PLUGIN(gz::rendering::OgreRenderEnginePlugin,
+                    gz::rendering::RenderEnginePlugin)
diff --git a/ogre/src/OgreRenderPass.cc b/ogre/src/OgreRenderPass.cc
index ce36cd804..0146a499d 100644
--- a/ogre/src/OgreRenderPass.cc
+++ b/ogre/src/OgreRenderPass.cc
@@ -14,10 +14,10 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreRenderPass.hh"
+#include "gz/rendering/ogre/OgreRenderPass.hh"
 
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreRenderTarget.cc b/ogre/src/OgreRenderTarget.cc
index 217c28a03..435fc1aca 100644
--- a/ogre/src/OgreRenderTarget.cc
+++ b/ogre/src/OgreRenderTarget.cc
@@ -31,21 +31,21 @@
 #endif
 
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/Material.hh"
+#include "gz/rendering/Material.hh"
 
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreRenderPass.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreRenderTarget.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreCamera.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreRenderPass.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreRenderTarget.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreCamera.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -76,7 +76,7 @@ void OgreRenderTarget::Copy(Image &_image) const
 
   if (_image.Width() != this->width || _image.Height() != this->height)
   {
-    ignerr << "Invalid image dimensions" << std::endl;
+    gzerr << "Invalid image dimensions" << std::endl;
     return;
   }
 
@@ -248,7 +248,7 @@ Ogre::Viewport *OgreRenderTarget::Viewport(const int _viewportId) const
 
   if (nullptr == ogreRenderTarget)
   {
-    ignerr << "Failed to get viewport: null render target" << std::endl;
+    gzerr << "Failed to get viewport: null render target" << std::endl;
     return nullptr;
   }
 
@@ -262,7 +262,7 @@ Ogre::Viewport *OgreRenderTarget::AddViewport(Ogre::Camera *_camera)
 
   if (nullptr == ogreRenderTarget)
   {
-    ignerr << "Failed to add viewport: null render target" << std::endl;
+    gzerr << "Failed to add viewport: null render target" << std::endl;
     return nullptr;
   }
 
@@ -276,7 +276,7 @@ void OgreRenderTarget::SetAutoUpdated(const bool _value)
 
   if (nullptr == ogreRenderTarget)
   {
-    ignerr << "Failed to set auto update: null render target" << std::endl;
+    gzerr << "Failed to set auto update: null render target" << std::endl;
     return;
   }
 
@@ -290,7 +290,7 @@ void OgreRenderTarget::SetUpdate(const bool _value)
 
   if (nullptr == ogreRenderTarget)
   {
-    ignerr << "Failed to set update: null render target" << std::endl;
+    gzerr << "Failed to set update: null render target" << std::endl;
     return;
   }
 
@@ -374,7 +374,7 @@ void OgreRenderTexture::BuildTarget()
     static bool ogreFSAAWarn = false;
     if (ogreFSAAWarn)
     {
-      ignwarn << "Anti-aliasing level of '" << this->antiAliasing << "' "
+      gzwarn << "Anti-aliasing level of '" << this->antiAliasing << "' "
               << "is not supported. Setting to 0" << std::endl;
       ogreFSAAWarn = true;
     }
@@ -416,7 +416,7 @@ void OgreRenderTexture::Buffer(float *_buffer)
 
   if (nullptr == ogreRenderTarget)
   {
-    ignerr << "Failed to set buffer: null render target" << std::endl;
+    gzerr << "Failed to set buffer: null render target" << std::endl;
     return;
   }
 
@@ -473,7 +473,7 @@ void OgreRenderWindow::RebuildTarget()
 
   if (nullptr == window)
   {
-    ignerr << "Failed to cast render window." << std::endl;
+    gzerr << "Failed to cast render window." << std::endl;
     return;
   }
 
@@ -494,7 +494,7 @@ void OgreRenderWindow::BuildTarget()
 
   if (renderTargetName.empty())
   {
-    ignerr << "Failed to build target." << std::endl;
+    gzerr << "Failed to build target." << std::endl;
     return;
   }
 
diff --git a/ogre/src/OgreRenderTargetMaterial.cc b/ogre/src/OgreRenderTargetMaterial.cc
index b3f9ed84b..9215ea996 100644
--- a/ogre/src/OgreRenderTargetMaterial.cc
+++ b/ogre/src/OgreRenderTargetMaterial.cc
@@ -15,10 +15,10 @@
  *
  */
 
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreRenderTargetMaterial.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreRenderTargetMaterial.hh"
 
-using namespace ignition::rendering;
+using namespace gz::rendering;
 
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreScene.cc b/ogre/src/OgreScene.cc
index dd74dabfd..3dae5a0ec 100644
--- a/ogre/src/OgreScene.cc
+++ b/ogre/src/OgreScene.cc
@@ -15,47 +15,47 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-
-#include "ignition/rendering/ogre/OgreArrowVisual.hh"
-#include "ignition/rendering/ogre/OgreAxisVisual.hh"
-#include "ignition/rendering/ogre/OgreCamera.hh"
-#include "ignition/rendering/ogre/OgreCapsule.hh"
-#include "ignition/rendering/ogre/OgreCOMVisual.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreDepthCamera.hh"
-#include "ignition/rendering/ogre/OgreGeometry.hh"
-#include "ignition/rendering/ogre/OgreGizmoVisual.hh"
-#include "ignition/rendering/ogre/OgreGpuRays.hh"
-#include "ignition/rendering/ogre/OgreGrid.hh"
-#include "ignition/rendering/ogre/OgreHeightmap.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreInertiaVisual.hh"
-#include "ignition/rendering/ogre/OgreJointVisual.hh"
-#include "ignition/rendering/ogre/OgreLidarVisual.hh"
-#include "ignition/rendering/ogre/OgreLightVisual.hh"
-#include "ignition/rendering/ogre/OgreMarker.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreMeshFactory.hh"
-#include "ignition/rendering/ogre/OgreParticleEmitter.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-#include "ignition/rendering/ogre/OgreRayQuery.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreRenderTarget.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreStorage.hh"
-#include "ignition/rendering/ogre/OgreText.hh"
-#include "ignition/rendering/ogre/OgreThermalCamera.hh"
-#include "ignition/rendering/ogre/OgreVisual.hh"
-#include "ignition/rendering/ogre/OgreWideAngleCamera.hh"
-#include "ignition/rendering/ogre/OgreWireBox.hh"
-
-namespace ignition
+#include <gz/common/Console.hh>
+
+#include "gz/rendering/ogre/OgreArrowVisual.hh"
+#include "gz/rendering/ogre/OgreAxisVisual.hh"
+#include "gz/rendering/ogre/OgreCamera.hh"
+#include "gz/rendering/ogre/OgreCapsule.hh"
+#include "gz/rendering/ogre/OgreCOMVisual.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreDepthCamera.hh"
+#include "gz/rendering/ogre/OgreGeometry.hh"
+#include "gz/rendering/ogre/OgreGizmoVisual.hh"
+#include "gz/rendering/ogre/OgreGpuRays.hh"
+#include "gz/rendering/ogre/OgreGrid.hh"
+#include "gz/rendering/ogre/OgreHeightmap.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreInertiaVisual.hh"
+#include "gz/rendering/ogre/OgreJointVisual.hh"
+#include "gz/rendering/ogre/OgreLidarVisual.hh"
+#include "gz/rendering/ogre/OgreLightVisual.hh"
+#include "gz/rendering/ogre/OgreMarker.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreMeshFactory.hh"
+#include "gz/rendering/ogre/OgreParticleEmitter.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreRayQuery.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreRenderTarget.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreStorage.hh"
+#include "gz/rendering/ogre/OgreText.hh"
+#include "gz/rendering/ogre/OgreThermalCamera.hh"
+#include "gz/rendering/ogre/OgreVisual.hh"
+#include "gz/rendering/ogre/OgreWideAngleCamera.hh"
+#include "gz/rendering/ogre/OgreWireBox.hh"
+
+namespace gz
 {
   namespace rendering
   {
 
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \class Subclassing the Ogre Rectangle2D class to create a gradient
     /// colored rectangle. The class is setting colors at the four vertices
@@ -129,7 +129,7 @@ namespace ignition
   }
 }
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -241,19 +241,19 @@ void OgreScene::SetGradientBackgroundColor(
   auto coloredRectangle2D = backgroundNodePtr->getAttachedObject(0);
   if (!coloredRectangle2D)
   {
-    ignerr << "Unable to find the background attached object" << std::endl;
+    gzerr << "Unable to find the background attached object" << std::endl;
     return;
   }
 
   rect = dynamic_cast<ColoredRectangle2D *>(coloredRectangle2D);
   if (!rect)
   {
-    ignerr << "Unable to cast from Ogre::MovableObject to ColouredRectangle2D"
+    gzerr << "Unable to cast from Ogre::MovableObject to ColouredRectangle2D"
            << std::endl;
     return;
   }
 
-  // Convert the ignition::math::Color to Ogre::ColourValue.
+  // Convert the gz::math::Color to Ogre::ColourValue.
   std::array<Ogre::ColourValue, 4> ogreColors;
   for (auto i = 0u; i < 4; ++i)
     ogreColors[i].setAsRGBA(_colors[i].AsRGBA());
@@ -707,7 +707,7 @@ void OgreScene::CreateRootVisual()
   // check if root visual created successfully
   if (!this->InitObject(this->rootVisual, rootId, rootName))
   {
-    ignerr << "Unable to create root visual" << std::endl;
+    gzerr << "Unable to create root visual" << std::endl;
     this->rootVisual = nullptr;
   }
 
diff --git a/ogre/src/OgreSelectionBuffer.cc b/ogre/src/OgreSelectionBuffer.cc
index 0bfc8c0f2..ac67934ce 100644
--- a/ogre/src/OgreSelectionBuffer.cc
+++ b/ogre/src/OgreSelectionBuffer.cc
@@ -16,18 +16,18 @@
 */
 
 #include <memory>
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
-#include "ignition/common/Console.hh"
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre/OgreIncludes.hh"
-#include "ignition/rendering/ogre/OgreMaterialSwitcher.hh"
-#include "ignition/rendering/ogre/OgreSelectionBuffer.hh"
+#include "gz/common/Console.hh"
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre/OgreIncludes.hh"
+#include "gz/rendering/ogre/OgreMaterialSwitcher.hh"
+#include "gz/rendering/ogre/OgreSelectionBuffer.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
-class ignition::rendering::OgreSelectionBufferPrivate
+class gz::rendering::OgreSelectionBufferPrivate
 {
   /// \brief This is a material listener and a RenderTargetListener.
   /// The material switcher is applied to only the selection camera
@@ -145,7 +145,7 @@ void OgreSelectionBuffer::CreateRTTBuffer()
   catch(...)
   {
     this->dataPtr->renderTexture = nullptr;
-    ignerr << "Unable to create selection buffer.\n";
+    gzerr << "Unable to create selection buffer.\n";
     return;
   }
 
@@ -231,14 +231,14 @@ Ogre::Entity *OgreSelectionBuffer::OnSelectionClick(const int _x, const int _y)
 
   size_t posInStream = 0;
 
-  ignition::math::Color::BGRA color(0);
+  gz::math::Color::BGRA color(0);
   if (!this->dataPtr->buffer)
   {
-    ignerr << "Selection buffer is null.\n";
+    gzerr << "Selection buffer is null.\n";
     return nullptr;
   }
   memcpy(static_cast<void *>(&color), this->dataPtr->buffer + posInStream, 4);
-  ignition::math::Color cv;
+  gz::math::Color cv;
   cv.SetFromARGB(color);
   cv.A(1.0);
   const std::string &entName =
@@ -289,7 +289,7 @@ void OgreSelectionBuffer::CreateRTTOverlays()
   }
   else
   {
-    ignlog << "Unable to create selection buffer overlay. "
+    gzlog << "Unable to create selection buffer overlay. "
       "This will not effect ignition-rendering unless you're trying to debug "
       "the selection buffer.\n";
   }
@@ -307,6 +307,6 @@ void OgreSelectionBuffer::ShowOverlay(const bool _show)
 #else
 void OgreSelectionBuffer::ShowOverlay(const bool _show)
 {
-  ignerr << "Selection debug overlay disabled for Ogre > 1.9\n";
+  gzerr << "Selection debug overlay disabled for Ogre > 1.9\n";
 }
 #endif
diff --git a/ogre/src/OgreSensor.cc b/ogre/src/OgreSensor.cc
index 58c965834..b45f5978a 100644
--- a/ogre/src/OgreSensor.cc
+++ b/ogre/src/OgreSensor.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre/OgreSensor.hh"
+#include "gz/rendering/ogre/OgreSensor.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre/src/OgreText.cc b/ogre/src/OgreText.cc
index 32538f0fd..d64a23a07 100644
--- a/ogre/src/OgreText.cc
+++ b/ogre/src/OgreText.cc
@@ -20,17 +20,17 @@
   #include <windows.h>
 #endif
 
-#include <ignition/common/Util.hh>
-#include <ignition/common/Console.hh>
+#include <gz/common/Util.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreText.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreText.hh"
 
 #define POS_TEX_BINDING    0
 #define COLOUR_BINDING     1
 
-class ignition::rendering::OgreMovableText
+class gz::rendering::OgreMovableText
   : public Ogre::MovableObject, public Ogre::Renderable
 {
   /// \brief Constructor
@@ -50,7 +50,7 @@ class ignition::rendering::OgreMovableText
 
   /// \brief Set the text color.
   /// \param[in] _color Text color.
-  public: void SetColor(const ignition::math::Color &_color);
+  public: void SetColor(const gz::math::Color &_color);
 
   /// \brief Set the height of the character in meters.
   /// \param[in] _height Height of the characters.
@@ -77,7 +77,7 @@ class ignition::rendering::OgreMovableText
 
   /// \brief Get the axis aligned bounding box of the text.
   /// \return The axis aligned bounding box.
-  public: ignition::math::AxisAlignedBox AABB() const;
+  public: gz::math::AxisAlignedBox AABB() const;
 
   /// \brief Setup the geometry based on input text string.
   public: void SetupGeometry();
@@ -187,7 +187,7 @@ class ignition::rendering::OgreMovableText
   private: std::string text;
 
   /// \brief Text color
-  private: ignition::math::Color color;
+  private: gz::math::Color color;
 
   /// \brief Character height in meters
   private: float charHeight = 0.0;
@@ -210,7 +210,7 @@ class ignition::rendering::OgreMovableText
 };
 
 /// \brief Private data for the OgreText class.
-class ignition::rendering::OgreTextPrivate
+class gz::rendering::OgreTextPrivate
 {
   /// \brief Text materal
   public: OgreMaterialPtr material;
@@ -219,7 +219,7 @@ class ignition::rendering::OgreTextPrivate
   public: std::unique_ptr<OgreMovableText> ogreObj;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -257,7 +257,7 @@ void OgreMovableText::SetTextString(const std::string &_text)
 }
 
 //////////////////////////////////////////////////
-void OgreMovableText::SetColor(const ignition::math::Color &_color)
+void OgreMovableText::SetColor(const gz::math::Color &_color)
 {
   if (this->color != _color)
   {
@@ -323,13 +323,13 @@ void OgreMovableText::SetShowOnTop(const bool _onTop)
 }
 
 //////////////////////////////////////////////////
-ignition::math::AxisAlignedBox OgreMovableText::AABB() const
+gz::math::AxisAlignedBox OgreMovableText::AABB() const
 {
-  return ignition::math::AxisAlignedBox(
-      ignition::math::Vector3d(this->aabb->getMinimum().x,
+  return gz::math::AxisAlignedBox(
+      gz::math::Vector3d(this->aabb->getMinimum().x,
                     this->aabb->getMinimum().y,
                     this->aabb->getMinimum().z),
-      ignition::math::Vector3d(this->aabb->getMaximum().x,
+      gz::math::Vector3d(this->aabb->getMaximum().x,
                     this->aabb->getMaximum().y,
                     this->aabb->getMaximum().z));
 }
@@ -362,7 +362,7 @@ void OgreMovableText::SetFontNameImpl(const std::string &_newFontName)
 
     if (!ogreFont)
     {
-      ignerr << "Could not find font " + _newFontName << std::endl;
+      gzerr << "Could not find font " + _newFontName << std::endl;
     }
     this->font = ogreFont;
     this->fontName = _newFontName;
@@ -489,7 +489,7 @@ void OgreMovableText::SetupGeometry()
   pVert = static_cast<float*>(ptbuf->lock(Ogre::HardwareBuffer::HBL_DISCARD));
 
   // Derive space width from a capital A
-  if (ignition::math::equal(this->spaceWidth, 0.0f))
+  if (gz::math::equal(this->spaceWidth, 0.0f))
   {
     this->spaceWidth = this->font->getGlyphAspectRatio('A') *
         this->charHeight * 2.0;
@@ -945,7 +945,7 @@ void OgreText::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign ogreMaterial created by another render-engine"
+    gzerr << "Cannot assign ogreMaterial created by another render-engine"
         << std::endl;
 
     return;
@@ -983,7 +983,7 @@ void OgreText::SetTextString(const std::string &_text)
 }
 
 //////////////////////////////////////////////////
-void OgreText::SetColor(const ignition::math::Color &_color)
+void OgreText::SetColor(const gz::math::Color &_color)
 {
   BaseText::SetColor(_color);
   this->dataPtr->ogreObj->SetColor(_color);
@@ -1026,7 +1026,7 @@ void OgreText::SetShowOnTop(const bool _onTop)
 }
 
 //////////////////////////////////////////////////
-ignition::math::AxisAlignedBox OgreText::AABB() const
+gz::math::AxisAlignedBox OgreText::AABB() const
 {
   return this->dataPtr->ogreObj->AABB();
 }
diff --git a/ogre/src/OgreThermalCamera.cc b/ogre/src/OgreThermalCamera.cc
index c201d3d8d..8c090ffc2 100644
--- a/ogre/src/OgreThermalCamera.cc
+++ b/ogre/src/OgreThermalCamera.cc
@@ -25,17 +25,17 @@
 
 #include <limits>
 
-#include <ignition/math/Helpers.hh>
-#include "ignition/rendering/ShaderParams.hh"
-#include "ignition/rendering/ogre/OgreThermalCamera.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreVisual.hh"
+#include <gz/math/Helpers.hh>
+#include "gz/rendering/ShaderParams.hh"
+#include "gz/rendering/ogre/OgreThermalCamera.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreVisual.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /// \brief Helper class for switching the ogre item's material to heat source
 /// material when a thermal camera is being rendered.
@@ -90,7 +90,7 @@ class OgreThermalCameraMaterialSwitcher : public Ogre::RenderTargetListener,
 
 /// \internal
 /// \brief Private data for the OgreThermalCamera class
-class ignition::rendering::OgreThermalCameraPrivate
+class gz::rendering::OgreThermalCameraPrivate
 {
   /// \brief The thermal material
   public: Ogre::MaterialPtr thermalMaterial;
@@ -123,7 +123,7 @@ class ignition::rendering::OgreThermalCameraPrivate
   public: uint16_t dataMinVal = 0u;
 
   /// \brief Event used to signal thermal image data
-  public: ignition::common::EventT<void(const uint16_t *,
+  public: gz::common::EventT<void(const uint16_t *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newThermalFrame;
 
@@ -132,7 +132,7 @@ class ignition::rendering::OgreThermalCameraPrivate
       thermalMaterialSwitcher;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 
@@ -208,7 +208,7 @@ Ogre::Technique *OgreThermalCameraMaterialSwitcher::handleSchemeNotFound(
     }
     catch(Ogre::Exception &e)
     {
-      ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+      gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
     }
     ogreVisual = std::dynamic_pointer_cast<OgreVisual>(result);
   }
@@ -240,7 +240,7 @@ Ogre::Technique *OgreThermalCameraMaterialSwitcher::handleSchemeNotFound(
         }
         catch(std::bad_variant_access &e)
         {
-          ignerr << "Error casting user data: " << e.what() << "\n";
+          gzerr << "Error casting user data: " << e.what() << "\n";
           temp = -1.0;
         }
       }
@@ -316,7 +316,7 @@ void OgreThermalCamera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   else
   {
@@ -345,7 +345,7 @@ void OgreThermalCamera::CreateCamera()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
@@ -353,7 +353,7 @@ void OgreThermalCamera::CreateCamera()
       this->name);
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -377,7 +377,7 @@ void OgreThermalCamera::CreateThermalTexture()
 {
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -545,14 +545,14 @@ void OgreThermalCamera::PostRender()
       this->dataPtr->thermalBuffer, width, height, 1, "L16");
 
   // Uncomment to debug thermal output
-  // igndbg << "wxh: " << width << " x " << height << std::endl;
+  // gzdbg << "wxh: " << width << " x " << height << std::endl;
   // for (unsigned int i = 0; i < height; ++i)
   // {
   //   for (unsigned int j = 0; j < width; ++j)
   //   {
-  //     igndbg << "[" << this->dataPtr->thermalImage[i*width + j] << "]";
+  //     gzdbg << "[" << this->dataPtr->thermalImage[i*width + j] << "]";
   //   }
-  //   igndbg << std::endl;
+  //   gzdbg << std::endl;
   // }
 }
 
diff --git a/ogre/src/OgreVisual.cc b/ogre/src/OgreVisual.cc
index fba1eee91..51ef7a7cf 100644
--- a/ogre/src/OgreVisual.cc
+++ b/ogre/src/OgreVisual.cc
@@ -15,19 +15,19 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreVisual.hh"
-#include "ignition/rendering/ogre/OgreWireBox.hh"
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreStorage.hh"
-#include "ignition/rendering/Utils.hh"
+#include "gz/rendering/ogre/OgreVisual.hh"
+#include "gz/rendering/ogre/OgreWireBox.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreStorage.hh"
+#include "gz/rendering/Utils.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /// \brief Private data for the Ogre2Visual class
-class ignition::rendering::OgreVisualPrivate
+class gz::rendering::OgreVisualPrivate
 {
   /// \brief True if wireframe mode is enabled
   public: bool wireframe;
@@ -132,14 +132,14 @@ bool OgreVisual::AttachGeometry(GeometryPtr _geometry)
 {
   if (!_geometry)
   {
-    ignerr << "Cannot attach null geometry." << std::endl;
+    gzerr << "Cannot attach null geometry." << std::endl;
 
     return false;
   }
 
   if (!this->ogreNode)
   {
-    ignerr << "Cannot attach geometry, null Ogre node." << std::endl;
+    gzerr << "Cannot attach geometry, null Ogre node." << std::endl;
     return false;
   }
 
@@ -148,7 +148,7 @@ bool OgreVisual::AttachGeometry(GeometryPtr _geometry)
 
   if (!derived)
   {
-    ignerr << "Cannot attach geometry created by another render-engine"
+    gzerr << "Cannot attach geometry created by another render-engine"
           << std::endl;
 
     return false;
@@ -174,7 +174,7 @@ bool OgreVisual::DetachGeometry(GeometryPtr _geometry)
 {
   if (!this->ogreNode)
   {
-    ignerr << "Cannot detach geometry, null Ogre node." << std::endl;
+    gzerr << "Cannot detach geometry, null Ogre node." << std::endl;
     return false;
   }
 
@@ -183,7 +183,7 @@ bool OgreVisual::DetachGeometry(GeometryPtr _geometry)
 
   if (!derived)
   {
-    ignerr << "Cannot detach geometry created by another render-engine"
+    gzerr << "Cannot detach geometry created by another render-engine"
           << std::endl;
 
     return false;
@@ -196,31 +196,31 @@ bool OgreVisual::DetachGeometry(GeometryPtr _geometry)
 }
 
 //////////////////////////////////////////////////
-ignition::math::AxisAlignedBox OgreVisual::LocalBoundingBox() const
+gz::math::AxisAlignedBox OgreVisual::LocalBoundingBox() const
 {
-  ignition::math::AxisAlignedBox box;
+  gz::math::AxisAlignedBox box;
   this->BoundsHelper(box, true /* local frame */);
   return box;
 }
 
 //////////////////////////////////////////////////
-ignition::math::AxisAlignedBox OgreVisual::BoundingBox() const
+gz::math::AxisAlignedBox OgreVisual::BoundingBox() const
 {
-  ignition::math::AxisAlignedBox box;
+  gz::math::AxisAlignedBox box;
   this->BoundsHelper(box, false /* world frame */);
   return box;
 }
 
 //////////////////////////////////////////////////
-void OgreVisual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
+void OgreVisual::BoundsHelper(gz::math::AxisAlignedBox &_box,
     bool _local) const
 {
   this->BoundsHelper(_box, _local, this->WorldPose());
 }
 
 //////////////////////////////////////////////////
-void OgreVisual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
-    bool _local, const ignition::math::Pose3d &_pose) const
+void OgreVisual::BoundsHelper(gz::math::AxisAlignedBox &_box,
+    bool _local, const gz::math::Pose3d &_pose) const
 {
   if (!this->ogreNode)
     return;
@@ -228,7 +228,7 @@ void OgreVisual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
   this->ogreNode->_updateBounds();
   this->ogreNode->_update(false, true);
 
-  ignition::math::Vector3d scale = this->WorldScale();
+  gz::math::Vector3d scale = this->WorldScale();
 
   for (int i = 0; i < this->ogreNode->numAttachedObjects(); i++)
   {
@@ -238,15 +238,15 @@ void OgreVisual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
     {
       Ogre::AxisAlignedBox bb = obj->getBoundingBox();
 
-      ignition::math::Vector3d min(0, 0, 0);
-      ignition::math::Vector3d max(0, 0, 0);
-      ignition::math::AxisAlignedBox box(min, max);
+      gz::math::Vector3d min(0, 0, 0);
+      gz::math::Vector3d max(0, 0, 0);
+      gz::math::AxisAlignedBox box(min, max);
 
       // Ogre does not return a valid bounding box for lights.
       if (obj->getMovableType() == Ogre::LightFactory::FACTORY_TYPE_NAME)
       {
-        box.Min() = ignition::math::Vector3d(-0.5, -0.5, -0.5);
-        box.Max()  = ignition::math::Vector3d(0.5, 0.5, 0.5);
+        box.Min() = gz::math::Vector3d(-0.5, -0.5, -0.5);
+        box.Max()  = gz::math::Vector3d(0.5, 0.5, 0.5);
       }
       else
       {
@@ -254,22 +254,22 @@ void OgreVisual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
         Ogre::Vector3 ogreMax = bb.getMaximum();
 
         // Get ogre bounding boxes and size to object's scale
-        min = scale * ignition::math::Vector3d(ogreMin.x, ogreMin.y, ogreMin.z);
-        max = scale * ignition::math::Vector3d(ogreMax.x, ogreMax.y, ogreMax.z);
+        min = scale * gz::math::Vector3d(ogreMin.x, ogreMin.y, ogreMin.z);
+        max = scale * gz::math::Vector3d(ogreMax.x, ogreMax.y, ogreMax.z);
         box.Min() = min,
         box.Max() = max;
 
         // Assume world transform
-        ignition::math::Pose3d transform = _pose;
+        gz::math::Pose3d transform = _pose;
 
         // If local frame, calculate transform matrix and set
         if (_local)
         {
-          ignition::math::Pose3d worldPose = this->WorldPose();
-          ignition::math::Vector3d parentPos = _pose.Pos();
-          ignition::math::Quaternion parentRotInv = _pose.Rot().Inverse();
-          ignition::math::Pose3d localTransform =
-            ignition::math::Pose3d(
+          gz::math::Pose3d worldPose = this->WorldPose();
+          gz::math::Vector3d parentPos = _pose.Pos();
+          gz::math::Quaternion parentRotInv = _pose.Rot().Inverse();
+          gz::math::Pose3d localTransform =
+            gz::math::Pose3d(
                 (parentRotInv * (worldPose.Pos() - parentPos)),
                 (parentRotInv * worldPose.Rot()));
           transform = localTransform;
diff --git a/ogre/src/OgreWideAngleCamera.cc b/ogre/src/OgreWideAngleCamera.cc
index 8475a5b2a..bdc18422e 100644
--- a/ogre/src/OgreWideAngleCamera.cc
+++ b/ogre/src/OgreWideAngleCamera.cc
@@ -32,15 +32,15 @@
 #endif
 #endif
 
-#include "ignition/rendering/CameraLens.hh"
+#include "gz/rendering/CameraLens.hh"
 
-#include "ignition/rendering/ogre/OgreConversions.hh"
-#include "ignition/rendering/ogre/OgreRenderEngine.hh"
-#include "ignition/rendering/ogre/OgreRTShaderSystem.hh"
-#include "ignition/rendering/ogre/OgreWideAngleCamera.hh"
+#include "gz/rendering/ogre/OgreConversions.hh"
+#include "gz/rendering/ogre/OgreRenderEngine.hh"
+#include "gz/rendering/ogre/OgreRTShaderSystem.hh"
+#include "gz/rendering/ogre/OgreWideAngleCamera.hh"
 
 /// \brief Private data for the WideAngleCamera class
-class ignition::rendering::OgreWideAngleCamera::Implementation
+class gz::rendering::OgreWideAngleCamera::Implementation
 {
   /// \brief Environment texture size
   public: int envTextureSize = 512u;
@@ -89,12 +89,12 @@ class ignition::rendering::OgreWideAngleCamera::Implementation
   public: unsigned char *wideAngleImage = nullptr;
 
   /// \brief Event used to signal camera data
-  public: ignition::common::EventT<void(const unsigned char *,
+  public: gz::common::EventT<void(const unsigned char *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newImageFrame;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -203,7 +203,7 @@ void OgreWideAngleCamera::CreateCamera()
   Ogre::SceneManager *ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
@@ -211,7 +211,7 @@ void OgreWideAngleCamera::CreateCamera()
       this->Name() + "_Camera");
   if (this->dataPtr->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -293,7 +293,7 @@ void OgreWideAngleCamera::CreateWideAngleTexture()
 {
   if (this->dataPtr->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -338,7 +338,7 @@ void OgreWideAngleCamera::CreateWideAngleTexture()
     static bool ogreFSAAWarn = false;
     if (ogreFSAAWarn)
     {
-      ignwarn << "Anti-aliasing level of '" << this->antiAliasing << "' "
+      gzwarn << "Anti-aliasing level of '" << this->antiAliasing << "' "
               << "is not supported. Setting to 0" << std::endl;
       ogreFSAAWarn = true;
     }
@@ -490,7 +490,7 @@ math::Vector3d OgreWideAngleCamera::Project3d(
     const math::Vector3d &_pt) const
 {
   // project onto cubemap face then onto
-  ignition::math::Vector3d screenPos;
+  gz::math::Vector3d screenPos;
   // loop through all env cameras can find the one that sees the 3d world point
   for (unsigned int i = 0u; i < this->dataPtr->kEnvCameraCount; ++i)
   {
@@ -505,22 +505,22 @@ math::Vector3d OgreWideAngleCamera::Project3d(
     {
       // determine dir vector to projected point from env camera
       // work in y up, z forward, x right clip space
-      ignition::math::Vector3d dir(pos.x, pos.y, 1);
-      ignition::math::Quaterniond rot = ignition::math::Quaterniond::Identity;
+      gz::math::Vector3d dir(pos.x, pos.y, 1);
+      gz::math::Quaterniond rot = gz::math::Quaterniond::Identity;
 
       // rotate dir vector into wide angle camera frame based on the
       // face of the cube. Note: operate in clip space so
       // left handed coordinate system rotation
       if (i == 0)
-        rot = ignition::math::Quaterniond(0.0, IGN_PI * 0.5, 0.0);
+        rot = gz::math::Quaterniond(0.0, IGN_PI * 0.5, 0.0);
       else if (i == 1)
-        rot = ignition::math::Quaterniond(0.0, -IGN_PI * 0.5, 0.0);
+        rot = gz::math::Quaterniond(0.0, -IGN_PI * 0.5, 0.0);
       else if (i == 2)
-        rot = ignition::math::Quaterniond(-IGN_PI * 0.5, 0.0, 0.0);
+        rot = gz::math::Quaterniond(-IGN_PI * 0.5, 0.0, 0.0);
       else if (i == 3)
-        rot = ignition::math::Quaterniond(IGN_PI * 0.5, 0.0, 0.0);
+        rot = gz::math::Quaterniond(IGN_PI * 0.5, 0.0, 0.0);
       else if (i == 5)
-        rot = ignition::math::Quaterniond(0.0, IGN_PI, 0.0);
+        rot = gz::math::Quaterniond(0.0, IGN_PI, 0.0);
       dir = rot * dir;
       dir.Normalize();
 
@@ -623,7 +623,7 @@ void OgreWideAngleCamera::PostRender()
       this->dataPtr->wideAngleImage, width, height, channelCount, "PF_R8G8B8");
 
   // Uncomment to debug wide angle cameraoutput
-  // igndbg << "wxh: " << width << " x " << height << std::endl;
+  // gzdbg << "wxh: " << width << " x " << height << std::endl;
   // for (unsigned int i = 0; i < height; ++i)
   // {
   //   for (unsigned int j = 0; j < width * channelCount; j += channelCount)
diff --git a/ogre/src/OgreWireBox.cc b/ogre/src/OgreWireBox.cc
index 0d53d52d6..e44c064ba 100644
--- a/ogre/src/OgreWireBox.cc
+++ b/ogre/src/OgreWireBox.cc
@@ -14,14 +14,14 @@
  * limitations under the License.
  *
 */
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre/OgreWireBox.hh"
-#include "ignition/rendering/ogre/OgreMaterial.hh"
-#include "ignition/rendering/ogre/OgreScene.hh"
-#include "ignition/rendering/ogre/OgreDynamicLines.hh"
+#include "gz/rendering/ogre/OgreWireBox.hh"
+#include "gz/rendering/ogre/OgreMaterial.hh"
+#include "gz/rendering/ogre/OgreScene.hh"
+#include "gz/rendering/ogre/OgreDynamicLines.hh"
 
-class ignition::rendering::OgreWireBoxPrivate
+class gz::rendering::OgreWireBoxPrivate
 {
   /// \brief WireBox materal
   public: OgreMaterialPtr material;
@@ -30,7 +30,7 @@ class ignition::rendering::OgreWireBoxPrivate
   public: Ogre::ManualObject *manualObject = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -93,8 +93,8 @@ void OgreWireBox::Create()
   this->dataPtr->manualObject->begin(materialName,
       Ogre::RenderOperation::OT_LINE_LIST);
 
-  ignition::math::Vector3d max = this->box.Max();
-  ignition::math::Vector3d min = this->box.Min();
+  gz::math::Vector3d max = this->box.Max();
+  gz::math::Vector3d min = this->box.Min();
 
   // line 0
   this->dataPtr->manualObject->position(min.X(), min.Y(), min.Z());
@@ -157,7 +157,7 @@ void OgreWireBox::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre/src/media/fonts/CMakeLists.txt b/ogre/src/media/fonts/CMakeLists.txt
index e09076c10..67ee66c4a 100644
--- a/ogre/src/media/fonts/CMakeLists.txt
+++ b/ogre/src/media/fonts/CMakeLists.txt
@@ -1,4 +1,4 @@
 file(GLOB files "*ttf" "*png" "*fontdef")
 
-install(FILES ${files} DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/ogre/media/fonts)
-install(DIRECTORY liberation-sans DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/ogre/media/fonts)
+install(FILES ${files} DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/ogre/media/fonts)
+install(DIRECTORY liberation-sans DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/ogre/media/fonts)
diff --git a/ogre/src/media/materials/programs/CMakeLists.txt b/ogre/src/media/materials/programs/CMakeLists.txt
index b245b70d6..8d19dd395 100644
--- a/ogre/src/media/materials/programs/CMakeLists.txt
+++ b/ogre/src/media/materials/programs/CMakeLists.txt
@@ -1,4 +1,4 @@
 file(GLOB files "*.glsl")
 
-install(FILES ${files} DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/ogre/media/materials/programs)
+install(FILES ${files} DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/ogre/media/materials/programs)
 
diff --git a/ogre/src/media/materials/scripts/CMakeLists.txt b/ogre/src/media/materials/scripts/CMakeLists.txt
index 66bf8e9e6..b739e94f8 100644
--- a/ogre/src/media/materials/scripts/CMakeLists.txt
+++ b/ogre/src/media/materials/scripts/CMakeLists.txt
@@ -1,4 +1,4 @@
 file(GLOB files "*.material" "*.compositor")
 
-install(FILES ${files} DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/ogre/media/materials/scripts)
+install(FILES ${files} DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/ogre/media/materials/scripts)
 
diff --git a/ogre/src/media/rtshaderlib150/CMakeLists.txt b/ogre/src/media/rtshaderlib150/CMakeLists.txt
index f65a9daf5..2cb12d93f 100644
--- a/ogre/src/media/rtshaderlib150/CMakeLists.txt
+++ b/ogre/src/media/rtshaderlib150/CMakeLists.txt
@@ -10,5 +10,5 @@ SGXLib_NormalMapLighting.glsl
 SGXLib_PerPixelLighting.glsl
 )
 
-install(FILES ${files} DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/ogre/media/rtshaderlib150)
+install(FILES ${files} DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/ogre/media/rtshaderlib150)
 
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2ArrowVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2ArrowVisual.hh
index fb57ed538..eeba38040 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2ArrowVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2ArrowVisual.hh
@@ -20,14 +20,14 @@
 #include "gz/rendering/base/BaseArrowVisual.hh"
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre2.x implementation of the arrow visual class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2ArrowVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2ArrowVisual :
       public BaseArrowVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2AxisVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2AxisVisual.hh
index 82725d4fb..42ab51e78 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2AxisVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2AxisVisual.hh
@@ -20,14 +20,14 @@
 #include "gz/rendering/base/BaseAxisVisual.hh"
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre2.x implementation of the axis visual class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2AxisVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2AxisVisual :
       public BaseAxisVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2COMVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2COMVisual.hh
index 5c913e89b..199b644e2 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2COMVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2COMVisual.hh
@@ -28,16 +28,16 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     // Forward declaration
     class Ogre2COMVisualPrivate;
 
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2COMVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2COMVisual :
       public BaseCOMVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Camera.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Camera.hh
index 788cea6ee..9b77b588d 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Camera.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Camera.hh
@@ -30,18 +30,18 @@ namespace Ogre
   class Camera;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2CameraPrivate;
     class Ogre2SelectionBuffer;
 
     /// \brief Ogre2.x implementation of the camera class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Camera :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Camera :
       public virtual BaseCamera<Ogre2Sensor>,
       public virtual Ogre2ObjectInterface
     {
@@ -105,7 +105,7 @@ namespace ignition
           override;
 
       // Documentation inherited
-      public: virtual VisualPtr VisualAt(const ignition::math::Vector2i
+      public: virtual VisualPtr VisualAt(const gz::math::Vector2i
                   &_mousePos) override;
 
       // Documentation Inherited.
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Capsule.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Capsule.hh
index d48f65733..a2541c3f1 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Capsule.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Capsule.hh
@@ -29,16 +29,16 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
       // Forward declaration
       class Ogre2CapsulePrivate;
 
       /// \brief Ogre 2.x implementation of a Capsule Geometry.
-      class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Capsule
+      class GZ_RENDERING_OGRE2_VISIBLE Ogre2Capsule
         : public BaseCapsule<Ogre2Geometry>
       {
         /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Conversions.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Conversions.hh
index 1b7afbc44..9362a6b25 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Conversions.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Conversions.hh
@@ -38,11 +38,11 @@
   #pragma warning(pop)
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \addtogroup ign_rendering
     /// \{
@@ -50,7 +50,7 @@ namespace ignition
     /// \brief Conversions Conversions.hh rendering/Conversions.hh
     /// \brief A set of utility function to convert between Ignition and Ogre
     /// data types
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Conversions
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Conversions
     {
       /// \brief Return the equivalent ogre color
       /// \param[in] _color ign-math color to convert
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2DepthCamera.hh b/ogre2/include/gz/rendering/ogre2/Ogre2DepthCamera.hh
index 7096c22c5..9d2a4cfc1 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2DepthCamera.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2DepthCamera.hh
@@ -42,17 +42,17 @@ namespace Ogre
   class Viewport;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2DepthCameraPrivate;
 
     /// \brief Depth camera used to render depth data into an image buffer
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2DepthCamera :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2DepthCamera :
       public virtual BaseDepthCamera<Ogre2Sensor>,
       public virtual Ogre2ObjectInterface
     {
@@ -92,14 +92,14 @@ namespace ignition
       /// \brief Connect a to the new depth image signal
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewDepthFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewDepthFrame(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
       /// \brief Connect a to the new rgb point cloud signal
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewRgbPointCloud(
+      public: virtual gz::common::ConnectionPtr ConnectNewRgbPointCloud(
           std::function<void(const float *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2DynamicRenderable.hh b/ogre2/include/gz/rendering/ogre2/Ogre2DynamicRenderable.hh
index 983772cd9..a8123179f 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2DynamicRenderable.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2DynamicRenderable.hh
@@ -38,11 +38,11 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations
     class Ogre2DynamicRenderablePrivate;
@@ -52,7 +52,7 @@ namespace ignition
      */
     /// \brief Dynamic renderable class that manages hardware buffers for
     /// a dynamic geometry
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2DynamicRenderable
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2DynamicRenderable
     {
       /// \brief Constructor
       /// \param[in] _scene Pointer to scene
@@ -76,10 +76,10 @@ namespace ignition
       public: Ogre::MovableObject *OgreObject() const;
 
       /// \brief Add a point to the point list
-      /// \param[in] _pt ignition::math::Vector3d point
-      /// \param[in] _color ignition::math::Color Point color
-      public: void AddPoint(const ignition::math::Vector3d &_pt,
-            const ignition::math::Color &_color = ignition::math::Color::White);
+      /// \param[in] _pt gz::math::Vector3d point
+      /// \param[in] _color gz::math::Color Point color
+      public: void AddPoint(const gz::math::Vector3d &_pt,
+            const gz::math::Color &_color = gz::math::Color::White);
 
       /// \brief Add a point to the point list.
       /// \param[in] _x X position
@@ -87,27 +87,27 @@ namespace ignition
       /// \param[in] _z Z position
       /// \param[in] _color Point color
       public: void AddPoint(const double _x, const double _y, const double _z,
-            const ignition::math::Color &_color = ignition::math::Color::White);
+            const gz::math::Color &_color = gz::math::Color::White);
 
       /// \brief Change the location of an existing point in the point list
       /// \param[in] _index Index of the point to set
       /// \param[in] _value Position of the point
       public: void SetPoint(unsigned int _index,
-                            const ignition::math::Vector3d &_value);
+                            const gz::math::Vector3d &_value);
 
       /// \brief Change the color of an existing point in the point list
       /// \param[in] _index Index of the point to set
       /// \param[in] _color color to set the point to
       public: void SetColor(unsigned int _index,
-                            const ignition::math::Color &_color);
+                            const gz::math::Color &_color);
 
       /// \brief Return the position of an existing point in the point list
       /// \param[in] _index Get the point at this index
       /// \return position of point. A vector of
-      /// [ignition::math::INF_D, ignition::math::INF_D, ignition::math::INF_D]
+      /// [gz::math::INF_D, gz::math::INF_D, gz::math::INF_D]
       /// is returned when then the _index is out of bounds.
-      /// ignition::math::INF_D==std::numeric_limits<double>::infinity()
-      public: ignition::math::Vector3d Point(unsigned int _index) const;
+      /// gz::math::INF_D==std::numeric_limits<double>::infinity()
+      public: gz::math::Vector3d Point(unsigned int _index) const;
 
       /// \brief Return the total number of points in the point list
       /// \return Number of points
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2GaussianNoisePass.hh b/ogre2/include/gz/rendering/ogre2/Ogre2GaussianNoisePass.hh
index b67f85c19..55e66f2c9 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2GaussianNoisePass.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2GaussianNoisePass.hh
@@ -23,11 +23,11 @@
 #include "gz/rendering/ogre2/Ogre2RenderPass.hh"
 #include "gz/rendering/ogre2/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2GaussianNoisePassPrivate;
@@ -36,7 +36,7 @@ namespace ignition
      * gz/rendering/ogre2/Ogre2GaussianNoisePass.hh
      */
     /// \brief Ogre2 Implementation of a Gaussian noise render pass.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2GaussianNoisePass :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2GaussianNoisePass :
       public BaseGaussianNoisePass<Ogre2RenderPass>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Geometry.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Geometry.hh
index 04f2e2b9b..a0836beea 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Geometry.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Geometry.hh
@@ -25,14 +25,14 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre2.x implementation of the geometry class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Geometry :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Geometry :
       public BaseGeometry<Ogre2Object>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2GizmoVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2GizmoVisual.hh
index 149c06d90..8ce747f2a 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2GizmoVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2GizmoVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseGizmoVisual.hh"
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2GizmoVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2GizmoVisual :
       public BaseGizmoVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2GpuRays.hh b/ogre2/include/gz/rendering/ogre2/Ogre2GpuRays.hh
index 237712e75..aeffb6cad 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2GpuRays.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2GpuRays.hh
@@ -40,11 +40,11 @@ namespace Ogre
   class Viewport;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2GpuRaysPrivate;
@@ -62,7 +62,7 @@ namespace ignition
     /// min/max angles and no. of samples. Each ray is a direction vector that
     /// is used to sample/lookup the range data stored in the faces of the
     /// cubemap.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2GpuRays :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2GpuRays :
       public BaseGpuRays<Ogre2Sensor>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Grid.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Grid.hh
index dab992c6b..6f7a44906 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Grid.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Grid.hh
@@ -27,17 +27,17 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2GridPrivate;
 
     /// \brief Ogre2 implementation of a grid geometry.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Grid
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Grid
       : public BaseGrid<Ogre2Geometry>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2GzOgreRenderingMode.hh b/ogre2/include/gz/rendering/ogre2/Ogre2GzOgreRenderingMode.hh
index 92a242616..50f1664cf 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2GzOgreRenderingMode.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2GzOgreRenderingMode.hh
@@ -20,11 +20,11 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/ogre2/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE
     {
       /// \brief Rendering modes so that GzHlms implementations
       /// follow alternate code paths or extra customizations
@@ -52,6 +52,6 @@ namespace ignition
       };
     }  // namespace IGNITION_RENDERING_VERSION_NAMESPACE
   }    // namespace rendering
-}  // namespace ignition
+}  // namespace gz
 
 #endif
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Heightmap.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Heightmap.hh
index 5d02c98c9..e8226780e 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Heightmap.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Heightmap.hh
@@ -24,7 +24,7 @@
 #include "gz/rendering/ogre2/Ogre2Geometry.hh"
 
 // Ignoring warning: "non dll-interface class
-// 'ignition::rendering::v5::Heightmap' used as base for dll-interface class"
+// 'gz::rendering::v5::Heightmap' used as base for dll-interface class"
 // because `Heightmap` and `BaseHeightmap` are header-only
 #ifdef _MSC_VER
  #pragma warning(push)
@@ -37,17 +37,17 @@ namespace Ogre
   class Terra;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2HeightmapPrivate;
 
     /// \brief Ogre implementation of a heightmap geometry.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Heightmap
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Heightmap
       : public BaseHeightmap<Ogre2Geometry>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2InertiaVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2InertiaVisual.hh
index 14dd0d041..b26ad5968 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2InertiaVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2InertiaVisual.hh
@@ -27,17 +27,17 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     // Forward declaration
     class Ogre2InertiaVisualPrivate;
 
     /// \brief Ogre2.x implementation of the inertia visual class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2InertiaVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2InertiaVisual :
       public BaseInertiaVisual<Ogre2Visual>
     {
       /// \brief Constructor
@@ -58,8 +58,8 @@ namespace ignition
       /// \brief Load the Inertia visual from its pose and scale
       /// \param[in] _pose Pose of the Inertia visual
       /// \param[in] _scale Scale factor of the box visual
-      public: void Load(const ignition::math::Pose3d &_pose,
-          const ignition::math::Vector3d &_scale) override;
+      public: void Load(const gz::math::Pose3d &_pose,
+          const gz::math::Vector3d &_scale) override;
 
       /// \brief Get the box visual
       /// \return Pointer to the box visual
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2JointVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2JointVisual.hh
index 985d09d3c..124dafd78 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2JointVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2JointVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseJointVisual.hh"
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2JointVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2JointVisual :
       public BaseJointVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2LidarVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2LidarVisual.hh
index 13ccf6dc3..9b18d67eb 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2LidarVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2LidarVisual.hh
@@ -24,17 +24,17 @@
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 #include "gz/rendering/ogre2/Ogre2Scene.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2LidarVisualPrivate;
 
     /// \brief Ogre 2.x implementation of a Lidar Visual.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2LidarVisual
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2LidarVisual
       : public BaseLidarVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Light.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Light.hh
index 85eff319e..202e36d91 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Light.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Light.hh
@@ -35,17 +35,17 @@ namespace Ogre
   class Light;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2LightPrivate;
 
     /// \brief Ogre 2.x implementation of the light class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Light :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Light :
       public BaseLight<Ogre2Node>
     {
       /// \brief Constructor
@@ -140,7 +140,7 @@ namespace ignition
     };
 
     /// \brief Ogre 2.x implementation of the directional light class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2DirectionalLight :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2DirectionalLight :
       public BaseDirectionalLight<Ogre2Light>
     {
       /// \brief Constructor
@@ -160,7 +160,7 @@ namespace ignition
     };
 
     /// \brief Ogre 2.x implementation of the point light class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2PointLight :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2PointLight :
       public BasePointLight<Ogre2Light>
     {
       /// \brief Constructor
@@ -174,7 +174,7 @@ namespace ignition
     };
 
     /// \brief Ogre 2.x implementation of the spot light class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SpotLight :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2SpotLight :
       public BaseSpotLight<Ogre2Light>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2LightVisual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2LightVisual.hh
index c4ff58d7e..4b8a815bb 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2LightVisual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2LightVisual.hh
@@ -27,17 +27,17 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     // Forward declaration
     class Ogre2LightVisualPrivate;
 
     /// \brief Ogre2.x implementation of the light visual class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2LightVisual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2LightVisual :
       public BaseLightVisual<Ogre2Visual>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Marker.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Marker.hh
index 1364e4f94..777ca5855 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Marker.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Marker.hh
@@ -22,17 +22,17 @@
 #include "gz/rendering/base/BaseMarker.hh"
 #include "gz/rendering/ogre2/Ogre2Geometry.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2MarkerPrivate;
 
     /// \brief Ogre 2.x implementation of a marker geometry.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Marker
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Marker
       : public BaseMarker<Ogre2Geometry>
     {
       /// \brief Constructor
@@ -62,11 +62,11 @@ namespace ignition
 
       // Documentation inherited
       public: virtual void SetPoint(unsigned int _index,
-                           const ignition::math::Vector3d &_value) override;
+                           const gz::math::Vector3d &_value) override;
 
       // Documentation inherited
-      public: virtual void AddPoint(const ignition::math::Vector3d &_pt,
-                           const ignition::math::Color &_color) override;
+      public: virtual void AddPoint(const gz::math::Vector3d &_pt,
+                           const gz::math::Color &_color) override;
 
       // Documentation inherited
       public: virtual void ClearPoints() override;
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Material.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Material.hh
index b570b4884..532032401 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Material.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Material.hh
@@ -39,17 +39,17 @@ namespace Ogre
   class HlmsUnlitDatablock;
 }  // namespace Ogre
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2MaterialPrivate;
 
     /// \brief Ogre 2.x implementation of the material class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Material :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Material :
       public BaseMaterial<Ogre2Object>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2MaterialSwitcher.hh b/ogre2/include/gz/rendering/ogre2/Ogre2MaterialSwitcher.hh
index dab051372..ab58fc025 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2MaterialSwitcher.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2MaterialSwitcher.hh
@@ -38,17 +38,17 @@
   #pragma warning(pop)
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declarations
     class Ogre2SelectionBuffer;
 
     /// \brief Helper class to assign unique colors to renderables
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2MaterialSwitcher :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2MaterialSwitcher :
       public Ogre::Camera::Listener
     {
       /// \brief Constructor
@@ -60,7 +60,7 @@ namespace ignition
       /// \brief Get the entity with a specific color
       /// \param[in] _color The entity's color.
       public: std::string EntityName(
-              const ignition::math::Color &_color) const;
+              const gz::math::Color &_color) const;
 
       /// \brief Reset the color value incrementor
       public: void Reset();
@@ -77,7 +77,7 @@ namespace ignition
       public: virtual void cameraPostRenderScene(Ogre::Camera *_cam) override;
 
       /// \brief Current unique color value
-      private: ignition::math::Color currentColor;
+      private: gz::math::Color currentColor;
 
       /// \brief Color dictionary that maps the unique color value to
       /// renderable name
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Mesh.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Mesh.hh
index ef3c8cd03..0e3e7f900 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Mesh.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Mesh.hh
@@ -33,18 +33,18 @@ namespace Ogre
   class SubItem;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2MeshPrivate;
     class Ogre2SubMeshPrivate;
 
     /// \brief Ogre2.x implementation of the mesh class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Mesh :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Mesh :
       public BaseMesh<Ogre2Geometry>
     {
       /// \brief Constructor
@@ -110,7 +110,7 @@ namespace ignition
     };
 
     /// \brief Ogre2.x implementation of the submesh class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SubMesh :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2SubMesh :
       public BaseSubMesh<Ogre2Object>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2MeshFactory.hh b/ogre2/include/gz/rendering/ogre2/Ogre2MeshFactory.hh
index 43ab40d56..bbc39a79d 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2MeshFactory.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2MeshFactory.hh
@@ -32,18 +32,18 @@ namespace Ogre
   class Item;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2MeshFactoryPrivate;
     class Ogre2SubMeshStoreFactoryPrivate;
 
     /// \brief Ogre2.x implementation of the mesh factory class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2MeshFactory
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2MeshFactory
     {
       /// \brief Constructor
       /// \param[in] _scene Pointer to the scene
@@ -102,7 +102,7 @@ namespace ignition
     };
 
     /// \brief Ogre2.x implementation of a submesh store factory class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SubMeshStoreFactory
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2SubMeshStoreFactory
     {
       /// \brief Constructor
       /// \param[in] _scene Pointer to the scene object
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Node.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Node.hh
index bcf40ffb3..e77611895 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Node.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Node.hh
@@ -26,14 +26,14 @@ namespace Ogre
   class SceneNode;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre2.x implementation of the Node class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Node :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Node :
       public BaseNode<Ogre2Object>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Object.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Object.hh
index 50042bfc6..daa2cda72 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Object.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Object.hh
@@ -22,14 +22,14 @@
 #include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
 #include "gz/rendering/ogre2/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre2.x implementation of the Object class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Object :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Object :
       public BaseObject
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2ObjectInterface.hh b/ogre2/include/gz/rendering/ogre2/Ogre2ObjectInterface.hh
index 4950d1bde..c6fe8cd84 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2ObjectInterface.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2ObjectInterface.hh
@@ -21,14 +21,14 @@
 #include "gz/rendering/ogre2/Ogre2Includes.hh"
 #include "gz/rendering/ogre2/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
     /// \brief Mixin class to provide direct access to Ogre objects.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2ObjectInterface
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2ObjectInterface
     {
       public: virtual ~Ogre2ObjectInterface();
 
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2ParticleEmitter.hh b/ogre2/include/gz/rendering/ogre2/Ogre2ParticleEmitter.hh
index 1eaccba7b..68098eeeb 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2ParticleEmitter.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2ParticleEmitter.hh
@@ -22,17 +22,17 @@
 #include "gz/rendering/base/BaseParticleEmitter.hh"
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2ParticleEmitterPrivate;
 
     /// \brief Class to manage a particle emitter.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2ParticleEmitter :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2ParticleEmitter :
       public BaseParticleEmitter<Ogre2Visual>
     {
       /// \brief Constructor
@@ -49,7 +49,7 @@ namespace ignition
 
       // Documentation inherited.
       public: virtual void SetEmitterSize(
-                  const ignition::math::Vector3d &_size) override;
+                  const gz::math::Vector3d &_size) override;
 
       // Documentation inherited.
       public: virtual void SetRate(double _rate) override;
@@ -62,7 +62,7 @@ namespace ignition
 
       // Documentation inherited.
       public: virtual void SetParticleSize(
-                  const ignition::math::Vector3d &_size) override;
+                  const gz::math::Vector3d &_size) override;
 
       // Documentation inherited.
       public: virtual void SetLifetime(double _lifetime) override;
@@ -76,8 +76,8 @@ namespace ignition
 
       // Documentation inherited.
       public: virtual void SetColorRange(
-                  const ignition::math::Color &_colorStart,
-                  const ignition::math::Color &_colorEnd) override;
+                  const gz::math::Color &_colorStart,
+                  const gz::math::Color &_colorEnd) override;
 
       // Documentation inherited.
       public: virtual void SetScaleRate(double _scaleRate) override;
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2RayQuery.hh b/ogre2/include/gz/rendering/ogre2/Ogre2RayQuery.hh
index 6d77a4642..05d53c3aa 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2RayQuery.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2RayQuery.hh
@@ -23,11 +23,11 @@
 #include "gz/rendering/ogre2/Ogre2Object.hh"
 #include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2RayQueryPrivate;
@@ -35,7 +35,7 @@ namespace ignition
     /// \class Ogre2RayQuery Ogre2RayQuery.hh
     /// gz/rendering/ogre2/Ogre2RayQuery.hh
     /// \brief A Ray Query class used for computing ray object intersections
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RayQuery :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RayQuery :
         public BaseRayQuery<Ogre2Object>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2RenderEngine.hh b/ogre2/include/gz/rendering/ogre2/Ogre2RenderEngine.hh
index 1a9b634ac..234bd4a38 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2RenderEngine.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2RenderEngine.hh
@@ -46,18 +46,18 @@ namespace Ogre
   class CompositorWorkspaceListener;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2RenderEnginePrivate;
     class Ogre2GzHlmsSphericalClipMinDistance;
 
     /// \brief Plugin for loading ogre render engine
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RenderEnginePlugin :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RenderEnginePlugin :
       public RenderEnginePlugin
     {
       /// \brief Constructor
@@ -78,7 +78,7 @@ namespace ignition
     /// \brief Ogre2 render engine class. A singleton class that manages the
     /// underlying ogre2 render engine, loads its plugins, and creates
     /// resources needed for the engine to run
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RenderEngine :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RenderEngine :
       public virtual BaseRenderEngine,
       public common::SingletonT<Ogre2RenderEngine>
     {
@@ -180,7 +180,7 @@ namespace ignition
       public: std::vector<unsigned int> FSAALevels() const;
 
       /// \brief Deprecated. Use SphericalClipMinDistance instead
-      public: Ogre2GzHlmsSphericalClipMinDistance IGN_DEPRECATED(7) &
+      public: Ogre2GzHlmsSphericalClipMinDistance GZ_DEPRECATED(7) &
           HlmsCustomizations();
 
       /// \brief Retrieves Hlms customizations for tweaking them
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2RenderPass.hh b/ogre2/include/gz/rendering/ogre2/Ogre2RenderPass.hh
index 0d13e7f32..741419b28 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2RenderPass.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2RenderPass.hh
@@ -24,11 +24,11 @@
 #include "gz/rendering/ogre2/Export.hh"
 #include "gz/rendering/ogre2/Ogre2Object.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2RenderPassPrivate;
@@ -49,7 +49,7 @@ namespace ignition
     /// the next RenderPass. Note that the Ogre2RenderPass class provides the
     /// node definition only and the actual node creation work is done in the
     /// Ogre2RenderTarget class when the whole workspace is constructed.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RenderPass :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RenderPass :
       public BaseRenderPass<Ogre2Object>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2RenderTarget.hh b/ogre2/include/gz/rendering/ogre2/Ogre2RenderTarget.hh
index 281899b71..d0f2551f2 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2RenderTarget.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2RenderTarget.hh
@@ -42,17 +42,17 @@ namespace Ogre
   class Texture;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2RenderTargetPrivate;
 
     /// \brief Ogre2.x implementation of the render target class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RenderTarget :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RenderTarget :
       public virtual BaseRenderTarget<Ogre2Object>
     {
       /// \brief Constructor
@@ -235,7 +235,7 @@ namespace ignition
     };
 
     /// \brief Ogre2.x implementation of the render texture class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RenderTexture :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RenderTexture :
       public virtual BaseRenderTexture<Ogre2RenderTarget>
     {
       /// \brief Constructor
@@ -278,7 +278,7 @@ namespace ignition
     };
 
     /// \brief Ogre2.x implementation of the render window class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2RenderWindow :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2RenderWindow :
       public virtual BaseRenderWindow<Ogre2RenderTarget>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2RenderTargetMaterial.hh b/ogre2/include/gz/rendering/ogre2/Ogre2RenderTargetMaterial.hh
index 6488a3ef6..34303f033 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2RenderTargetMaterial.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2RenderTargetMaterial.hh
@@ -37,11 +37,11 @@
   #pragma warning(disable:4275)
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Causes all objects in a scene to be rendered with the same
     /// material when rendered by a given RenderTarget.
@@ -55,7 +55,7 @@ namespace ignition
     /// Every time ogre tries to get a technique for a material it will call
     /// handleSchemeNotFound which returns the first supported technique on the
     /// material provided to this class's constructor.
-    class IGNITION_RENDERING_OGRE2_VISIBLE  Ogre2RenderTargetMaterial :
+    class GZ_RENDERING_OGRE2_VISIBLE  Ogre2RenderTargetMaterial :
       public Ogre::Camera::Listener,
       public Ogre::MaterialManager::Listener
     {
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2RenderTypes.hh b/ogre2/include/gz/rendering/ogre2/Ogre2RenderTypes.hh
index 3dd7d28e8..036b71d66 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2RenderTypes.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2RenderTypes.hh
@@ -22,11 +22,11 @@
 #include "gz/rendering/config.hh"
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class Ogre2ArrowVisual;
     class Ogre2AxisVisual;
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Scene.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Scene.hh
index ae1f766d9..d57a8b59c 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Scene.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Scene.hh
@@ -44,17 +44,17 @@ namespace Ogre
   class SceneManager;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2ScenePrivate;
     //
     /// \brief Ogre2.x implementation of the scene class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Scene :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Scene :
       public BaseScene
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2SegmentationCamera.hh b/ogre2/include/gz/rendering/ogre2/Ogre2SegmentationCamera.hh
index 6f383cdd3..9b52b7212 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2SegmentationCamera.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2SegmentationCamera.hh
@@ -35,18 +35,18 @@
 #include "gz/rendering/ogre2/Ogre2ObjectInterface.hh"
 #include "gz/rendering/ogre2/Ogre2Sensor.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2SegmentationCameraPrivate;
 
     /// \brief Segmentation camera used to label each pixel with a label id.
     /// Supports Semantic / Panoptic Segmentation
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SegmentationCamera :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2SegmentationCamera :
       public virtual BaseSegmentationCamera<Ogre2Sensor>,
       public virtual Ogre2ObjectInterface
     {
@@ -69,7 +69,7 @@ namespace ignition
       public: virtual void PostRender() override;
 
       // Documentation inherited
-      public: virtual ignition::common::ConnectionPtr
+      public: virtual gz::common::ConnectionPtr
         ConnectNewSegmentationFrame(
         std::function<void(const uint8_t *, unsigned int, unsigned int,
         unsigned int, const std::string &)>  _subscriber) override;
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2SelectionBuffer.hh b/ogre2/include/gz/rendering/ogre2/Ogre2SelectionBuffer.hh
index 6aaf3356c..610a045d3 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2SelectionBuffer.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2SelectionBuffer.hh
@@ -30,11 +30,11 @@ namespace Ogre
   class SceneManager;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     struct Ogre2SelectionBufferPrivate;
@@ -44,7 +44,7 @@ namespace ignition
     /// color is assigned to each entity. Whenever a selection request is made,
     /// the selection buffer camera renders to a 1x1 sized offscreen buffer.
     /// The color value of that pixel gives the identity of the entity.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SelectionBuffer
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2SelectionBuffer
     {
       /// \brief Constructor
       /// \param[in] _cameraName Name of the camera to generate a selection
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Sensor.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Sensor.hh
index 00141d7e0..cb1a2c62b 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Sensor.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Sensor.hh
@@ -20,14 +20,14 @@
 #include "gz/rendering/base/BaseSensor.hh"
 #include "gz/rendering/ogre2/Ogre2Node.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Ogre2.x implementation of the sensor classs
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Sensor :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Sensor :
       public BaseSensor<Ogre2Node>
     {
       /// \brief Constructor
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Storage.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Storage.hh
index 6bb732a8b..f3316827a 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Storage.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Storage.hh
@@ -29,15 +29,15 @@
 #include "gz/rendering/ogre2/Ogre2Scene.hh"
 #include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
 // armhf failed to build with this code. It can not be removed for the rest
 // of arches to keep ABI but should be removed in major versions unreleased
-// see https://github.com/ignitionrobotics/ign-rendering/pull/457
+// see https://github.com/gazebosim/gz-rendering/pull/457
 #ifndef __ARM_PCS_VFP
     template class BaseGeometryStore<Ogre2Geometry>;
     template class BaseLightStore<Ogre2Light>;
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2ThermalCamera.hh b/ogre2/include/gz/rendering/ogre2/Ogre2ThermalCamera.hh
index e42c9843f..8fbc57a4f 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2ThermalCamera.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2ThermalCamera.hh
@@ -43,17 +43,17 @@ namespace Ogre
   class Viewport;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2ThermalCameraPrivate;
 
     /// \brief Thermal camera used to render thermal data into an image buffer
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2ThermalCamera :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2ThermalCamera :
       public virtual BaseThermalCamera<Ogre2Sensor>,
       public virtual Ogre2ObjectInterface
     {
@@ -78,7 +78,7 @@ namespace ignition
       /// \brief Connect to the new thermal image event
       /// \param[in] _subscriber Subscriber callback function
       /// \return Pointer to the new Connection. This must be kept in scope
-      public: virtual ignition::common::ConnectionPtr ConnectNewThermalFrame(
+      public: virtual gz::common::ConnectionPtr ConnectNewThermalFrame(
           std::function<void(const uint16_t *, unsigned int, unsigned int,
           unsigned int, const std::string &)>  _subscriber) override;
 
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2Visual.hh b/ogre2/include/gz/rendering/ogre2/Ogre2Visual.hh
index eec1bbdbc..62ede7bbf 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2Visual.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2Visual.hh
@@ -24,17 +24,17 @@
 #include "gz/rendering/ogre2/Ogre2Node.hh"
 #include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // forward declaration
     class Ogre2VisualPrivate;
 
     /// \brief Ogre2.x implementation of the visual class
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2Visual :
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2Visual :
       public BaseVisual<Ogre2Node>
     {
       /// \brief Constructor
@@ -56,11 +56,11 @@ namespace ignition
       public: virtual void SetVisibilityFlags(uint32_t _flags) override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox BoundingBox()
+      public: virtual gz::math::AxisAlignedBox BoundingBox()
                   const override;
 
       // Documentation inherited.
-      public: virtual ignition::math::AxisAlignedBox LocalBoundingBox()
+      public: virtual gz::math::AxisAlignedBox LocalBoundingBox()
                   const override;
 
       /// \brief Recursively loop through this visual's children
@@ -70,8 +70,8 @@ namespace ignition
       /// be calculated.
       /// \param[in] _pose World pose of the visual
       private: virtual void BoundsHelper(
-                     ignition::math::AxisAlignedBox &_box, bool _local,
-                     const ignition::math::Pose3d &_pose) const;
+                     gz::math::AxisAlignedBox &_box, bool _local,
+                     const gz::math::Pose3d &_pose) const;
 
       /// \brief Wrapper function for BoundsHelper to reduce redundant
       /// world pose access
@@ -79,7 +79,7 @@ namespace ignition
       /// \param[in] _local A flag indicating if the local bounding box is to
       /// be calculated.
       private: virtual void BoundsHelper(
-                     ignition::math::AxisAlignedBox &_box, bool _local) const;
+                     gz::math::AxisAlignedBox &_box, bool _local) const;
 
       // Documentation inherited.
       protected: virtual GeometryStorePtr Geometries() const override;
diff --git a/ogre2/include/gz/rendering/ogre2/Ogre2WireBox.hh b/ogre2/include/gz/rendering/ogre2/Ogre2WireBox.hh
index f26d42605..111c539a9 100644
--- a/ogre2/include/gz/rendering/ogre2/Ogre2WireBox.hh
+++ b/ogre2/include/gz/rendering/ogre2/Ogre2WireBox.hh
@@ -27,17 +27,17 @@ namespace Ogre
   class MovableObject;
 }
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     // Forward declaration
     class Ogre2WireBoxPrivate;
 
     /// \brief Ogre2 implementation of a wire box geometry.
-    class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2WireBox
+    class GZ_RENDERING_OGRE2_VISIBLE Ogre2WireBox
       : public BaseWireBox<Ogre2Geometry>
     {
       /// \brief Constructor
diff --git a/ogre2/include/ignition/rendering/ogre2.hh b/ogre2/include/ignition/rendering/ogre2.hh
index e3826fd92..d1fc687de 100644
--- a/ogre2/include/ignition/rendering/ogre2.hh
+++ b/ogre2/include/ignition/rendering/ogre2.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Export.hh b/ogre2/include/ignition/rendering/ogre2/Export.hh
index 3d6d75e98..fdabd6698 100644
--- a/ogre2/include/ignition/rendering/ogre2/Export.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Export.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Export.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2ArrowVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2ArrowVisual.hh
index 59357cd1e..42742b10d 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2ArrowVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2ArrowVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2ArrowVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2AxisVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2AxisVisual.hh
index 5eb9e970f..e57962424 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2AxisVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2AxisVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2AxisVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2COMVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2COMVisual.hh
index 523d0781f..b7eb4ccba 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2COMVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2COMVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2COMVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Camera.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Camera.hh
index c3e18fdd3..7532566d6 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Camera.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Camera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Camera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Capsule.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Capsule.hh
index c5014fa30..a6486c315 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Capsule.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Capsule.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Capsule.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Conversions.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Conversions.hh
index 68df00907..acdf2e13b 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Conversions.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Conversions.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Conversions.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2DepthCamera.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2DepthCamera.hh
index 8eaf8dc05..628463607 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2DepthCamera.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2DepthCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2DepthCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2DynamicRenderable.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2DynamicRenderable.hh
index 310188740..cd946fb9a 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2DynamicRenderable.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2DynamicRenderable.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2DynamicRenderable.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2GaussianNoisePass.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2GaussianNoisePass.hh
index 9cccd0af5..3ab8d7256 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2GaussianNoisePass.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2GaussianNoisePass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2GaussianNoisePass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Geometry.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Geometry.hh
index dac66aba0..af08f4d63 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Geometry.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Geometry.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Geometry.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2GizmoVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2GizmoVisual.hh
index b8e9f1ebf..b7201ac10 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2GizmoVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2GizmoVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2GizmoVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2GpuRays.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2GpuRays.hh
index 7c4352820..e42b4893c 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2GpuRays.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2GpuRays.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2GpuRays.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Grid.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Grid.hh
index 0269e078d..aa70377a4 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Grid.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Grid.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Grid.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Heightmap.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Heightmap.hh
index d877ae3ea..313268703 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Heightmap.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Heightmap.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Heightmap.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2IgnOgreRenderingMode.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2IgnOgreRenderingMode.hh
index 4cfb48df9..1a6a1fa77 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2IgnOgreRenderingMode.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2IgnOgreRenderingMode.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2GzOgreRenderingMode.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Includes.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Includes.hh
index d77808390..dcf1b1df9 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Includes.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Includes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Includes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2InertiaVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2InertiaVisual.hh
index 479c80b09..cd391072e 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2InertiaVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2InertiaVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2InertiaVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2JointVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2JointVisual.hh
index 59a243982..a24ad6749 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2JointVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2JointVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2JointVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2LidarVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2LidarVisual.hh
index f69378f9f..ddfc0f043 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2LidarVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2LidarVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2LidarVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Light.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Light.hh
index 57ea35043..7a380cca4 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Light.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Light.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Light.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2LightVisual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2LightVisual.hh
index 12ac08d7e..f7485b288 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2LightVisual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2LightVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2LightVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Marker.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Marker.hh
index 722485873..3b8b64eec 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Marker.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Marker.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Marker.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Material.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Material.hh
index 2434b36df..a886a16aa 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Material.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Material.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Material.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2MaterialSwitcher.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2MaterialSwitcher.hh
index e2edba50f..c93da6b97 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2MaterialSwitcher.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2MaterialSwitcher.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2MaterialSwitcher.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Mesh.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Mesh.hh
index f0c10737a..6d0bdffb5 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Mesh.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Mesh.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Mesh.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2MeshFactory.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2MeshFactory.hh
index 52e148fb7..0be086a8f 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2MeshFactory.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2MeshFactory.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2MeshFactory.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Node.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Node.hh
index b382cfac7..d53e6937a 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Node.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Node.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Node.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Object.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Object.hh
index f54faaa09..6efcc6cd7 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Object.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Object.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Object.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2ObjectInterface.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2ObjectInterface.hh
index e6a0500b2..e8f361b2f 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2ObjectInterface.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2ObjectInterface.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2ObjectInterface.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2ParticleEmitter.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2ParticleEmitter.hh
index f0861ef8b..5cbf2627e 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2ParticleEmitter.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2ParticleEmitter.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2ParticleEmitter.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2RayQuery.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2RayQuery.hh
index eceb2e4b5..9c93d661b 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2RayQuery.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2RayQuery.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2RayQuery.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderEngine.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderEngine.hh
index e417dd198..f1fea5810 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderEngine.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderEngine.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2RenderEngine.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderPass.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderPass.hh
index ef71b300a..d44917894 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderPass.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderPass.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2RenderPass.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTarget.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTarget.hh
index 8a4240795..5fc01059f 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTarget.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTarget.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2RenderTarget.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTargetMaterial.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTargetMaterial.hh
index b7c7c40ed..b5341766e 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTargetMaterial.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTargetMaterial.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2RenderTargetMaterial.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTypes.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTypes.hh
index c0ab47811..859aa03f6 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTypes.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2RenderTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2RenderTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Scene.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Scene.hh
index c6deba168..324475a25 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Scene.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Scene.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Scene.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2SegmentationCamera.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2SegmentationCamera.hh
index d1cd9a749..43353d5d9 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2SegmentationCamera.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2SegmentationCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2SegmentationCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2SelectionBuffer.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2SelectionBuffer.hh
index 4cbbe9334..f2e20ae43 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2SelectionBuffer.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2SelectionBuffer.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2SelectionBuffer.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Sensor.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Sensor.hh
index 49baa7263..9b158f195 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Sensor.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Sensor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Sensor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Storage.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Storage.hh
index 5abf53084..5db81fa7f 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Storage.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Storage.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Storage.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2ThermalCamera.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2ThermalCamera.hh
index 505c140f0..bb22a4e8d 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2ThermalCamera.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2ThermalCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2ThermalCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2Visual.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2Visual.hh
index 353a6310c..d1150df79 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2Visual.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2Visual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2Visual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/Ogre2WireBox.hh b/ogre2/include/ignition/rendering/ogre2/Ogre2WireBox.hh
index a8eaae4fe..7023d0c3d 100644
--- a/ogre2/include/ignition/rendering/ogre2/Ogre2WireBox.hh
+++ b/ogre2/include/ignition/rendering/ogre2/Ogre2WireBox.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/Ogre2WireBox.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/include/ignition/rendering/ogre2/detail/Export.hh b/ogre2/include/ignition/rendering/ogre2/detail/Export.hh
index e6d0f0430..6af2dae73 100644
--- a/ogre2/include/ignition/rendering/ogre2/detail/Export.hh
+++ b/ogre2/include/ignition/rendering/ogre2/detail/Export.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/ogre2/detail/Export.hh>
+#include <ignition/rendering/config.hh>
diff --git a/ogre2/src/CMakeLists.txt b/ogre2/src/CMakeLists.txt
index bd3975cce..a5fa23fcc 100644
--- a/ogre2/src/CMakeLists.txt
+++ b/ogre2/src/CMakeLists.txt
@@ -22,7 +22,7 @@ add_definitions(-DOGRE_IGNORE_UNKNOWN_DEBUG)
 set_property(
   SOURCE Ogre2RenderEngine.cc
   PROPERTY COMPILE_DEFINITIONS
-  IGN_RENDERING_RESOURCE_PATH="${IGN_RENDERING_RESOURCE_PATH}"
+  GZ_RENDERING_RESOURCE_PATH="${GZ_RENDERING_RESOURCE_PATH}"
   OGRE2_RESOURCE_PATH="${OGRE2_RESOURCE_PATH}"
   OGRE2_VERSION="${OGRE2_VERSION}"
 )
@@ -45,20 +45,20 @@ set (versioned ${CMAKE_SHARED_LIBRARY_PREFIX}${PROJECT_NAME_LOWER}-${engine_name
 set (unversioned ${CMAKE_SHARED_LIBRARY_PREFIX}${PROJECT_NAME_NO_VERSION_LOWER}-${engine_name}${CMAKE_SHARED_LIBRARY_SUFFIX})
 
 # Note that plugins are currently being installed in 2 places: /lib and the engine-plugins dir
-install(TARGETS ${ogre2_target} DESTINATION ${IGNITION_RENDERING_ENGINE_INSTALL_DIR})
+install(TARGETS ${ogre2_target} DESTINATION ${GZ_RENDERING_ENGINE_INSTALL_DIR})
 
 if (WIN32)
   # disable MSVC inherit via dominance warning
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /wd4250")
   INSTALL(CODE "EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E copy
-  ${IGNITION_RENDERING_ENGINE_INSTALL_DIR}\/${versioned}
-  ${IGNITION_RENDERING_ENGINE_INSTALL_DIR}\/${unversioned})")
+  ${GZ_RENDERING_ENGINE_INSTALL_DIR}\/${versioned}
+  ${GZ_RENDERING_ENGINE_INSTALL_DIR}\/${unversioned})")
 else()
   EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E create_symlink ${versioned} ${unversioned})
-  INSTALL(FILES ${PROJECT_BINARY_DIR}/${unversioned} DESTINATION ${IGNITION_RENDERING_ENGINE_INSTALL_DIR})
+  INSTALL(FILES ${PROJECT_BINARY_DIR}/${unversioned} DESTINATION ${GZ_RENDERING_ENGINE_INSTALL_DIR})
 endif()
 
 # Build the unit tests
 ign_build_tests(TYPE UNIT SOURCES ${gtest_sources} LIB_DEPS ${ogre2_target})
 
-install(DIRECTORY "media"  DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/ogre2)
+install(DIRECTORY "media"  DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/ogre2)
diff --git a/ogre2/src/Ogre2ArrowVisual.cc b/ogre2/src/Ogre2ArrowVisual.cc
index 1b5eb9e52..9d101caae 100644
--- a/ogre2/src/Ogre2ArrowVisual.cc
+++ b/ogre2/src/Ogre2ArrowVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2ArrowVisual.hh"
+#include "gz/rendering/ogre2/Ogre2ArrowVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2AxisVisual.cc b/ogre2/src/Ogre2AxisVisual.cc
index d78d66879..75f8a6648 100644
--- a/ogre2/src/Ogre2AxisVisual.cc
+++ b/ogre2/src/Ogre2AxisVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2AxisVisual.hh"
+#include "gz/rendering/ogre2/Ogre2AxisVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2COMVisual.cc b/ogre2/src/Ogre2COMVisual.cc
index 6d9052b4b..03d3d67b9 100644
--- a/ogre2/src/Ogre2COMVisual.cc
+++ b/ogre2/src/Ogre2COMVisual.cc
@@ -15,9 +15,9 @@
  *
  */
 
-#include "ignition/rendering/ogre2/Ogre2COMVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2COMVisual.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -27,7 +27,7 @@
   #pragma warning(pop)
 #endif
 
-class ignition::rendering::Ogre2COMVisualPrivate
+class gz::rendering::Ogre2COMVisualPrivate
 {
   /// \brief Grid materal
   public: Ogre2MaterialPtr material = nullptr;
@@ -39,7 +39,7 @@ class ignition::rendering::Ogre2COMVisualPrivate
   public: VisualPtr sphereVis = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -116,14 +116,14 @@ void Ogre2COMVisual::CreateVisual()
   }
 
   double sphereRadius = this->SphereRadius();
-  this->dataPtr->sphereVis->SetLocalScale(ignition::math::Vector3d(
+  this->dataPtr->sphereVis->SetLocalScale(gz::math::Vector3d(
       sphereRadius*2, sphereRadius*2, sphereRadius*2));
   this->dataPtr->sphereVis->SetLocalPosition(this->InertiaPose().Pos());
   this->dataPtr->sphereVis->SetLocalRotation(this->InertiaPose().Rot());
 
   // Get the bounding box of the parent visual
   VisualPtr vis = this->Scene()->VisualByName(this->parentName);
-  ignition::math::AxisAlignedBox box;
+  gz::math::AxisAlignedBox box;
   if (vis)
     box = vis->LocalBoundingBox();
 
@@ -140,19 +140,19 @@ void Ogre2COMVisual::CreateVisual()
   }
 
   // CoM position indicator
-  ignition::math::Vector3d p1(0, 0,
+  gz::math::Vector3d p1(0, 0,
       box.Min().Z() - this->InertiaPose().Pos().Z());
-  ignition::math::Vector3d p2(0, 0,
+  gz::math::Vector3d p2(0, 0,
       box.Max().Z() - this->InertiaPose().Pos().Z());
 
-  ignition::math::Vector3d p3(0,
+  gz::math::Vector3d p3(0,
       box.Min().Y() - this->InertiaPose().Pos().Y(), 0);
-  ignition::math::Vector3d p4(0,
+  gz::math::Vector3d p4(0,
       box.Max().Y() - this->InertiaPose().Pos().Y(), 0);
 
-  ignition::math::Vector3d p5(
+  gz::math::Vector3d p5(
       box.Min().X() - this->InertiaPose().Pos().X(), 0, 0);
-  ignition::math::Vector3d p6(
+  gz::math::Vector3d p6(
       box.Max().X() - this->InertiaPose().Pos().X(), 0, 0);
 
   p1 += this->InertiaPose().Pos();
@@ -183,7 +183,7 @@ void Ogre2COMVisual::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2Camera.cc b/ogre2/src/Ogre2Camera.cc
index 59c91b871..f95e5e41a 100644
--- a/ogre2/src/Ogre2Camera.cc
+++ b/ogre2/src/Ogre2Camera.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include "ignition/rendering/ogre2/Ogre2Camera.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2SelectionBuffer.hh"
-#include "ignition/rendering/Utils.hh"
+#include "gz/rendering/ogre2/Ogre2Camera.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2SelectionBuffer.hh"
+#include "gz/rendering/Utils.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -33,11 +33,11 @@
 #endif
 
 /// \brief Private data for the Ogre2Camera class
-class ignition::rendering::Ogre2CameraPrivate
+class gz::rendering::Ogre2CameraPrivate
 {
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -62,7 +62,7 @@ void Ogre2Camera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   if (ogreSceneManager->findCameraNoThrow(this->name) != nullptr)
   {
@@ -255,7 +255,7 @@ Ogre2SelectionBuffer *Ogre2Camera::SelectionBuffer() const
 }
 
 //////////////////////////////////////////////////
-VisualPtr Ogre2Camera::VisualAt(const ignition::math::Vector2i &_mousePos)
+VisualPtr Ogre2Camera::VisualAt(const gz::math::Vector2i &_mousePos)
 {
   VisualPtr result;
 
@@ -275,7 +275,7 @@ VisualPtr Ogre2Camera::VisualAt(const ignition::math::Vector2i &_mousePos)
   }
 
   float ratio = screenScalingFactor();
-  ignition::math::Vector2i mousePos(
+  gz::math::Vector2i mousePos(
       static_cast<int>(std::rint(ratio * _mousePos.X())),
       static_cast<int>(std::rint(ratio * _mousePos.Y())));
   Ogre::Item *ogreItem = this->selectionBuffer->OnSelectionClick(
@@ -294,7 +294,7 @@ VisualPtr Ogre2Camera::VisualAt(const ignition::math::Vector2i &_mousePos)
       }
       catch(Ogre::Exception &e)
       {
-        ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+        gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
       }
     }
   }
diff --git a/ogre2/src/Ogre2Capsule.cc b/ogre2/src/Ogre2Capsule.cc
index cf6560e5f..1ee7adfee 100644
--- a/ogre2/src/Ogre2Capsule.cc
+++ b/ogre2/src/Ogre2Capsule.cc
@@ -17,16 +17,16 @@
 
 #include <cmath>
 
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Capsule.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Mesh.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/ogre2/Ogre2Capsule.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Mesh.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-class ignition::rendering::Ogre2CapsulePrivate
+class gz::rendering::Ogre2CapsulePrivate
 {
   /// \brief Capsule materal
   public: Ogre2MaterialPtr material{nullptr};
@@ -35,7 +35,7 @@ class ignition::rendering::Ogre2CapsulePrivate
   public: Ogre2MeshPtr ogreMesh{nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -106,7 +106,7 @@ void Ogre2Capsule::Update()
   meshDescriptor.mesh = meshMgr->MeshByName(capsuleMeshName);
   if (meshDescriptor.mesh == nullptr)
   {
-    ignerr << "Capsule mesh is unavailable in the Mesh Manager" << std::endl;
+    gzerr << "Capsule mesh is unavailable in the Mesh Manager" << std::endl;
     return;
   }
 
@@ -145,7 +145,7 @@ void Ogre2Capsule::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2Conversions.cc b/ogre2/src/Ogre2Conversions.cc
index ea208b9be..f2f9f325e 100644
--- a/ogre2/src/Ogre2Conversions.cc
+++ b/ogre2/src/Ogre2Conversions.cc
@@ -14,7 +14,7 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -24,7 +24,7 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2DepthCamera.cc b/ogre2/src/Ogre2DepthCamera.cc
index 5b3e98adf..f06188cb7 100644
--- a/ogre2/src/Ogre2DepthCamera.cc
+++ b/ogre2/src/Ogre2DepthCamera.cc
@@ -33,27 +33,27 @@
 #endif
 
 #include <math.h>
-#include <ignition/math/Helpers.hh>
-
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2DepthCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2GaussianNoisePass.hh"
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Sensor.hh"
+#include <gz/math/Helpers.hh>
+
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2DepthCamera.hh"
+#include "gz/rendering/ogre2/Ogre2GaussianNoisePass.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Sensor.hh"
 
 #include "Ogre2ParticleNoiseListener.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /// \brief Gaussian noise render pass for depth cameras
 /// The class implementation is very similar to Ogre2GaussianNoisePass but
@@ -83,7 +83,7 @@ class Ogre2DepthGaussianNoisePass : public Ogre2GaussianNoisePass
 
 /// \internal
 /// \brief Private data for the Ogre2DepthCamera class
-class ignition::rendering::Ogre2DepthCameraPrivate
+class gz::rendering::Ogre2DepthCameraPrivate
 {
   /// \brief The depth buffer
   public: float *depthBuffer = nullptr;
@@ -95,10 +95,10 @@ class ignition::rendering::Ogre2DepthCameraPrivate
   public: float *pointCloudImage = nullptr;
 
   /// \brief maximum value used for data outside sensor range
-  public: float dataMaxVal = ignition::math::INF_D;
+  public: float dataMaxVal = gz::math::INF_D;
 
   /// \brief minimum value used for data outside sensor range
-  public: float dataMinVal = -ignition::math::INF_D;
+  public: float dataMinVal = -gz::math::INF_D;
 
   /// \brief 1st pass compositor workspace definition
   public: std::string ogreCompositorWorkspaceDef;
@@ -131,12 +131,12 @@ class ignition::rendering::Ogre2DepthCameraPrivate
   public: bool renderPassDirty = false;
 
   /// \brief Event used to signal rgb point cloud data
-  public: ignition::common::EventT<void(const float *,
+  public: gz::common::EventT<void(const float *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newRgbPointCloud;
 
   /// \brief Event used to signal depth data
-  public: ignition::common::EventT<void(const float *,
+  public: gz::common::EventT<void(const float *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newDepthFrame;
 
@@ -158,7 +158,7 @@ class ignition::rendering::Ogre2DepthCameraPrivate
   public: const std::string kShadowNodeName = "PbsMaterialsShadowNode";
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -173,9 +173,9 @@ void Ogre2DepthGaussianNoisePass::PreRender()
   if (!this->enabled)
     return;
 
-  Ogre::Vector3 offsets(ignition::math::Rand::DblUniform(0.0, 1.0),
-                        ignition::math::Rand::DblUniform(0.0, 1.0),
-                        ignition::math::Rand::DblUniform(0.0, 1.0));
+  Ogre::Vector3 offsets(gz::math::Rand::DblUniform(0.0, 1.0),
+                        gz::math::Rand::DblUniform(0.0, 1.0),
+                        gz::math::Rand::DblUniform(0.0, 1.0));
 
   Ogre::Pass *pass = this->gaussianNoiseMat->getTechnique(0)->getPass(0);
   Ogre::GpuProgramParametersSharedPtr psParams =
@@ -211,7 +211,7 @@ void Ogre2DepthGaussianNoisePass::CreateRenderPass()
       Ogre::MaterialManager::getSingleton().getByName(matName);
   if (!ogreMat)
   {
-    ignerr << "Gaussian noise material not found: '" << matName << "'"
+    gzerr << "Gaussian noise material not found: '" << matName << "'"
            << std::endl;
     return;
   }
@@ -343,7 +343,7 @@ void Ogre2DepthCamera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   else
   {
@@ -363,14 +363,14 @@ void Ogre2DepthCamera::CreateCamera()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
   this->ogreCamera = ogreSceneManager->createCamera(this->name);
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -495,7 +495,7 @@ void Ogre2DepthCamera::CreateDepthTexture()
       auto skyboxMat = matManager.getByName(this->dataPtr->kSkyboxMaterialName);
       if (!skyboxMat)
       {
-        ignerr << "Unable to find skybox material" << std::endl;
+        gzerr << "Unable to find skybox material" << std::endl;
         return;
       }
       mat = skyboxMat->clone(skyMatName);
@@ -882,7 +882,7 @@ void Ogre2DepthCamera::CreateDepthTexture()
 
   if (!wsDef)
   {
-    ignerr << "Unable to add workspace definition [" << wsDefName << "] "
+    gzerr << "Unable to add workspace definition [" << wsDefName << "] "
            << " for " << this->Name();
   }
 
@@ -1116,34 +1116,34 @@ void Ogre2DepthCamera::PostRender()
     //     unsigned int r = *rgba >> 24 & 0xFF;
     //     unsigned int g = *rgba >> 16 & 0xFF;
     //     unsigned int b = *rgba >> 8 & 0xFF;
-    //     igndbg << "[" << r << "]" << "[" << g << "]" << "[" << b << "],";
+    //     gzdbg << "[" << r << "]" << "[" << g << "]" << "[" << b << "],";
     //   }
-    //   igndbg << std::endl;
+    //   gzdbg << std::endl;
     // }
 
     // Uncomment to debug xyz output
-    // igndbg << "wxh: " << width << " x " << height << std::endl;
+    // gzdbg << "wxh: " << width << " x " << height << std::endl;
     // for (unsigned int i = 0; i < height; ++i)
     // {
     //   for (unsigned int j = 0; j < width; ++j)
     //   {
-    //     igndbg << "[" << this->dataPtr->pointCloudImage[i*width*4+j*4] << "]"
+    //     gzdbg << "[" << this->dataPtr->pointCloudImage[i*width*4+j*4] << "]"
     //       << "[" << this->dataPtr->pointCloudImage[i*width*4+j*4+1] << "]"
     //       << "[" << this->dataPtr->pointCloudImage[i*width*4+j*4+2] << "],";
     //   }
-    //   igndbg << std::endl;
+    //   gzdbg << std::endl;
     // }
   }
 
   // Uncomment to debug depth output
-  // igndbg << "wxh: " << width << " x " << height << std::endl;
+  // gzdbg << "wxh: " << width << " x " << height << std::endl;
   // for (unsigned int i = 0; i < height; ++i)
   // {
   //   for (unsigned int j = 0; j < width; ++j)
   //   {
-  //     igndbg << "[" << this->dataPtr->depthImage[i*width + j] << "]";
+  //     gzdbg << "[" << this->dataPtr->depthImage[i*width + j] << "]";
   //   }
-  //   igndbg << std::endl;
+  //   gzdbg << std::endl;
   // }
 }
 
@@ -1154,7 +1154,7 @@ const float *Ogre2DepthCamera::DepthData() const
 }
 
 //////////////////////////////////////////////////
-ignition::common::ConnectionPtr Ogre2DepthCamera::ConnectNewDepthFrame(
+gz::common::ConnectionPtr Ogre2DepthCamera::ConnectNewDepthFrame(
     std::function<void(const float *, unsigned int, unsigned int,
       unsigned int, const std::string &)>  _subscriber)
 {
@@ -1162,7 +1162,7 @@ ignition::common::ConnectionPtr Ogre2DepthCamera::ConnectNewDepthFrame(
 }
 
 //////////////////////////////////////////////////
-ignition::common::ConnectionPtr Ogre2DepthCamera::ConnectNewRgbPointCloud(
+gz::common::ConnectionPtr Ogre2DepthCamera::ConnectNewRgbPointCloud(
     std::function<void(const float *, unsigned int, unsigned int,
       unsigned int, const std::string &)>  _subscriber)
 {
@@ -1246,7 +1246,7 @@ void Ogre2DepthCamera::AddRenderPass(const RenderPassPtr &_pass)
       std::dynamic_pointer_cast<Ogre2GaussianNoisePass>(_pass);
   if (!pass)
   {
-    ignerr << "Depth camera currently only supports a gaussian noise pass"
+    gzerr << "Depth camera currently only supports a gaussian noise pass"
            << std::endl;
     return;
   }
diff --git a/ogre2/src/Ogre2DynamicRenderable.cc b/ogre2/src/Ogre2DynamicRenderable.cc
index 30cec97ed..6f10afe78 100644
--- a/ogre2/src/Ogre2DynamicRenderable.cc
+++ b/ogre2/src/Ogre2DynamicRenderable.cc
@@ -25,12 +25,12 @@
 #pragma warning(pop)
 #endif
 
-#include "ignition/common/Console.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/common/Console.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -46,13 +46,13 @@
 #endif
 
 /// \brief Private implementation
-class ignition::rendering::Ogre2DynamicRenderablePrivate
+class gz::rendering::Ogre2DynamicRenderablePrivate
 {
   /// \brief list of colors at each point
-  public: std::vector<ignition::math::Color> colors;
+  public: std::vector<gz::math::Color> colors;
 
   /// \brief List of vertices for the mesh
-  public: std::vector<ignition::math::Vector3d> vertices;
+  public: std::vector<gz::math::Vector3d> vertices;
 
   /// \brief Used to indicate if the lines require an update
   public: bool dirty = false;
@@ -93,7 +93,7 @@ class ignition::rendering::Ogre2DynamicRenderablePrivate
 };
 
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -405,7 +405,7 @@ void Ogre2DynamicRenderable::SetOperationType(MarkerType _opType)
       break;
 
     default:
-      ignerr << "Unknown render operation type[" << _opType << "]\n";
+      gzerr << "Unknown render operation type[" << _opType << "]\n";
       return;
   }
 }
@@ -446,8 +446,8 @@ MarkerType Ogre2DynamicRenderable::OperationType() const
 }
 
 /////////////////////////////////////////////////
-void Ogre2DynamicRenderable::AddPoint(const ignition::math::Vector3d &_pt,
-                                      const ignition::math::Color &_color)
+void Ogre2DynamicRenderable::AddPoint(const gz::math::Vector3d &_pt,
+                                      const gz::math::Color &_color)
 {
   this->dataPtr->vertices.push_back(_pt);
 
@@ -462,18 +462,18 @@ void Ogre2DynamicRenderable::AddPoint(const ignition::math::Vector3d &_pt,
 
 /////////////////////////////////////////////////
 void Ogre2DynamicRenderable::AddPoint(double _x, double _y, double _z,
-                                      const ignition::math::Color &_color)
+                                      const gz::math::Color &_color)
 {
-  this->AddPoint(ignition::math::Vector3d(_x, _y, _z), _color);
+  this->AddPoint(gz::math::Vector3d(_x, _y, _z), _color);
 }
 
 /////////////////////////////////////////////////
 void Ogre2DynamicRenderable::SetPoint(unsigned int _index,
-                                      const ignition::math::Vector3d &_value)
+                                      const gz::math::Vector3d &_value)
 {
   if (_index >= this->dataPtr->vertices.size())
   {
-    ignerr << "Point index[" << _index << "] is out of bounds[0-"
+    gzerr << "Point index[" << _index << "] is out of bounds[0-"
            << this->dataPtr->vertices.size()-1 << "]\n";
     return;
   }
@@ -485,11 +485,11 @@ void Ogre2DynamicRenderable::SetPoint(unsigned int _index,
 
 /////////////////////////////////////////////////
 void Ogre2DynamicRenderable::SetColor(unsigned int _index,
-                                      const ignition::math::Color &_color)
+                                      const gz::math::Color &_color)
 {
   if (_index >= this->dataPtr->colors.size())
   {
-    ignerr << "Point color index[" << _index << "] is out of bounds[0-"
+    gzerr << "Point color index[" << _index << "] is out of bounds[0-"
            << this->dataPtr->colors.size()-1 << "]\n";
     return;
   }
@@ -505,17 +505,17 @@ void Ogre2DynamicRenderable::SetColor(unsigned int _index,
 }
 
 /////////////////////////////////////////////////
-ignition::math::Vector3d Ogre2DynamicRenderable::Point(
+gz::math::Vector3d Ogre2DynamicRenderable::Point(
     const unsigned int _index) const
 {
   if (_index >= this->dataPtr->vertices.size())
   {
-    ignerr << "Point index[" << _index << "] is out of bounds[0-"
+    gzerr << "Point index[" << _index << "] is out of bounds[0-"
            << this->dataPtr->vertices.size()-1 << "]\n";
 
-    return ignition::math::Vector3d(ignition::math::INF_D,
-                                    ignition::math::INF_D,
-                                    ignition::math::INF_D);
+    return gz::math::Vector3d(gz::math::INF_D,
+                                    gz::math::INF_D,
+                                    gz::math::INF_D);
   }
 
   return this->dataPtr->vertices[_index];
@@ -548,7 +548,7 @@ void Ogre2DynamicRenderable::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2GaussianNoisePass.cc b/ogre2/src/Ogre2GaussianNoisePass.cc
index 905ae42c1..3e589aad7 100644
--- a/ogre2/src/Ogre2GaussianNoisePass.cc
+++ b/ogre2/src/Ogre2GaussianNoisePass.cc
@@ -16,11 +16,11 @@
  */
 
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/ogre2/Ogre2GaussianNoisePass.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/ogre2/Ogre2GaussianNoisePass.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -39,13 +39,13 @@
 #endif
 
 /// \brief Private data for the Ogre2GaussianNoisePass class
-class ignition::rendering::Ogre2GaussianNoisePassPrivate
+class gz::rendering::Ogre2GaussianNoisePassPrivate
 {
   /// brief Pointer to the Gaussian noise ogre material
   public: Ogre::Material *gaussianNoiseMat = nullptr;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -74,9 +74,9 @@ void Ogre2GaussianNoisePass::PreRender()
   // Sample three values within the range [0,1.0] and set them for use in
   // the fragment shader, which will interpret them as offsets from (0,0)
   // to use when computing pseudo-random values.
-  Ogre::Vector3 offsets(ignition::math::Rand::DblUniform(0.0, 1.0),
-                        ignition::math::Rand::DblUniform(0.0, 1.0),
-                        ignition::math::Rand::DblUniform(0.0, 1.0));
+  Ogre::Vector3 offsets(gz::math::Rand::DblUniform(0.0, 1.0),
+                        gz::math::Rand::DblUniform(0.0, 1.0),
+                        gz::math::Rand::DblUniform(0.0, 1.0));
   // These calls are setting parameters that are declared in two places:
   // 1. media/materials/scripts/gaussian_noise.material, in
   //    fragment_program GaussianNoiseFS
@@ -113,7 +113,7 @@ void Ogre2GaussianNoisePass::CreateRenderPass()
       Ogre::MaterialManager::getSingleton().getByName(matName);
   if (!ogreMat)
   {
-    ignerr << "Gaussian noise material not found: '" << matName << "'"
+    gzerr << "Gaussian noise material not found: '" << matName << "'"
            << std::endl;
     return;
   }
diff --git a/ogre2/src/Ogre2Geometry.cc b/ogre2/src/Ogre2Geometry.cc
index 759fe3b97..a19814a44 100644
--- a/ogre2/src/Ogre2Geometry.cc
+++ b/ogre2/src/Ogre2Geometry.cc
@@ -14,11 +14,11 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2Geometry.hh"
+#include "gz/rendering/ogre2/Ogre2Geometry.hh"
 
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2GizmoVisual.cc b/ogre2/src/Ogre2GizmoVisual.cc
index 5c7b2eba7..f5d3be24a 100644
--- a/ogre2/src/Ogre2GizmoVisual.cc
+++ b/ogre2/src/Ogre2GizmoVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2GizmoVisual.hh"
+#include "gz/rendering/ogre2/Ogre2GizmoVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2GpuRays.cc b/ogre2/src/Ogre2GpuRays.cc
index 978c596da..8bd4f2229 100644
--- a/ogre2/src/Ogre2GpuRays.cc
+++ b/ogre2/src/Ogre2GpuRays.cc
@@ -15,24 +15,24 @@
  *
 */
 
-#include <ignition/math/Vector2.hh>
-#include <ignition/math/Vector3.hh>
-
-#include <ignition/common/Console.hh>
-#include <ignition/math/Helpers.hh>
-
-#include "ignition/rendering/ogre2/Ogre2Camera.hh"
-#include "ignition/rendering/ogre2/Ogre2GpuRays.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Heightmap.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Sensor.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
+#include <gz/math/Vector2.hh>
+#include <gz/math/Vector3.hh>
+
+#include <gz/common/Console.hh>
+#include <gz/math/Helpers.hh>
+
+#include "gz/rendering/ogre2/Ogre2Camera.hh"
+#include "gz/rendering/ogre2/Ogre2GpuRays.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Heightmap.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Sensor.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
 
 #include "Ogre2GzHlmsSphericalClipMinDistance.hh"
 #include "Ogre2ParticleNoiseListener.hh"
@@ -56,15 +56,15 @@
   #pragma warning(pop)
 #endif
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /// \brief Helper class for switching the ogre item's material to laser retro
 /// source material when a thermal camera is being rendered.
-class IGNITION_RENDERING_OGRE2_HIDDEN
+class GZ_RENDERING_OGRE2_HIDDEN
     Ogre2LaserRetroMaterialSwitcher : public Ogre::CompositorWorkspaceListener
 {
   /// \brief constructor
@@ -104,7 +104,7 @@ class IGNITION_RENDERING_OGRE2_HIDDEN
 
 /// \internal
 /// \brief Private data for the Ogre2GpuRays class
-class IGNITION_RENDERING_OGRE2_HIDDEN ignition::rendering::Ogre2GpuRaysPrivate
+class GZ_RENDERING_OGRE2_HIDDEN gz::rendering::Ogre2GpuRaysPrivate
 {
   /// \brief Event triggered when new gpu rays range data are available.
   /// \param[in] _frame New frame containing raw gpu rays data.
@@ -112,7 +112,7 @@ class IGNITION_RENDERING_OGRE2_HIDDEN ignition::rendering::Ogre2GpuRaysPrivate
   /// \param[in] _height Height of frame.
   /// \param[in] _channel Number of channels
   /// \param[in] _format Format of frame.
-  public: ignition::common::EventT<void(const float *,
+  public: gz::common::EventT<void(const float *,
                unsigned int, unsigned int, unsigned int,
                const std::string &)> newGpuRaysFrame;
 
@@ -198,7 +198,7 @@ class IGNITION_RENDERING_OGRE2_HIDDEN ignition::rendering::Ogre2GpuRaysPrivate
   public: const math::Angle kMinAllowedAngle = 1e-4;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 // Arbitrary value
@@ -255,7 +255,7 @@ void Ogre2LaserRetroMaterialSwitcher::passPreExecute(
       }
       catch(Ogre::Exception &e)
       {
-        ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+        gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
       }
       Ogre2VisualPtr ogreVisual =
           std::dynamic_pointer_cast<Ogre2Visual>(result);
@@ -283,7 +283,7 @@ void Ogre2LaserRetroMaterialSwitcher::passPreExecute(
             }
             catch(std::bad_variant_access &e)
             {
-              ignerr << "Error casting user data: " << e.what() << "\n";
+              gzerr << "Error casting user data: " << e.what() << "\n";
             }
           }
         }
@@ -314,7 +314,7 @@ void Ogre2LaserRetroMaterialSwitcher::passPreExecute(
         // We need to keep the material's vertex shader
         // to keep vertex deformation consistent; so we use
         // a cloned material with a different pixel shader
-        // https://github.com/ignitionrobotics/ign-rendering/issues/544
+        // https://github.com/gazebosim/gz-rendering/issues/544
         //
         // material may be a nullptr if we called setMaterial directly
         // (i.e. it's not using Ogre2Material interface).
@@ -404,7 +404,7 @@ void Ogre2LaserRetroMaterialSwitcher::passPreExecute(
             }
             catch (std::bad_variant_access &e)
             {
-              ignerr << "Error casting user data: " << e.what() << "\n";
+              gzerr << "Error casting user data: " << e.what() << "\n";
             }
           }
         }
@@ -627,7 +627,7 @@ void Ogre2GpuRays::CreateCamera()
   Ogre::SceneManager *ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
@@ -635,7 +635,7 @@ void Ogre2GpuRays::CreateCamera()
       this->Name() + "_Camera");
   if (this->dataPtr->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -670,7 +670,7 @@ void Ogre2GpuRays::ConfigureCamera()
 
     if (this->VerticalAngleMax() != this->VerticalAngleMin())
     {
-      ignwarn << "Only one vertical ray but vertical min. and max. angle "
+      gzwarn << "Only one vertical ray but vertical min. and max. angle "
           "are not equal. Min. angle is used.\n";
       this->SetVerticalAngleMax(this->VerticalAngleMin().Radian());
     }
@@ -825,7 +825,7 @@ void Ogre2GpuRays::CreateSampleTexture()
       unsigned int faceIdx;
       math::Vector2d uv = this->SampleCubemap(dir, faceIdx);
       this->dataPtr->cubeFaceIdx.insert(faceIdx);
-      // igndbg << "p(" << pitch << ") y(" << yaw << "): " << dir << " | "
+      // gzdbg << "p(" << pitch << ") y(" << yaw << "): " << dir << " | "
       //       << uv << " | " << faceIdx << std::endl;
       // u
       pDest[index++] = uv.X();
@@ -1122,7 +1122,7 @@ void Ogre2GpuRays::Setup1stPass()
 
   if (!wsDef)
   {
-    ignerr << "Unable to add workspace definition [" << wsDefName << "] "
+    gzerr << "Unable to add workspace definition [" << wsDefName << "] "
            << " for " << this->Name();
   }
 
@@ -1327,7 +1327,7 @@ void Ogre2GpuRays::Setup2ndPass()
       ogreCompMgr->getWorkspaceDefinition(wsDefName);
   if (!wsDef)
   {
-    ignerr << "Unable to add workspace definition [" << wsDefName << "] "
+    gzerr << "Unable to add workspace definition [" << wsDefName << "] "
            << " for " << this->Name();
   }
 
@@ -1408,7 +1408,7 @@ void Ogre2GpuRays::Render()
   // clamping as it clips before sending vertices to the pixel shader.
   // These customization can be used to implement multi-tiered
   // "near plane distances" as proposed in:
-  // https://github.com/ignitionrobotics/ign-rendering/issues/395
+  // https://github.com/gazebosim/gz-rendering/issues/395
   Ogre2GzHlmsSphericalClipMinDistance &hlmsCustomizations =
       engine->SphericalClipMinDistance();
 
@@ -1548,7 +1548,7 @@ void Ogre2GpuRays::SetRangeCount(
 }
 
 //////////////////////////////////////////////////
-ignition::common::ConnectionPtr Ogre2GpuRays::ConnectNewGpuRaysFrame(
+gz::common::ConnectionPtr Ogre2GpuRays::ConnectNewGpuRaysFrame(
     std::function<void(const float *_frame, unsigned int _width,
     unsigned int _height, unsigned int _channels,
     const std::string &/*_format*/)> _subscriber)
diff --git a/ogre2/src/Ogre2Grid.cc b/ogre2/src/Ogre2Grid.cc
index 08493253a..e752e6d0d 100644
--- a/ogre2/src/Ogre2Grid.cc
+++ b/ogre2/src/Ogre2Grid.cc
@@ -15,17 +15,17 @@
  *
 */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Grid.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2Grid.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
-class ignition::rendering::Ogre2GridPrivate
+class gz::rendering::Ogre2GridPrivate
 {
   /// \brief Grid materal
   public: Ogre2MaterialPtr material;
@@ -159,7 +159,7 @@ void Ogre2Grid::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2GzHlmsPbsPrivate.cc b/ogre2/src/Ogre2GzHlmsPbsPrivate.cc
index 7bf64e67f..988c75f17 100644
--- a/ogre2/src/Ogre2GzHlmsPbsPrivate.cc
+++ b/ogre2/src/Ogre2GzHlmsPbsPrivate.cc
@@ -19,9 +19,9 @@
 
 #include "Terra/Hlms/PbsListener/OgreHlmsPbsTerraShadows.h"
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Util.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Util.hh>
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -35,7 +35,7 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 namespace Ogre
@@ -222,9 +222,9 @@ namespace Ogre
         //  2. This object should not be rendered and we should've called
         //     movableObject->setVisible(false) or use RenderQueue IDs
         //     or visibility flags to prevent rendering it
-        ignerr << "A module is trying to render an object without "
+        gzerr << "A module is trying to render an object without "
                   "specifying a parameter. Please report this bug at "
-                  "https://github.com/ignitionrobotics/ign-rendering/issues\n";
+                  "https://github.com/gazebosim/gz-rendering/issues\n";
         throw;
       }
       float *dataPtr = this->MapObjectDataBufferFor(
diff --git a/ogre2/src/Ogre2GzHlmsPbsPrivate.hh b/ogre2/src/Ogre2GzHlmsPbsPrivate.hh
index f3bdf458c..80e24ba4c 100644
--- a/ogre2/src/Ogre2GzHlmsPbsPrivate.hh
+++ b/ogre2/src/Ogre2GzHlmsPbsPrivate.hh
@@ -14,11 +14,11 @@
  * limitations under the License.
  *
  */
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2GZHLMSPBSPRIVATE_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2GZHLMSPBSPRIVATE_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2GZHLMSPBSPRIVATE_HH_
+#define GZ_RENDERING_OGRE2_OGRE2GZHLMSPBSPRIVATE_HH_
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre2/Export.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre2/Export.hh"
 
 #include "Ogre2GzHlmsSphericalClipMinDistance.hh"
 #include "Ogre2GzHlmsSharedPrivate.hh"
@@ -58,15 +58,15 @@ namespace Ogre
   /// \internal
   /// \remark Public variables take effect immediately (i.e. for the
   /// next render)
-  class IGNITION_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsPbs final
+  class GZ_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsPbs final
     : public HlmsPbs,
       public HlmsListener,
-      public ignition::rendering::Ogre2GzHlmsShared
+      public gz::rendering::Ogre2GzHlmsShared
   {
     /// \brief Constructor. Asks for modular listeners so we can add
     /// them in the proper order
     public: Ogre2GzHlmsPbs(Archive *dataFolder, ArchiveVec *libraryFolders,
-                            ignition::rendering::
+                            gz::rendering::
                             Ogre2GzHlmsSphericalClipMinDistance
                             *_sphericalClipMinDistance,
                             Ogre::HlmsPbsTerraShadows *terraShadows);
diff --git a/ogre2/src/Ogre2GzHlmsSharedPrivate.cc b/ogre2/src/Ogre2GzHlmsSharedPrivate.cc
index 70ee00a76..e2107216d 100644
--- a/ogre2/src/Ogre2GzHlmsSharedPrivate.cc
+++ b/ogre2/src/Ogre2GzHlmsSharedPrivate.cc
@@ -17,7 +17,7 @@
 
 #include "Ogre2GzHlmsSharedPrivate.hh"
 
-#include <ignition/common/Util.hh>
+#include <gz/common/Util.hh>
 
 #ifdef _MSC_VER
 #  pragma warning(push, 0)
@@ -33,7 +33,7 @@
 
 #include <algorithm>
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
@@ -118,4 +118,4 @@ namespace ignition
       }
     }
   }  // namespace rendering
-}  // namespace ignition
+}  // namespace gz
diff --git a/ogre2/src/Ogre2GzHlmsSharedPrivate.hh b/ogre2/src/Ogre2GzHlmsSharedPrivate.hh
index 85934b65e..e965bbe83 100644
--- a/ogre2/src/Ogre2GzHlmsSharedPrivate.hh
+++ b/ogre2/src/Ogre2GzHlmsSharedPrivate.hh
@@ -14,12 +14,12 @@
  * limitations under the License.
  *
  */
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2GZHLMSSHAREDPRIVATE_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2GZHLMSSHAREDPRIVATE_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2GZHLMSSHAREDPRIVATE_HH_
+#define GZ_RENDERING_OGRE2_OGRE2GZHLMSSHAREDPRIVATE_HH_
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre2/Export.hh"
-#include "ignition/rendering/ogre2/Ogre2IgnOgreRenderingMode.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre2/Export.hh"
+#include "gz/rendering/ogre2/Ogre2GzOgreRenderingMode.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -32,19 +32,19 @@
 
 #include <vector>
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE
     {
-    typedef ignition::rendering::IgnOgreRenderingMode IgnOgreRenderingMode;
+    typedef gz::rendering::IgnOgreRenderingMode IgnOgreRenderingMode;
     typedef Ogre::vector<Ogre::ConstBufferPacked*>::type ConstBufferPackedVec;
 
     /// \brief Implements code shared across all or most of our Hlms
     /// customizations
     /// \internal
-    class IGNITION_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsShared
+    class GZ_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsShared
     {
       /// \brief Binds currPerObjectDataBuffer to the right slot.
       /// Does nothing if it's nullptr
diff --git a/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.cc b/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.cc
index b2a3d2a7c..3489b6b5a 100644
--- a/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.cc
+++ b/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.cc
@@ -17,7 +17,7 @@
 
 #include "Ogre2GzHlmsSphericalClipMinDistance.hh"
 
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
 
 #ifdef _MSC_VER
 #  pragma warning(push, 0)
@@ -31,7 +31,7 @@
 #  pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.hh b/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.hh
index 6612687fd..b32313691 100644
--- a/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.hh
+++ b/ogre2/src/Ogre2GzHlmsSphericalClipMinDistance.hh
@@ -15,11 +15,11 @@
  *
 */
 
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2GZHLMSCUSTOMIZATIONS_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2GZHLMSCUSTOMIZATIONS_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2GZHLMSCUSTOMIZATIONS_HH_
+#define GZ_RENDERING_OGRE2_OGRE2GZHLMSCUSTOMIZATIONS_HH_
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre2/Export.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre2/Export.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -29,11 +29,11 @@
   #pragma warning(pop)
 #endif
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Controls custom shader snippets of Hlms (both Pbs and Unlit):
     ///
@@ -46,7 +46,7 @@ namespace ignition
     /// \internal
     /// \remark Public variables take effect immediately (i.e. for the
     /// next render)
-    class IGNITION_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsSphericalClipMinDistance
+    class GZ_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsSphericalClipMinDistance
       final : public Ogre::HlmsListener
     {
       public: virtual ~Ogre2GzHlmsSphericalClipMinDistance() = default;
@@ -104,7 +104,7 @@ namespace ignition
       ///
       /// Set to a negative value to disable (0 does NOT disable it!)
       ///
-      /// See https://github.com/ignitionrobotics/ign-rendering/pull/356
+      /// See https://github.com/gazebosim/gz-rendering/pull/356
       public: float minDistanceClip = -1.0f;
 
       /// \brief When true, we're currently dealing with HlmsUnlit
diff --git a/ogre2/src/Ogre2GzHlmsTerraPrivate.cc b/ogre2/src/Ogre2GzHlmsTerraPrivate.cc
index a6798b262..32984a1ba 100644
--- a/ogre2/src/Ogre2GzHlmsTerraPrivate.cc
+++ b/ogre2/src/Ogre2GzHlmsTerraPrivate.cc
@@ -17,9 +17,9 @@
 
 #include "Ogre2GzHlmsTerraPrivate.hh"
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Util.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Util.hh>
 
 #include "Terra/Terra.h"
 
@@ -35,7 +35,7 @@
 #  pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 namespace Ogre
@@ -180,9 +180,9 @@ namespace Ogre
         //  2. This object should not be rendered and we should've called
         //     movableObject->setVisible(false) or use RenderQueue IDs
         //     or visibility flags to prevent rendering it
-        ignerr << "A module is trying to render an object without "
+        gzerr << "A module is trying to render an object without "
                   "specifying a parameter. Please report this bug at "
-                  "https://github.com/ignitionrobotics/ign-rendering/issues\n";
+                  "https://github.com/gazebosim/gz-rendering/issues\n";
         throw;
       }
       float *dataPtr = this->MapObjectDataBufferFor(
@@ -241,9 +241,9 @@ namespace Ogre
         //  2. This object should not be rendered and we should've called
         //     movableObject->setVisible(false) or use RenderQueue IDs
         //     or visibility flags to prevent rendering it
-        ignerr << "A module is trying to render an object without "
+        gzerr << "A module is trying to render an object without "
                   "specifying a parameter. Please report this bug at "
-                  "https://github.com/ignitionrobotics/ign-rendering/issues\n";
+                  "https://github.com/gazebosim/gz-rendering/issues\n";
         throw;
       }
       float *dataPtr = this->MapObjectDataBufferFor(
diff --git a/ogre2/src/Ogre2GzHlmsTerraPrivate.hh b/ogre2/src/Ogre2GzHlmsTerraPrivate.hh
index cb9d230f1..8f1ec65ee 100644
--- a/ogre2/src/Ogre2GzHlmsTerraPrivate.hh
+++ b/ogre2/src/Ogre2GzHlmsTerraPrivate.hh
@@ -14,11 +14,11 @@
  * limitations under the License.
  *
  */
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2GZHLMSTERRAPRIVATE_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2GZHLMSTERRAPRIVATE_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2GZHLMSTERRAPRIVATE_HH_
+#define GZ_RENDERING_OGRE2_OGRE2GZHLMSTERRAPRIVATE_HH_
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre2/Export.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre2/Export.hh"
 
 #include "Ogre2GzHlmsSharedPrivate.hh"
 #include "Ogre2GzHlmsSphericalClipMinDistance.hh"
@@ -56,15 +56,15 @@ namespace Ogre
   /// \internal
   /// \remark Public variables take effect immediately (i.e. for the
   /// next render)
-  class IGNITION_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsTerra final
+  class GZ_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsTerra final
     : public HlmsTerra,
       public HlmsListener,
-      public ignition::rendering::Ogre2GzHlmsShared
+      public gz::rendering::Ogre2GzHlmsShared
   {
     /// \brief Constructor. Asks for modular listeners so we can add
     /// them in the proper order
     public: Ogre2GzHlmsTerra(Archive *dataFolder, ArchiveVec *libraryFolders,
-                              ignition::rendering::
+                              gz::rendering::
                               Ogre2GzHlmsSphericalClipMinDistance
                               *_sphericalClipMinDistance);
 
diff --git a/ogre2/src/Ogre2GzHlmsUnlitPrivate.cc b/ogre2/src/Ogre2GzHlmsUnlitPrivate.cc
index 8d99606c9..21057b145 100644
--- a/ogre2/src/Ogre2GzHlmsUnlitPrivate.cc
+++ b/ogre2/src/Ogre2GzHlmsUnlitPrivate.cc
@@ -17,9 +17,9 @@
 
 #include "Ogre2GzHlmsUnlitPrivate.hh"
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Util.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Util.hh>
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -33,7 +33,7 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 namespace Ogre
@@ -166,9 +166,9 @@ namespace Ogre
         //  2. This object should not be rendered and we should've called
         //     movableObject->setVisible(false) or use RenderQueue IDs
         //     or visibility flags to prevent rendering it
-        ignerr << "A module is trying to render an object without "
+        gzerr << "A module is trying to render an object without "
                   "specifying a parameter. Please report this bug at "
-                  "https://github.com/ignitionrobotics/ign-rendering/issues\n";
+                  "https://github.com/gazebosim/gz-rendering/issues\n";
         throw;
       }
       float *dataPtr = this->MapObjectDataBufferFor(
diff --git a/ogre2/src/Ogre2GzHlmsUnlitPrivate.hh b/ogre2/src/Ogre2GzHlmsUnlitPrivate.hh
index 7d92becb0..967a90aad 100644
--- a/ogre2/src/Ogre2GzHlmsUnlitPrivate.hh
+++ b/ogre2/src/Ogre2GzHlmsUnlitPrivate.hh
@@ -14,11 +14,11 @@
  * limitations under the License.
  *
  */
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2GZHLMSUNLITPRIVATE_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2GZHLMSUNLITPRIVATE_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2GZHLMSUNLITPRIVATE_HH_
+#define GZ_RENDERING_OGRE2_OGRE2GZHLMSUNLITPRIVATE_HH_
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre2/Export.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre2/Export.hh"
 
 #include "Ogre2GzHlmsSphericalClipMinDistance.hh"
 #include "Ogre2GzHlmsSharedPrivate.hh"
@@ -56,15 +56,15 @@ namespace Ogre
   /// \internal
   /// \remark Public variables take effect immediately (i.e. for the
   /// next render)
-  class IGNITION_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsUnlit final
+  class GZ_RENDERING_OGRE2_HIDDEN Ogre2GzHlmsUnlit final
     : public HlmsUnlit,
       public HlmsListener,
-      public ignition::rendering::Ogre2GzHlmsShared
+      public gz::rendering::Ogre2GzHlmsShared
   {
     /// \brief Constructor. Asks for modular listeners so we can add
     /// them in the proper order
     public: Ogre2GzHlmsUnlit(Archive *dataFolder, ArchiveVec *libraryFolders,
-                              ignition::rendering::
+                              gz::rendering::
                               Ogre2GzHlmsSphericalClipMinDistance
                               *_sphericalClipMinDistance);
 
diff --git a/ogre2/src/Ogre2Heightmap.cc b/ogre2/src/Ogre2Heightmap.cc
index b16b1ce02..45dfa773c 100644
--- a/ogre2/src/Ogre2Heightmap.cc
+++ b/ogre2/src/Ogre2Heightmap.cc
@@ -17,14 +17,14 @@
 
 #include <chrono>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Util.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Util.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Heightmap.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Light.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Heightmap.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Light.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
 
 #include "Terra/Terra.h"
 
@@ -44,7 +44,7 @@
 #endif
 
 //////////////////////////////////////////////////
-class ignition::rendering::Ogre2HeightmapPrivate
+class gz::rendering::Ogre2HeightmapPrivate
 {
   /// \brief Skirt min height. Leave it at -1 for automatic.
   /// Leave it at 0 for maximum skirt size (high performance hit)
@@ -64,7 +64,7 @@ class ignition::rendering::Ogre2HeightmapPrivate
   public: std::unique_ptr<Ogre::Terra> terra{nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -85,7 +85,7 @@ void Ogre2Heightmap::Init()
 
   if (this->descriptor.Data() == nullptr)
   {
-    ignerr << "Failed to initialize: null heightmap data." << std::endl;
+    gzerr << "Failed to initialize: null heightmap data." << std::endl;
     return;
   }
 
@@ -115,7 +115,7 @@ void Ogre2Heightmap::Init()
 
   if (needsOgre1Compat)
   {
-    ignwarn << "Heightmap final sampling should be 2^n"
+    gzwarn << "Heightmap final sampling should be 2^n"
            << std::endl << " which differs from ogre1's 2^n+1"
            << std::endl << "The last row and column will be cropped"
            << std::endl << "size = (width * sampling) - sampling + 1"
@@ -127,7 +127,7 @@ void Ogre2Heightmap::Init()
   }
   else if (!math::isPowerOfTwo(srcWidth))
   {
-    ignerr << "Heightmap final sampling must satisfy 2^n."
+    gzerr << "Heightmap final sampling must satisfy 2^n."
            << std::endl << "size = width * sampling"
            << std::endl << "[" << srcWidth << "] = ["
            << this->descriptor.Data()->Width() << "] * ["
@@ -175,7 +175,7 @@ void Ogre2Heightmap::Init()
 
       if (heightVal < minElevation || heightVal > maxElevation)
       {
-        ignerr << "Internal error: height [" << heightVal
+        gzerr << "Internal error: height [" << heightVal
                << "] is out of bounds [" << minElevation << " / "
                << maxElevation << "]" << std::endl;
       }
@@ -197,7 +197,7 @@ void Ogre2Heightmap::Init()
 
   if (this->dataPtr->heights.empty())
   {
-    ignerr << "Failed to load terrain. Heightmap data is empty" << std::endl;
+    gzerr << "Failed to load terrain. Heightmap data is empty" << std::endl;
     return;
   }
 
@@ -290,7 +290,7 @@ void Ogre2Heightmap::Init()
     if ((numTextures > 4u && !bCanUseFirstAsBase) ||
         (numTextures > 5u && bCanUseFirstAsBase))
     {
-      ignwarn << "Ogre2Heightmap currently supports up to 4 textures, "
+      gzwarn << "Ogre2Heightmap currently supports up to 4 textures, "
                  "5 textures if the first one is diffuse-only & "
                  "texture size = terrain size. "
                  "The rest are ignored. Supplied: "
@@ -349,7 +349,7 @@ void Ogre2Heightmap::Init()
     if ((numBlends > 3u && !bCanUseFirstAsBase) ||
         (numBlends > 4u && bCanUseFirstAsBase))
     {
-      ignwarn << "Ogre2Heightmap currently supports up to 3 blends, "
+      gzwarn << "Ogre2Heightmap currently supports up to 3 blends, "
                  "4 blends if the first one is diffuse-only & "
                  "texture size = terrain size. "
                  "The rest are ignored. Supplied: "
@@ -374,10 +374,10 @@ void Ogre2Heightmap::Init()
 
   this->dataPtr->terra->setDatablock(datablock);
 
-  ignmsg << "Loading heightmap: " << this->descriptor.Name() << std::endl;
+  gzmsg << "Loading heightmap: " << this->descriptor.Name() << std::endl;
   auto time = std::chrono::steady_clock::now();
 
-  ignmsg << "Heightmap loaded. Process took "
+  gzmsg << "Heightmap loaded. Process took "
         <<  std::chrono::duration_cast<std::chrono::milliseconds>(
             std::chrono::steady_clock::now() - time).count()
         << " ms." << std::endl;
diff --git a/ogre2/src/Ogre2InertiaVisual.cc b/ogre2/src/Ogre2InertiaVisual.cc
index 3a623a279..e829997e8 100644
--- a/ogre2/src/Ogre2InertiaVisual.cc
+++ b/ogre2/src/Ogre2InertiaVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2InertiaVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2InertiaVisual.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -26,10 +26,10 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
-class ignition::rendering::Ogre2InertiaVisualPrivate
+class gz::rendering::Ogre2InertiaVisualPrivate
 {
   /// \brief inertia visual materal
   public: Ogre2MaterialPtr material = nullptr;
@@ -86,8 +86,8 @@ void Ogre2InertiaVisual::Destroy()
 }
 
 //////////////////////////////////////////////////
-void Ogre2InertiaVisual::Load(const ignition::math::Pose3d &_pose,
-                              const ignition::math::Vector3d &_scale)
+void Ogre2InertiaVisual::Load(const gz::math::Pose3d &_pose,
+                              const gz::math::Vector3d &_scale)
 {
   if (!this->dataPtr->crossLines)
   {
@@ -117,12 +117,12 @@ void Ogre2InertiaVisual::Load(const ignition::math::Pose3d &_pose,
   }
 
   // Inertia position indicator
-  ignition::math::Vector3d p1(0, 0, -2*_scale.Z());
-  ignition::math::Vector3d p2(0, 0, 2*_scale.Z());
-  ignition::math::Vector3d p3(0, -2*_scale.Y(), 0);
-  ignition::math::Vector3d p4(0, 2*_scale.Y(), 0);
-  ignition::math::Vector3d p5(-2*_scale.X(), 0, 0);
-  ignition::math::Vector3d p6(2*_scale.X(), 0, 0);
+  gz::math::Vector3d p1(0, 0, -2*_scale.Z());
+  gz::math::Vector3d p2(0, 0, 2*_scale.Z());
+  gz::math::Vector3d p3(0, -2*_scale.Y(), 0);
+  gz::math::Vector3d p4(0, 2*_scale.Y(), 0);
+  gz::math::Vector3d p5(-2*_scale.X(), 0, 0);
+  gz::math::Vector3d p6(2*_scale.X(), 0, 0);
   p1 = _pose.Rot().RotateVector(p1);
   p2 = _pose.Rot().RotateVector(p2);
   p3 = _pose.Rot().RotateVector(p3);
@@ -166,7 +166,7 @@ void Ogre2InertiaVisual::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2JointVisual.cc b/ogre2/src/Ogre2JointVisual.cc
index a47c8fed7..d734fc25b 100644
--- a/ogre2/src/Ogre2JointVisual.cc
+++ b/ogre2/src/Ogre2JointVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2JointVisual.hh"
+#include "gz/rendering/ogre2/Ogre2JointVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2LidarVisual.cc b/ogre2/src/Ogre2LidarVisual.cc
index 53d66520c..348ce020b 100644
--- a/ogre2/src/Ogre2LidarVisual.cc
+++ b/ogre2/src/Ogre2LidarVisual.cc
@@ -25,15 +25,15 @@
 #endif
 #endif
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
-#include "ignition/rendering/ogre2/Ogre2LidarVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Marker.hh"
-#include "ignition/rendering/ogre2/Ogre2Geometry.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2LidarVisual.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Marker.hh"
+#include "gz/rendering/ogre2/Ogre2Geometry.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -47,7 +47,7 @@
   #pragma warning(pop)
 #endif
 
-class ignition::rendering::Ogre2LidarVisualPrivate
+class gz::rendering::Ogre2LidarVisualPrivate
 {
   /// \brief Non Hitting DynamicLines Object to display
   public: std::vector<std::shared_ptr<Ogre2DynamicRenderable>> noHitRayStrips;
@@ -85,7 +85,7 @@ class ignition::rendering::Ogre2LidarVisualPrivate
   public: Ogre::MaterialPtr pointsMat;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -212,7 +212,7 @@ void Ogre2LidarVisual::Update()
 
   if (!this->dataPtr->receivedData || this->dataPtr->lidarPoints.size() == 0)
   {
-    ignwarn << "New lidar data not received. Exiting update function"
+    gzwarn << "New lidar data not received. Exiting update function"
             << std::endl;
     return;
   }
@@ -259,7 +259,7 @@ void Ogre2LidarVisual::Update()
   if (this->dataPtr->lidarPoints.size() !=
                   this->verticalCount * this->horizontalCount)
   {
-    ignwarn << "Size of lidar data inconsistent with rays."
+    gzwarn << "Size of lidar data inconsistent with rays."
             << " Exiting update function."
             << std::endl;
     return;
@@ -313,7 +313,7 @@ void Ogre2LidarVisual::Update()
           this->ogreNode->attachObject(renderable->OgreObject());
           this->dataPtr->deadZoneRayFans.push_back(renderable);
           this->dataPtr->deadZoneRayFans[j]->AddPoint(
-                      ignition::math::Vector3d::Zero);
+                      gz::math::Vector3d::Zero);
 
           renderable = std::shared_ptr<Ogre2DynamicRenderable>(
                                   new Ogre2DynamicRenderable(this->Scene()));
@@ -365,28 +365,28 @@ void Ogre2LidarVisual::Update()
       double r = this->dataPtr->lidarPoints[ j * this->horizontalCount + i];
 
       bool inf = (std::isinf(r) || r >= this->maxRange);
-      ignition::math::Quaterniond ray(
-        ignition::math::Vector3d(0.0, -verticalAngle, horizontalAngle));
+      gz::math::Quaterniond ray(
+        gz::math::Vector3d(0.0, -verticalAngle, horizontalAngle));
 
-      ignition::math::Vector3d axis = this->offset.Rot() * ray *
-        ignition::math::Vector3d(1.0, 0.0, 0.0);
+      gz::math::Vector3d axis = this->offset.Rot() * ray *
+        gz::math::Vector3d(1.0, 0.0, 0.0);
 
       // Check for infinite range, which indicates the ray did not
       // intersect an object.
       double hitRange = inf ? 0 : r;
 
       // Compute the start point of the ray
-      ignition::math::Vector3d startPt =
+      gz::math::Vector3d startPt =
                   (axis * this->minRange) + this->offset.Pos();
 
       // Compute the end point of the ray
-      ignition::math::Vector3d pt =
+      gz::math::Vector3d pt =
                   (axis * hitRange) + this->offset.Pos();
 
       double noHitRange = inf ? this->maxRange : hitRange;
 
       // Compute the end point of the no-hit ray
-      ignition::math::Vector3d noHitPt =
+      gz::math::Vector3d noHitPt =
                   (axis * noHitRange) + this->offset.Pos();
 
       // Update the lines and strips that represent each simulated ray.
diff --git a/ogre2/src/Ogre2Light.cc b/ogre2/src/Ogre2Light.cc
index e5c048315..9b26de661 100644
--- a/ogre2/src/Ogre2Light.cc
+++ b/ogre2/src/Ogre2Light.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Light.hh"
+#include "gz/rendering/ogre2/Ogre2Light.hh"
 
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -31,11 +31,11 @@
 #endif
 
 /// \brief Private data for the Ogre2Light class
-class ignition::rendering::Ogre2LightPrivate
+class gz::rendering::Ogre2LightPrivate
 {
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2LightVisual.cc b/ogre2/src/Ogre2LightVisual.cc
index 8a3a85a48..7db9698c3 100644
--- a/ogre2/src/Ogre2LightVisual.cc
+++ b/ogre2/src/Ogre2LightVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2LightVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2LightVisual.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -26,10 +26,10 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
-class ignition::rendering::Ogre2LightVisualPrivate
+class gz::rendering::Ogre2LightVisualPrivate
 {
   /// \brief light visual materal
   public: Ogre2MaterialPtr material = nullptr;
@@ -93,7 +93,7 @@ void Ogre2LightVisual::CreateVisual()
     this->SetMaterial(defaultMat, false);
   }
 
-  std::vector<ignition::math::Vector3d> positions = this->CreateVisualLines();
+  std::vector<gz::math::Vector3d> positions = this->CreateVisualLines();
 
   for (const auto &p : positions)
   {
@@ -113,7 +113,7 @@ void Ogre2LightVisual::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2Marker.cc b/ogre2/src/Ogre2Marker.cc
index 8dc00c721..515ca973e 100644
--- a/ogre2/src/Ogre2Marker.cc
+++ b/ogre2/src/Ogre2Marker.cc
@@ -25,20 +25,20 @@
 #endif
 #endif
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Capsule.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
-#include "ignition/rendering/ogre2/Ogre2Marker.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2Mesh.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/ogre2/Ogre2Capsule.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2Marker.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2Mesh.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -51,7 +51,7 @@
   #pragma warning(pop)
 #endif
 
-class ignition::rendering::Ogre2MarkerPrivate
+class gz::rendering::Ogre2MarkerPrivate
 {
   /// \brief Marker material
   public: Ogre2MaterialPtr material = nullptr;
@@ -67,7 +67,7 @@ class ignition::rendering::Ogre2MarkerPrivate
   public: std::shared_ptr<Ogre2DynamicRenderable> dynamicRenderable;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -179,7 +179,7 @@ Ogre::MovableObject *Ogre2Marker::OgreObject() const
       return nullptr;
     }
     default:
-      ignerr << "Invalid Marker type " << this->markerType << "\n";
+      gzerr << "Invalid Marker type " << this->markerType << "\n";
       return nullptr;
   }
 }
@@ -208,7 +208,7 @@ void Ogre2Marker::SetMaterial(MaterialPtr _material, bool _unique)
 {
   if (nullptr == _material)
   {
-    ignerr << "Cannot assign null material" << std::endl;
+    gzerr << "Cannot assign null material" << std::endl;
     return;
   }
 
@@ -219,7 +219,7 @@ void Ogre2Marker::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
       << std::endl;
 
     return;
@@ -246,7 +246,7 @@ void Ogre2Marker::SetMaterial(MaterialPtr _material, bool _unique)
       }
       else
       {
-        ignerr << "Failed to set material, null geometry." << std::endl;
+        gzerr << "Failed to set material, null geometry." << std::endl;
       }
       break;
     }
@@ -263,12 +263,12 @@ void Ogre2Marker::SetMaterial(MaterialPtr _material, bool _unique)
       }
       else
       {
-        ignerr << "Failed to set material, null renderable." << std::endl;
+        gzerr << "Failed to set material, null renderable." << std::endl;
       }
       break;
     }
     default:
-      ignerr << "Invalid Marker type " << this->markerType << "\n";
+      gzerr << "Invalid Marker type " << this->markerType << "\n";
       break;
   }
 
@@ -287,14 +287,14 @@ MaterialPtr Ogre2Marker::Material() const
 
 //////////////////////////////////////////////////
 void Ogre2Marker::SetPoint(unsigned int _index,
-    const ignition::math::Vector3d &_value)
+    const gz::math::Vector3d &_value)
 {
   this->dataPtr->dynamicRenderable->SetPoint(_index, _value);
 }
 
 //////////////////////////////////////////////////
-void Ogre2Marker::AddPoint(const ignition::math::Vector3d &_pt,
-    const ignition::math::Color &_color)
+void Ogre2Marker::AddPoint(const gz::math::Vector3d &_pt,
+    const gz::math::Color &_color)
 {
   this->dataPtr->dynamicRenderable->AddPoint(_pt, _color);
 }
@@ -357,7 +357,7 @@ void Ogre2Marker::SetType(MarkerType _markerType)
       this->dataPtr->dynamicRenderable->SetOperationType(_markerType);
       break;
     default:
-      ignerr << "Invalid Marker type [" << _markerType << "]" << std::endl;
+      gzerr << "Invalid Marker type [" << _markerType << "]" << std::endl;
       break;
   }
 
@@ -366,7 +366,7 @@ void Ogre2Marker::SetType(MarkerType _markerType)
     this->dataPtr->geom = std::dynamic_pointer_cast<Ogre2Geometry>(newGeom);
     if (nullptr == this->dataPtr->geom)
     {
-      ignerr << "Failed to cast to [Ogre2Geom], type [" << _markerType << "]"
+      gzerr << "Failed to cast to [Ogre2Geom], type [" << _markerType << "]"
              << std::endl;
     }
     else if (visual)
@@ -377,7 +377,7 @@ void Ogre2Marker::SetType(MarkerType _markerType)
   }
   else if (isGeom)
   {
-    ignerr << "Failed to create geometry for marker type [" << _markerType
+    gzerr << "Failed to create geometry for marker type [" << _markerType
            << "]" << std::endl;
   }
 }
diff --git a/ogre2/src/Ogre2Material.cc b/ogre2/src/Ogre2Material.cc
index 8b4088073..318e00e2d 100644
--- a/ogre2/src/Ogre2Material.cc
+++ b/ogre2/src/Ogre2Material.cc
@@ -36,21 +36,21 @@
 #pragma warning(pop)
 #endif
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Image.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Image.hh>
 
-#include "ignition/rendering/GraphicsAPI.hh"
-#include "ignition/rendering/ShaderParams.hh"
-#include "ignition/rendering/ShaderType.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/GraphicsAPI.hh"
+#include "gz/rendering/ShaderParams.hh"
+#include "gz/rendering/ShaderType.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
 
 
 /// \brief Private data for the Ogre2Material class
-class ignition::rendering::Ogre2MaterialPrivate
+class gz::rendering::Ogre2MaterialPrivate
 {
   /// \brief Ogre stores the name using hashes. This variable will
   /// store the material hash name
@@ -103,7 +103,7 @@ class ignition::rendering::Ogre2MaterialPrivate
   }
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -345,7 +345,7 @@ void Ogre2Material::SetRenderOrder(const float _renderOrder)
   if (renderSystem->isReverseDepth())
   {
     // Reverse depth needs 100x scale AND ends up being superior
-    // See https://github.com/ignitionrobotics/ign-rendering/
+    // See https://github.com/gazebosim/gz-rendering/
     // issues/427#issuecomment-991800352
     // and see https://www.youtube.com/watch?v=s2XdH3fYUac
     macroblock.mDepthBiasConstant = _renderOrder * 100.0f;
@@ -698,7 +698,7 @@ void Ogre2Material::UpdateShaderParams(ConstShaderParamsPtr _params,
             (ShaderParam::PARAM_TEXTURE == name_param.second.Type() ||
              ShaderParam::PARAM_TEXTURE_CUBE == name_param.second.Type())))
     {
-      ignwarn << "Unable to find GPU program parameter: "
+      gzwarn << "Unable to find GPU program parameter: "
               << name_param.first << std::endl;
       continue;
     }
@@ -766,7 +766,7 @@ void Ogre2Material::UpdateShaderParams(ConstShaderParamsPtr _params,
       }
       else
       {
-        ignerr << "Shader param texture not found: " << value << std::endl;
+        gzerr << "Shader param texture not found: " << value << std::endl;
         continue;
       }
 
@@ -804,7 +804,7 @@ void Ogre2Material::UpdateShaderParams(ConstShaderParamsPtr _params,
         texUnit->setCubicTextureName(baseName, true);
         // must apply this check for Metal rendering to work
         // (i.e. not segfault). See the discussion in:
-        // https://github.com/ignitionrobotics/ign-rendering/pull/541
+        // https://github.com/gazebosim/gz-rendering/pull/541
         if (texUnit->isLoaded())
         {
           texUnit->_load();
@@ -812,7 +812,7 @@ void Ogre2Material::UpdateShaderParams(ConstShaderParamsPtr _params,
       }
       else
       {
-        ignerr << "Unrecognized texture type set for shader param: "
+        gzerr << "Unrecognized texture type set for shader param: "
                << name_param.first << std::endl;
         continue;
       }
@@ -882,7 +882,7 @@ void Ogre2Material::SetTextureMapImpl(const std::string &_texture,
   Ogre::PbsTextureTypes _type)
 {
   // FIXME(anyone) need to keep baseName = _texture for all meshes. Refer to
-  // https://github.com/ignitionrobotics/ign-rendering/issues/139
+  // https://github.com/gazebosim/gz-rendering/issues/139
   // for more details
   std::string baseName = _texture;
   if (common::isFile(_texture))
@@ -938,7 +938,7 @@ void Ogre2Material::SetTextureMapImpl(const std::string &_texture,
       auto tex = textureMgr->findTextureNoThrow(rgbTexName);
       if (!tex)
       {
-        ignmsg << "Grayscale emissive texture detected. Converting to RGB: "
+        gzmsg << "Grayscale emissive texture detected. Converting to RGB: "
                << rgbTexName << std::endl;
         // need to be 4 channels for gpu texture
         unsigned int channels = 4u;
@@ -1056,7 +1056,7 @@ void Ogre2Material::Init()
 
   if (!this->ogreHlmsPbs)
   {
-    ignerr << "Ogre HLMS PBS not ready. Is Ogre2 Render Engine initiallized?"
+    gzerr << "Ogre HLMS PBS not ready. Is Ogre2 Render Engine initiallized?"
            << std::endl;
     return;
   }
@@ -1122,7 +1122,7 @@ Ogre::HlmsUnlitDatablock *Ogre2Material::UnlitDatablock()
         hlmsManager->getHlms(Ogre::HLMS_UNLIT));
     if (!ogreHlmsUnlit)
     {
-      ignerr << "Ogre HLMS UNLIT not ready. Is Ogre2 Render Engine "
+      gzerr << "Ogre HLMS UNLIT not ready. Is Ogre2 Render Engine "
              << "initiallized?" << std::endl;
       return nullptr;
     }
@@ -1177,7 +1177,7 @@ void Ogre2Material::SetVertexShader(const std::string &_path)
 
   if (!common::exists(_path))
   {
-    ignerr << "Vertex shader path does not exist: " << _path << std::endl;
+    gzerr << "Vertex shader path does not exist: " << _path << std::endl;
     return;
   }
 
@@ -1231,14 +1231,14 @@ void Ogre2Material::SetVertexShader(const std::string &_path)
 
   if(this->dataPtr->ogreSolidColorMat->getNumSupportedTechniques() == 0u)
   {
-    ignwarn
+    gzwarn
       << "Material '" << this->Name()
       << "' could not be paired with special pixel shader '"
       << this->dataPtr->ogreSolidColorShader->getSourceFile()
       << "' See Ogre.log for details. This shader is used for special "
          "rendering in sensors (e.g. Lidar, Thermal). Your vertex shader "
          "must have a compatible signature if you want it to work.\n"
-         "See https://github.com/ignitionrobotics/ign-rendering/issues/544\n"
+         "See https://github.com/gazebosim/gz-rendering/issues/544\n"
          "If this issue isn't fixed, sensor rendering MIGHT not be correct"
          "if your vertex shader performs custom geometry deformation";
   }
@@ -1267,7 +1267,7 @@ void Ogre2Material::SetFragmentShader(const std::string &_path)
 
   if (!common::exists(_path))
   {
-    ignerr << "Fragment shader path does not exist: " << _path << std::endl;
+    gzerr << "Fragment shader path does not exist: " << _path << std::endl;
     return;
   }
 
diff --git a/ogre2/src/Ogre2MaterialSwitcher.cc b/ogre2/src/Ogre2MaterialSwitcher.cc
index d3e3a35f8..242421227 100644
--- a/ogre2/src/Ogre2MaterialSwitcher.cc
+++ b/ogre2/src/Ogre2MaterialSwitcher.cc
@@ -15,13 +15,13 @@
  *
 */
 
-#include "ignition/common/Console.hh"
+#include "gz/common/Console.hh"
 
-#include "ignition/rendering/ogre2/Ogre2Heightmap.hh"
-#include "ignition/rendering/ogre2/Ogre2MaterialSwitcher.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Heightmap.hh"
+#include "gz/rendering/ogre2/Ogre2MaterialSwitcher.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/RenderTypes.hh"
 
 #include "Terra/Terra.h"
 
@@ -39,13 +39,13 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /////////////////////////////////////////////////
 Ogre2MaterialSwitcher::Ogre2MaterialSwitcher(Ogre2ScenePtr _scene)
 {
-  this->currentColor = ignition::math::Color(0.0, 0.0, 0.1);
+  this->currentColor = gz::math::Color(0.0, 0.0, 0.1);
   this->scene = _scene;
 }
 
@@ -102,7 +102,7 @@ void Ogre2MaterialSwitcher::cameraPreRenderScene(
         // We need to keep the material's vertex shader
         // to keep vertex deformation consistent; so we use
         // a cloned material with a different pixel shader
-        // https://github.com/ignitionrobotics/ign-rendering/issues/544
+        // https://github.com/gazebosim/gz-rendering/issues/544
         //
         // material may be a nullptr if we called setMaterial directly
         // (i.e. it's not using Ogre2Material interface).
@@ -239,7 +239,7 @@ void Ogre2MaterialSwitcher::cameraPostRenderScene(
 
 /////////////////////////////////////////////////
 std::string Ogre2MaterialSwitcher::EntityName(
-    const ignition::math::Color &_color) const
+    const gz::math::Color &_color) const
 {
   auto iter = this->colorDict.find(_color.AsRGBA());
 
@@ -260,7 +260,7 @@ void Ogre2MaterialSwitcher::NextColor()
 /////////////////////////////////////////////////
 void Ogre2MaterialSwitcher::Reset()
 {
-  this->currentColor = ignition::math::Color(
+  this->currentColor = gz::math::Color(
       0.0, 0.0, 0.0);
   this->colorDict.clear();
 }
diff --git a/ogre2/src/Ogre2Mesh.cc b/ogre2/src/Ogre2Mesh.cc
index 1b097fe0a..380feb4b1 100644
--- a/ogre2/src/Ogre2Mesh.cc
+++ b/ogre2/src/Ogre2Mesh.cc
@@ -31,27 +31,27 @@
 #pragma warning(pop)
 #endif
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Mesh.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2Storage.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Mesh.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2Storage.hh"
 
 /// brief Private implementation of the Ogre2Mesh class
-class ignition::rendering::Ogre2MeshPrivate
+class gz::rendering::Ogre2MeshPrivate
 {
 };
 
 /// brief Private implementation of the Ogre2SubMesh class
-class ignition::rendering::Ogre2SubMeshPrivate
+class gz::rendering::Ogre2SubMeshPrivate
 {
   /// \brief name of the mesh inside the mesh manager to be able to
   /// remove it
   public: std::string subMeshName;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -102,7 +102,7 @@ bool Ogre2Mesh::HasSkeleton() const
 //////////////////////////////////////////////////
 std::map<std::string, math::Matrix4d> Ogre2Mesh::SkeletonLocalTransforms() const
 {
-  std::map<std::string, ignition::math::Matrix4d> mapTfs;
+  std::map<std::string, gz::math::Matrix4d> mapTfs;
   if (this->ogreItem->hasSkeleton())
   {
     auto skel = this->ogreItem->getSkeletonInstance();
@@ -206,7 +206,7 @@ void Ogre2Mesh::SetSkeletonAnimationEnabled(const std::string &_name,
 
   if (!skel->hasAnimation(_name))
   {
-    ignerr << "Skeleton animation name not found: " << _name << std::endl;
+    gzerr << "Skeleton animation name not found: " << _name << std::endl;
     return;
   }
 
@@ -260,7 +260,7 @@ bool Ogre2Mesh::SkeletonAnimationEnabled(const std::string &_name) const
   Ogre::SkeletonInstance *skel = this->ogreItem->getSkeletonInstance();
   if (!skel->hasAnimation(_name))
   {
-    ignerr << "Skeleton animation name not found: " << _name << std::endl;
+    gzerr << "Skeleton animation name not found: " << _name << std::endl;
     return false;
   }
 
@@ -340,7 +340,7 @@ void Ogre2SubMesh::SetMaterialImpl(MaterialPtr _material)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/Ogre2MeshFactory.cc b/ogre2/src/Ogre2MeshFactory.cc
index 807f24d98..d0cbc4132 100644
--- a/ogre2/src/Ogre2MeshFactory.cc
+++ b/ogre2/src/Ogre2MeshFactory.cc
@@ -18,22 +18,22 @@
 
 #include <sstream>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Material.hh>
-#include <ignition/common/MeshManager.hh>
-#include <ignition/common/Skeleton.hh>
-#include <ignition/common/SkeletonAnimation.hh>
-#include <ignition/common/SubMesh.hh>
-
-#include <ignition/math/Matrix4.hh>
-
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Mesh.hh"
-#include "ignition/rendering/ogre2/Ogre2MeshFactory.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Storage.hh"
+#include <gz/common/Console.hh>
+#include <gz/common/Material.hh>
+#include <gz/common/MeshManager.hh>
+#include <gz/common/Skeleton.hh>
+#include <gz/common/SkeletonAnimation.hh>
+#include <gz/common/SubMesh.hh>
+
+#include <gz/math/Matrix4.hh>
+
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Mesh.hh"
+#include "gz/rendering/ogre2/Ogre2MeshFactory.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Storage.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -56,7 +56,7 @@
 #endif
 
 /// \brief Private data for the Ogre2MeshFactory class
-class ignition::rendering::Ogre2MeshFactoryPrivate
+class gz::rendering::Ogre2MeshFactoryPrivate
 {
   /// \brief Vector with the template materials, we keep the pointer to be
   /// able to remove it when nobody is using it.
@@ -64,11 +64,11 @@ class ignition::rendering::Ogre2MeshFactoryPrivate
 };
 
 /// \brief Private data for the Ogre2SubMeshStoreFactory class
-class ignition::rendering::Ogre2SubMeshStoreFactoryPrivate
+class gz::rendering::Ogre2SubMeshStoreFactoryPrivate
 {
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -122,7 +122,7 @@ Ogre2MeshPtr Ogre2MeshFactory::Create(const MeshDescriptor &_desc)
   // check if invalid mesh
   if (!mesh->ogreItem)
   {
-    ignerr << "Failed to get Ogre item for [" << _desc.meshName << "]"
+    gzerr << "Failed to get Ogre item for [" << _desc.meshName << "]"
            << std::endl;
     return nullptr;
   }
@@ -351,7 +351,7 @@ bool Ogre2MeshFactory::LoadImpl(const MeshDescriptor &_desc)
       }
       else
       {
-        ignerr << "Unknown primitive type["
+        gzerr << "Unknown primitive type["
               << subMesh.SubMeshPrimitiveType() << "]\n";
       }
 
@@ -500,13 +500,13 @@ bool Ogre2MeshFactory::LoadImpl(const MeshDescriptor &_desc)
 
     if (!max.IsFinite())
     {
-      ignerr << "Max bounding box is not finite[" << max << "]" << std::endl;
+      gzerr << "Max bounding box is not finite[" << max << "]" << std::endl;
       return false;
     }
 
     if (!min.IsFinite())
     {
-      ignerr << "Min bounding box is not finite[" << min << "]" << std::endl;
+      gzerr << "Min bounding box is not finite[" << min << "]" << std::endl;
       return false;
     }
 
@@ -524,7 +524,7 @@ bool Ogre2MeshFactory::LoadImpl(const MeshDescriptor &_desc)
   }
   catch(Ogre::Exception &e)
   {
-    ignerr << "Unable to insert mesh[" << e.getDescription() << "]"
+    gzerr << "Unable to insert mesh[" << e.getDescription() << "]"
         << std::endl;
     return false;
   }
@@ -535,7 +535,7 @@ bool Ogre2MeshFactory::LoadImpl(const MeshDescriptor &_desc)
     if (!_desc.subMeshName.empty())
       msg += ", submesh: '" + _desc.subMeshName + "'";
     msg += ". Mesh will be empty.";
-    ignwarn << msg << std::endl;
+    gzwarn << msg << std::endl;
   }
 
   return true;
@@ -556,19 +556,19 @@ bool Ogre2MeshFactory::Validate(const MeshDescriptor &_desc)
 {
   if (!_desc.mesh && _desc.meshName.empty())
   {
-    ignerr << "Invalid mesh-descriptor, no mesh specified" << std::endl;
+    gzerr << "Invalid mesh-descriptor, no mesh specified" << std::endl;
     return false;
   }
 
   if (!_desc.mesh)
   {
-    ignerr << "Cannot load null mesh [" << _desc.meshName << "]" << std::endl;
+    gzerr << "Cannot load null mesh [" << _desc.meshName << "]" << std::endl;
     return false;
   }
 
   if (_desc.mesh->SubMeshCount() == 0)
   {
-    ignerr << "Cannot load mesh with zero sub-meshes" << std::endl;
+    gzerr << "Cannot load mesh with zero sub-meshes" << std::endl;
     return false;
   }
 
diff --git a/ogre2/src/Ogre2Node.cc b/ogre2/src/Ogre2Node.cc
index a9b6b4d5d..3e5f5f254 100644
--- a/ogre2/src/Ogre2Node.cc
+++ b/ogre2/src/Ogre2Node.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Node.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Storage.hh"
+#include "gz/rendering/ogre2/Ogre2Node.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Storage.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -30,7 +30,7 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -146,21 +146,21 @@ void Ogre2Node::Init()
 {
   if (nullptr == this->scene)
   {
-    ignerr << "Failed to initialize node: scene is NULL" << std::endl;
+    gzerr << "Failed to initialize node: scene is NULL" << std::endl;
     return;
   }
 
   auto sceneManager = this->scene->OgreSceneManager();
   if (nullptr == sceneManager)
   {
-    ignerr << "Failed to initialize node: scene manager is NULL" << std::endl;
+    gzerr << "Failed to initialize node: scene manager is NULL" << std::endl;
     return;
   }
 
   this->ogreNode = sceneManager->createSceneNode();
   if (nullptr == this->ogreNode)
   {
-    ignerr << "Failed to create Ogre node" << std::endl;
+    gzerr << "Failed to create Ogre node" << std::endl;
     return;
   }
   this->ogreNode->setInheritScale(true);
@@ -183,7 +183,7 @@ bool Ogre2Node::AttachChild(NodePtr _child)
 
   if (!derived)
   {
-    ignerr << "Cannot attach node created by another render-engine"
+    gzerr << "Cannot attach node created by another render-engine"
         << std::endl;
     return false;
   }
@@ -195,7 +195,7 @@ bool Ogre2Node::AttachChild(NodePtr _child)
   {
     if (p == derived->Node())
     {
-      ignerr << "Node cycle detected. Not adding Node: " << _child->Name()
+      gzerr << "Node cycle detected. Not adding Node: " << _child->Name()
              << std::endl;
       return false;
     }
@@ -217,7 +217,7 @@ bool Ogre2Node::DetachChild(NodePtr _child)
 
   if (!derived)
   {
-    ignerr << "Cannot detach node created by another render-engine"
+    gzerr << "Cannot detach node created by another render-engine"
         << std::endl;
     return false;
   }
diff --git a/ogre2/src/Ogre2Object.cc b/ogre2/src/Ogre2Object.cc
index 35db61317..1c4d2890d 100644
--- a/ogre2/src/Ogre2Object.cc
+++ b/ogre2/src/Ogre2Object.cc
@@ -15,11 +15,11 @@
  *
  */
 
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Object.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Object.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2ObjectInterface.cc b/ogre2/src/Ogre2ObjectInterface.cc
index aad3b108d..b4bcf4dcc 100644
--- a/ogre2/src/Ogre2ObjectInterface.cc
+++ b/ogre2/src/Ogre2ObjectInterface.cc
@@ -15,9 +15,9 @@
  *
  */
 
-#include "ignition/rendering/ogre2/Ogre2ObjectInterface.hh"
+#include "gz/rendering/ogre2/Ogre2ObjectInterface.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2ParticleEmitter.cc b/ogre2/src/Ogre2ParticleEmitter.cc
index b7446db37..036a9c50a 100644
--- a/ogre2/src/Ogre2ParticleEmitter.cc
+++ b/ogre2/src/Ogre2ParticleEmitter.cc
@@ -26,19 +26,19 @@
 #pragma warning(pop)
 #endif
 
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-
-using namespace ignition;
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+
+using namespace gz;
 using namespace rendering;
 
 const uint32_t Ogre2ParticleEmitter::kParticleVisibilityFlags = 0x00100000;
 
-class ignition::rendering::Ogre2ParticleEmitterPrivate
+class gz::rendering::Ogre2ParticleEmitterPrivate
 {
   /// \brief Internal material name.
   public: const std::string kMaterialName = "__particle_emitter_material__";
@@ -120,7 +120,7 @@ void Ogre2ParticleEmitter::SetType(
   // Sanity check: Make sure that the emitter type is valid.
   if (_type == EmitterType::EM_NUM_EMITTERS)
   {
-    ignerr << "SetType() error: You shouldn't use EM_NUM_EMITTERS as a type."
+    gzerr << "SetType() error: You shouldn't use EM_NUM_EMITTERS as a type."
            << std::endl;
     return;
   }
@@ -138,12 +138,12 @@ void Ogre2ParticleEmitter::SetType(
 }
 
 //////////////////////////////////////////////////
-void Ogre2ParticleEmitter::SetEmitterSize(const ignition::math::Vector3d &_size)
+void Ogre2ParticleEmitter::SetEmitterSize(const gz::math::Vector3d &_size)
 {
   // Sanity check: Size should be non-negative.
   if (_size[0] < 0 || _size[1] < 0 || _size[2] < 0)
   {
-    ignerr << "SetEmitterSize() error: Invalid size " << _size << ". "
+    gzerr << "SetEmitterSize() error: Invalid size " << _size << ". "
            << "Emitter size values should be non-negative." << std::endl;
     return;
   }
@@ -175,7 +175,7 @@ void Ogre2ParticleEmitter::SetEmitterSize(const ignition::math::Vector3d &_size)
         // We skip EM_POINT.
         if (!this->dataPtr->emitter->setParameter(param,  value))
         {
-          ignerr << "SetEmitterSize() error for "
+          gzerr << "SetEmitterSize() error for "
                  << this->dataPtr->emitter->getType()
                  << " emitter because SetParameter(" << param << " " << value
                  << ") failed." << std::endl;
@@ -186,7 +186,7 @@ void Ogre2ParticleEmitter::SetEmitterSize(const ignition::math::Vector3d &_size)
     }
     default:
     {
-      ignerr << "Unsupported particle emitter type [" << this->type
+      gzerr << "Unsupported particle emitter type [" << this->type
              << "]" << std::endl;
       return;
     }
@@ -201,7 +201,7 @@ void Ogre2ParticleEmitter::SetRate(double _rate)
   // Sanity check: Rate should be non-negative.
   if (_rate < 0)
   {
-    ignerr << "SetRate() error: Invalid rate [" << _rate << "]. "
+    gzerr << "SetRate() error: Invalid rate [" << _rate << "]. "
            << "The rate should be non-negative." << std::endl;
     return;
   }
@@ -230,12 +230,12 @@ void Ogre2ParticleEmitter::SetEmitting(bool _enable)
 
 //////////////////////////////////////////////////
 void Ogre2ParticleEmitter::SetParticleSize(
-    const ignition::math::Vector3d &_size)
+    const gz::math::Vector3d &_size)
 {
   // Sanity check: Size should be non-negative.
   if (_size[0] < 0 || _size[1] < 0 || _size[2] < 0)
   {
-    ignerr << "SetParticleSize() error: Invalid size " << _size << ". "
+    gzerr << "SetParticleSize() error: Invalid size " << _size << ". "
            << "Particle size values should be non-negative." << std::endl;
     return;
   }
@@ -255,7 +255,7 @@ void Ogre2ParticleEmitter::SetLifetime(double _lifetime)
   // Sanity check: Lifetime should be non-negative.
   if (_lifetime < 0)
   {
-    ignerr << "SetLifetime() error: Invalid lifetime [" << _lifetime << "]. "
+    gzerr << "SetLifetime() error: Invalid lifetime [" << _lifetime << "]. "
            << "The lifetime should be non-negative." << std::endl;
     return;
   }
@@ -271,7 +271,7 @@ void Ogre2ParticleEmitter::SetMaterial(const MaterialPtr &_material)
   // Sanity check: The material cannot be nullptr.
   if (!_material)
   {
-    ignerr << "SetMaterial error: material is NULL" << std::endl;
+    gzerr << "SetMaterial error: material is NULL" << std::endl;
     return;
   }
 
@@ -293,8 +293,8 @@ void Ogre2ParticleEmitter::SetVelocityRange(double _minVelocity,
 
 //////////////////////////////////////////////////
 void Ogre2ParticleEmitter::SetColorRange(
-    const ignition::math::Color &_colorStart,
-    const ignition::math::Color &_colorEnd)
+    const gz::math::Color &_colorStart,
+    const gz::math::Color &_colorEnd)
 {
   // Color interpolator affector.
   if (!this->dataPtr->colorInterpolatorAffector)
@@ -326,7 +326,7 @@ void Ogre2ParticleEmitter::SetColorRange(
   {
     if (!this->dataPtr->colorInterpolatorAffector->setParameter(param,  value))
     {
-      ignerr << "Ignoring SetColorRange() because SetParameter("
+      gzerr << "Ignoring SetColorRange() because SetParameter("
              << param << " " << value << ") failed." << std::endl;
       return;
     }
@@ -342,7 +342,7 @@ void Ogre2ParticleEmitter::SetScaleRate(double _scaleRate)
   // Sanity check: The rate should be non-negative.
   if (_scaleRate < 0)
   {
-    ignerr << "SetScaleRate() error: Invalid rate [" << _scaleRate << "]. "
+    gzerr << "SetScaleRate() error: Invalid rate [" << _scaleRate << "]. "
            << "The rate should be non-negative." << std::endl;
     return;
   }
@@ -363,7 +363,7 @@ void Ogre2ParticleEmitter::SetScaleRate(double _scaleRate)
   {
     if (!this->dataPtr->scalerAffector->setParameter(param,  value))
     {
-      ignerr << "Ignoring SetScaleRate() because SetParameter("
+      gzerr << "Ignoring SetScaleRate() because SetParameter("
              << param << " " << value << ") failed." << std::endl;
       return;
     }
@@ -378,7 +378,7 @@ void Ogre2ParticleEmitter::SetColorRangeImage(const std::string &_image)
   // Sanity check: Make sure that the texture can be found.
   if (!common::exists(_image) || !common::isFile(_image))
   {
-    ignerr << "SetColorRangeImage() error: Texture [" << _image << "] not found"
+    gzerr << "SetColorRangeImage() error: Texture [" << _image << "] not found"
            << std::endl;
     return;
   }
@@ -417,7 +417,7 @@ void Ogre2ParticleEmitter::SetColorRangeImage(const std::string &_image)
   {
     if (!this->dataPtr->colorImageAffector->setParameter(param,  value))
     {
-      ignerr << "Ignoring SetColorRangeImage() because SetParameter("
+      gzerr << "Ignoring SetColorRangeImage() because SetParameter("
              << param << " " << value << ") failed." << std::endl;
       return;
     }
@@ -511,5 +511,5 @@ void Ogre2ParticleEmitter::CreateParticleSystem()
   this->dataPtr->ps->setDefaultDimensions(1, 1);
 
   this->ogreNode->attachObject(this->dataPtr->ps);
-  igndbg << "Particle emitter initialized" << std::endl;
+  gzdbg << "Particle emitter initialized" << std::endl;
 }
diff --git a/ogre2/src/Ogre2ParticleNoiseListener.cc b/ogre2/src/Ogre2ParticleNoiseListener.cc
index 5a5110683..254db6143 100644
--- a/ogre2/src/Ogre2ParticleNoiseListener.cc
+++ b/ogre2/src/Ogre2ParticleNoiseListener.cc
@@ -17,17 +17,17 @@
 
 #include <string>
 
-#include <ignition/math/Rand.hh>
+#include <gz/math/Rand.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
 
 #include "Ogre2ParticleNoiseListener.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -87,7 +87,7 @@ void Ogre2ParticleNoiseListener::cameraPreRenderScene(
       psParams->setNamedConstant("particleStddev",
           static_cast<float>(particleStddev));
       psParams->setNamedConstant("rnd",
-          static_cast<float>(ignition::math::Rand::DblUniform(0.0, 1.0)));
+          static_cast<float>(gz::math::Rand::DblUniform(0.0, 1.0)));
 
       // get particle scatter ratio value from particle emitter user data
       // and pass that to the shaders
@@ -103,7 +103,7 @@ void Ogre2ParticleNoiseListener::cameraPreRenderScene(
         }
         catch(Ogre::Exception &e)
         {
-          ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+          gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
         }
         Ogre2ParticleEmitterPtr emitterPtr =
           std::dynamic_pointer_cast<Ogre2ParticleEmitter>(result);
diff --git a/ogre2/src/Ogre2ParticleNoiseListener.hh b/ogre2/src/Ogre2ParticleNoiseListener.hh
index eb0f15d19..49e0c3bb2 100644
--- a/ogre2/src/Ogre2ParticleNoiseListener.hh
+++ b/ogre2/src/Ogre2ParticleNoiseListener.hh
@@ -14,14 +14,14 @@
  * limitations under the License.
  *
  */
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2PARTICLENOISELISTENER_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2PARTICLENOISELISTENER_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2PARTICLENOISELISTENER_HH_
+#define GZ_RENDERING_OGRE2_OGRE2PARTICLENOISELISTENER_HH_
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Helper class for updating particle noise params
     class Ogre2ParticleNoiseListener : public Ogre::Camera::Listener
diff --git a/ogre2/src/Ogre2RayQuery.cc b/ogre2/src/Ogre2RayQuery.cc
index 745ea09d7..289bd50f9 100644
--- a/ogre2/src/Ogre2RayQuery.cc
+++ b/ogre2/src/Ogre2RayQuery.cc
@@ -15,20 +15,20 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
-#include <ignition/common/SubMesh.hh>
-
-#include "ignition/rendering/ogre2/Ogre2Camera.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2DepthCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2ObjectInterface.hh"
-#include "ignition/rendering/ogre2/Ogre2RayQuery.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2SegmentationCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2SelectionBuffer.hh"
-#include "ignition/rendering/ogre2/Ogre2ThermalCamera.hh"
+#include <gz/common/Console.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
+#include <gz/common/SubMesh.hh>
+
+#include "gz/rendering/ogre2/Ogre2Camera.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2DepthCamera.hh"
+#include "gz/rendering/ogre2/Ogre2ObjectInterface.hh"
+#include "gz/rendering/ogre2/Ogre2RayQuery.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2SegmentationCamera.hh"
+#include "gz/rendering/ogre2/Ogre2SelectionBuffer.hh"
+#include "gz/rendering/ogre2/Ogre2ThermalCamera.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -43,7 +43,7 @@
 #endif
 
 /// \brief Private data class for Ogre2RayQuery
-class ignition::rendering::Ogre2RayQueryPrivate
+class gz::rendering::Ogre2RayQueryPrivate
 {
   /// \brief Ogre ray scene query object for computing intersection.
   public: Ogre::RaySceneQuery *rayQuery = nullptr;
@@ -58,7 +58,7 @@ class ignition::rendering::Ogre2RayQueryPrivate
   public: std::thread::id threadId;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -90,7 +90,7 @@ void Ogre2RayQuery::SetFromCamera(const CameraPtr &_camera,
       std::dynamic_pointer_cast<Ogre2ObjectInterface>(_camera);
   if (!ogre2ObjectInterface)
   {
-    ignwarn << "Camera does not support ray query\n";
+    gzwarn << "Camera does not support ray query\n";
     return;
   }
 
@@ -245,11 +245,11 @@ RayQueryResult Ogre2RayQuery::ClosestPointByIntersection(bool _forceSceneUpdate)
           if (indexCount <= k+2)
             continue;
 
-          ignition::math::Vector3d vertexA =
+          gz::math::Vector3d vertexA =
             submesh->Vertex(submesh->Index(k));
-          ignition::math::Vector3d vertexB =
+          gz::math::Vector3d vertexB =
             submesh->Vertex(submesh->Index(k+1));
-          ignition::math::Vector3d vertexC =
+          gz::math::Vector3d vertexC =
             submesh->Vertex(submesh->Index(k+2));
 
           Ogre::Vector3 worldVertexA =
diff --git a/ogre2/src/Ogre2RenderEngine.cc b/ogre2/src/Ogre2RenderEngine.cc
index b9a7d644e..4c82ee137 100644
--- a/ogre2/src/Ogre2RenderEngine.cc
+++ b/ogre2/src/Ogre2RenderEngine.cc
@@ -28,19 +28,19 @@
   // pulled in by anybody (e.g., Boost).
   #include <Winsock2.h>
 #endif
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Util.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Util.hh>
 
-#include <ignition/plugin/Register.hh>
+#include <gz/plugin/Register.hh>
 
-#include "ignition/rendering/GraphicsAPI.hh"
-#include "ignition/rendering/RenderEngineManager.hh"
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Storage.hh"
+#include "gz/rendering/GraphicsAPI.hh"
+#include "gz/rendering/RenderEngineManager.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Storage.hh"
 
 #include "Ogre2GzHlmsPbsPrivate.hh"
 #include "Ogre2GzHlmsTerraPrivate.hh"
@@ -51,21 +51,21 @@
 #include "Terra/TerraWorkspaceListener.h"
 #include "Ogre2GzHlmsSphericalClipMinDistance.hh"
 
-class IGNITION_RENDERING_OGRE2_HIDDEN
-    ignition::rendering::Ogre2RenderEnginePrivate
+class GZ_RENDERING_OGRE2_HIDDEN
+    gz::rendering::Ogre2RenderEnginePrivate
 {
 #if !defined(__APPLE__) && !defined(_WIN32)
   public: GLXFBConfig* dummyFBConfigs = nullptr;
 #endif
 
   /// \brief The graphics API to use
-  public: ignition::rendering::GraphicsAPI graphicsAPI{GraphicsAPI::OPENGL};
+  public: gz::rendering::GraphicsAPI graphicsAPI{GraphicsAPI::OPENGL};
 
   /// \brief A list of supported fsaa levels
   public: std::vector<unsigned int> fsaaLevels;
 
   /// \brief Controls Hlms customizations for both PBS and Unlit
-  public: ignition::rendering::Ogre2GzHlmsSphericalClipMinDistance
+  public: gz::rendering::Ogre2GzHlmsSphericalClipMinDistance
   sphericalClipMinDistance;
 
   /// \brief Pbs listener that adds terra shadows
@@ -85,7 +85,7 @@ class IGNITION_RENDERING_OGRE2_HIDDEN
   public: Ogre::Ogre2GzHlmsTerra *ignHlmsTerra{nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -211,7 +211,7 @@ void Ogre2RenderEngine::AddResourcePath(const std::string &_uri)
 
   if (path.empty())
   {
-    ignerr << "URI doesn't exist[" << _uri << "]\n";
+    gzerr << "URI doesn't exist[" << _uri << "]\n";
     return;
   }
 
@@ -268,7 +268,7 @@ void Ogre2RenderEngine::AddResourcePath(const std::string &_uri)
             }
             catch(Ogre::Exception&)
             {
-              ignerr << "Unable to parse material file[" << fullPath << "]\n";
+              gzerr << "Unable to parse material file[" << fullPath << "]\n";
             }
             stream->close();
           }
@@ -278,7 +278,7 @@ void Ogre2RenderEngine::AddResourcePath(const std::string &_uri)
   }
   catch(Ogre::Exception &)
   {
-    ignerr << "Unable to load Ogre Resources.\nMake sure the"
+    gzerr << "Unable to load Ogre Resources.\nMake sure the"
         "resources path in the world file is set correctly." << std::endl;
   }
 }
@@ -338,12 +338,12 @@ bool Ogre2RenderEngine::LoadImpl(
   }
   catch (Ogre::Exception &ex)
   {
-    ignerr << ex.what() << std::endl;
+    gzerr << ex.what() << std::endl;
     return false;
   }
   catch (...)
   {
-    ignerr << "Failed to load render-engine" << std::endl;
+    gzerr << "Failed to load render-engine" << std::endl;
     return false;
   }
 }
@@ -358,7 +358,7 @@ bool Ogre2RenderEngine::InitImpl()
   }
   catch (...)
   {
-    ignerr << "Failed to initialize render-engine" << std::endl;
+    gzerr << "Failed to initialize render-engine" << std::endl;
     return false;
   }
 }
@@ -384,7 +384,7 @@ void Ogre2RenderEngine::CreateLogger()
 {
   // create log file path
   std::string logPath;
-  ignition::common::env(IGN_HOMEDIR, logPath);
+  gz::common::env(IGN_HOMEDIR, logPath);
   logPath = common::joinPaths(logPath, ".ignition", "rendering");
   common::createDirectories(logPath);
   logPath = common::joinPaths(logPath, "ogre2.log");
@@ -411,7 +411,7 @@ void Ogre2RenderEngine::CreateContext()
   {
     // Not able to create a Xwindow, try to run in headless mode
     this->SetHeadless(true);
-    ignwarn << "Unable to open display: " << XDisplayName(0)
+    gzwarn << "Unable to open display: " << XDisplayName(0)
             << ". Trying to run in headless mode." << std::endl;
     return;
   }
@@ -434,7 +434,7 @@ void Ogre2RenderEngine::CreateContext()
 
   if (nelements <= 0)
   {
-    ignerr << "Unable to create glx fbconfig" << std::endl;
+    gzerr << "Unable to create glx fbconfig" << std::endl;
     return;
   }
 
@@ -461,7 +461,7 @@ void Ogre2RenderEngine::CreateContext()
   }
   else
   {
-    ignwarn << "glXCreateContextAttribsARB() not found" << std::endl;
+    gzwarn << "glXCreateContextAttribsARB() not found" << std::endl;
     this->dummyContext = glXCreateNewContext(x11Display,
                                              this->dataPtr->dummyFBConfigs[0],
                                              GLX_RGBA_TYPE, nullptr, 1);
@@ -471,7 +471,7 @@ void Ogre2RenderEngine::CreateContext()
 
   if (!this->dummyContext)
   {
-    ignerr << "Unable to create glx context" << std::endl;
+    gzerr << "Unable to create glx context" << std::endl;
     return;
   }
 
@@ -489,7 +489,7 @@ void Ogre2RenderEngine::CreateRoot()
   }
   catch (Ogre::Exception &)
   {
-    ignerr << "Unable to create Ogre root" << std::endl;
+    gzerr << "Unable to create Ogre root" << std::endl;
   }
 }
 
@@ -541,7 +541,7 @@ void Ogre2RenderEngine::LoadPlugins()
         {
           if ((*piter).find("RenderSystem") != std::string::npos)
           {
-            ignerr << "Unable to find Ogre Plugin[" << *piter
+            gzerr << "Unable to find Ogre Plugin[" << *piter
                    << "]. Rendering will not be possible."
                    << "Make sure you have installed OGRE properly.\n";
           }
@@ -559,7 +559,7 @@ void Ogre2RenderEngine::LoadPlugins()
       {
         if ((*piter).find("RenderSystem") != std::string::npos)
         {
-          ignerr << "Unable to load Ogre Plugin[" << *piter
+          gzerr << "Unable to load Ogre Plugin[" << *piter
                  << "]. Rendering will not be possible."
                  << "Make sure you have installed OGRE properly.\n";
         }
@@ -601,7 +601,7 @@ void Ogre2RenderEngine::CreateRenderSystem()
 
   if (renderSys == nullptr)
   {
-    ignerr << "unable to find " << targetRenderSysName << ". OGRE is probably "
+    gzerr << "unable to find " << targetRenderSysName << ". OGRE is probably "
             "installed incorrectly. Double check the OGRE cmake output, "
             "and make sure OpenGL is enabled." << std::endl;
   }
@@ -671,9 +671,10 @@ void Ogre2RenderEngine::CreateRenderSystem()
 
 void Ogre2RenderEngine::RegisterHlms()
 {
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
   // install path
   std::string mediaPath = common::joinPaths(resourcePath, "ogre2", "media");
   if (!common::exists(mediaPath))
@@ -864,9 +865,10 @@ void Ogre2RenderEngine::RegisterHlms()
 //////////////////////////////////////////////////
 void Ogre2RenderEngine::CreateResources()
 {
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
   // install path
   std::string mediaPath = common::joinPaths(resourcePath, "ogre2", "media");
   if (!common::exists(mediaPath))
@@ -902,7 +904,7 @@ void Ogre2RenderEngine::CreateResources()
       }
       catch(Ogre::Exception &/*_e*/)
       {
-        ignerr << "Unable to load Ogre Resources. Make sure the resources "
+        gzerr << "Unable to load Ogre Resources. Make sure the resources "
             "path in the world file is set correctly." << std::endl;
       }
     }
@@ -917,7 +919,7 @@ void Ogre2RenderEngine::CreateRenderWindow()
       1, 1, 1, 0);
   if (res.empty())
   {
-    ignerr << "Failed to create dummy render window." << std::endl;
+    gzerr << "Failed to create dummy render window." << std::endl;
   }
 }
 
@@ -988,7 +990,7 @@ std::string Ogre2RenderEngine::CreateRenderWindow(const std::string &_handle,
     }
     catch(const std::exception &_e)
     {
-      ignerr << " Unable to create the rendering window: " << _e.what()
+      gzerr << " Unable to create the rendering window: " << _e.what()
              << std::endl;
       window = nullptr;
     }
@@ -996,7 +998,7 @@ std::string Ogre2RenderEngine::CreateRenderWindow(const std::string &_handle,
 
   if (attempts >= 10)
   {
-    ignerr << "Unable to create the rendering window after [" << attempts
+    gzerr << "Unable to create the rendering window after [" << attempts
            << "] attempts." << std::endl;
     return std::string();
   }
@@ -1076,5 +1078,5 @@ Ogre::CompositorWorkspaceListener *Ogre2RenderEngine::TerraWorkspaceListener()
 }
 
 // Register this plugin
-IGNITION_ADD_PLUGIN(ignition::rendering::Ogre2RenderEnginePlugin,
-                    ignition::rendering::RenderEnginePlugin)
+IGNITION_ADD_PLUGIN(gz::rendering::Ogre2RenderEnginePlugin,
+                    gz::rendering::RenderEnginePlugin)
diff --git a/ogre2/src/Ogre2RenderPass.cc b/ogre2/src/Ogre2RenderPass.cc
index 267b2ffff..e562e1516 100644
--- a/ogre2/src/Ogre2RenderPass.cc
+++ b/ogre2/src/Ogre2RenderPass.cc
@@ -14,14 +14,14 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2RenderPass.hh"
+#include "gz/rendering/ogre2/Ogre2RenderPass.hh"
 
 /// \brief Private data for the Ogre2RenderPass class
-class ignition::rendering::Ogre2RenderPassPrivate
+class gz::rendering::Ogre2RenderPassPrivate
 {
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2RenderTarget.cc b/ogre2/src/Ogre2RenderTarget.cc
index d1a2a0e68..2b4dc22b9 100644
--- a/ogre2/src/Ogre2RenderTarget.cc
+++ b/ogre2/src/Ogre2RenderTarget.cc
@@ -15,23 +15,23 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/Material.hh"
+#include "gz/rendering/Material.hh"
 
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderPass.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderPass.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /// \brief Listener for changing ogre compositor pass properties
 class Ogre2RenderTargetCompositorListener :
@@ -75,7 +75,7 @@ class Ogre2RenderTargetCompositorListener :
 }
 
 /// \brief Private data class for Ogre2RenderTarget
-class ignition::rendering::Ogre2RenderTargetPrivate
+class gz::rendering::Ogre2RenderTargetPrivate
 {
   /// \brief Listener for chaning compositor pass properties
   public: Ogre2RenderTargetCompositorListener *rtListener = nullptr;
@@ -101,7 +101,7 @@ class ignition::rendering::Ogre2RenderTargetPrivate
   public: Ogre::TextureGpu *ogreTexture[2] = {nullptr, nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -356,7 +356,7 @@ void Ogre2RenderTarget::Copy(Image &_image) const
 
   if (_image.Width() != this->width || _image.Height() != this->height)
   {
-    ignerr << "Invalid image dimensions" << std::endl;
+    gzerr << "Invalid image dimensions" << std::endl;
     return;
   }
 
@@ -582,7 +582,7 @@ uint8_t Ogre2RenderTarget::TargetFSAA() const
       }
       os << "]";
 
-      ignwarn << "Anti-aliasing level of '" << this->antiAliasing << "' "
+      gzwarn << "Anti-aliasing level of '" << this->antiAliasing << "' "
               << "is not supported; valid FSAA levels are: " << os.str()
               << ". Setting to 0" << std::endl;
       targetFSAA = 0u;
@@ -653,7 +653,7 @@ void Ogre2RenderTarget::UpdateBackgroundMaterial()
       auto skyboxMat = matManager.getByName(this->dataPtr->kSkyboxMaterialName);
       if (!skyboxMat)
       {
-        ignerr << "Unable to find skybox material" << std::endl;
+        gzerr << "Unable to find skybox material" << std::endl;
         return;
       }
       mat = skyboxMat->clone(skyMatName);
diff --git a/ogre2/src/Ogre2RenderTargetMaterial.cc b/ogre2/src/Ogre2RenderTargetMaterial.cc
index d87645a78..8a2d31ca6 100644
--- a/ogre2/src/Ogre2RenderTargetMaterial.cc
+++ b/ogre2/src/Ogre2RenderTargetMaterial.cc
@@ -15,7 +15,7 @@
  *
  */
 
-#include "ignition/rendering/ogre2/Ogre2RenderTargetMaterial.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTargetMaterial.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -26,7 +26,7 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition::rendering;
+using namespace gz::rendering;
 
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2Scene.cc b/ogre2/src/Ogre2Scene.cc
index 9dedbf1fc..681908643 100644
--- a/ogre2/src/Ogre2Scene.cc
+++ b/ogre2/src/Ogre2Scene.cc
@@ -15,39 +15,39 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2ArrowVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2AxisVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2Camera.hh"
-#include "ignition/rendering/ogre2/Ogre2Capsule.hh"
-#include "ignition/rendering/ogre2/Ogre2COMVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2DepthCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2GizmoVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2GpuRays.hh"
-#include "ignition/rendering/ogre2/Ogre2Grid.hh"
-#include "ignition/rendering/ogre2/Ogre2Heightmap.hh"
-#include "ignition/rendering/ogre2/Ogre2InertiaVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2JointVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2Light.hh"
-#include "ignition/rendering/ogre2/Ogre2LightVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2LidarVisual.hh"
-#include "ignition/rendering/ogre2/Ogre2Marker.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2MeshFactory.hh"
-#include "ignition/rendering/ogre2/Ogre2Node.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RayQuery.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2ThermalCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2SegmentationCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
-#include "ignition/rendering/ogre2/Ogre2WireBox.hh"
+#include <gz/common/Console.hh>
+
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2ArrowVisual.hh"
+#include "gz/rendering/ogre2/Ogre2AxisVisual.hh"
+#include "gz/rendering/ogre2/Ogre2Camera.hh"
+#include "gz/rendering/ogre2/Ogre2Capsule.hh"
+#include "gz/rendering/ogre2/Ogre2COMVisual.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2DepthCamera.hh"
+#include "gz/rendering/ogre2/Ogre2GizmoVisual.hh"
+#include "gz/rendering/ogre2/Ogre2GpuRays.hh"
+#include "gz/rendering/ogre2/Ogre2Grid.hh"
+#include "gz/rendering/ogre2/Ogre2Heightmap.hh"
+#include "gz/rendering/ogre2/Ogre2InertiaVisual.hh"
+#include "gz/rendering/ogre2/Ogre2JointVisual.hh"
+#include "gz/rendering/ogre2/Ogre2Light.hh"
+#include "gz/rendering/ogre2/Ogre2LightVisual.hh"
+#include "gz/rendering/ogre2/Ogre2LidarVisual.hh"
+#include "gz/rendering/ogre2/Ogre2Marker.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2MeshFactory.hh"
+#include "gz/rendering/ogre2/Ogre2Node.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RayQuery.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2ThermalCamera.hh"
+#include "gz/rendering/ogre2/Ogre2SegmentationCamera.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/ogre2/Ogre2WireBox.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -74,7 +74,7 @@
 #endif
 
 /// \brief Private data for the Ogre2Scene class
-class ignition::rendering::Ogre2ScenePrivate
+class gz::rendering::Ogre2ScenePrivate
 {
   /// \brief Flag to indicate if shadows need to be updated
   public: bool shadowsDirty = true;
@@ -100,7 +100,7 @@ class ignition::rendering::Ogre2ScenePrivate
   public: const std::string kShadowNodeName = "PbsMaterialsShadowNode";
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -226,7 +226,7 @@ void Ogre2Scene::PostRender()
 
   if (dataPtr->cameraPassCountPerGpuFlush == 0u)
   {
-    ignwarn << "Calling Scene::PostRender but "
+    gzwarn << "Calling Scene::PostRender but "
                "SetCameraPassCountPerGpuFlush is 0 (legacy mode for clients"
                " not calling PostRender)."
                "Read the documentation on SetCameraPassCountPerGpuFlush, "
@@ -573,7 +573,7 @@ void Ogre2Scene::UpdateShadowNode()
         dirLightCount);
     spotPointLightCount = std::min(
         std::max(maxShadowMaps - dirLightCount * 3, 0u), spotPointLightCount);
-    ignwarn << "Number of shadow-casting lights exceeds the limit supported by "
+    gzwarn << "Number of shadow-casting lights exceeds the limit supported by "
             << "the underlying rendering engine ogre2. Limiting to "
             << dirLightCount << " directional lights and "
             << spotPointLightCount << " point / spot lights" << std::endl;
@@ -1341,7 +1341,7 @@ void Ogre2Scene::CreateRootVisual()
   // check if root visual created successfully
   if (!this->InitObject(this->rootVisual, rootId, rootName))
   {
-    ignerr << "Unable to create root visual" << std::endl;
+    gzerr << "Unable to create root visual" << std::endl;
     this->rootVisual = nullptr;
     return;
   }
diff --git a/ogre2/src/Ogre2SegmentationCamera.cc b/ogre2/src/Ogre2SegmentationCamera.cc
index 45115e7ff..4217baaba 100644
--- a/ogre2/src/Ogre2SegmentationCamera.cc
+++ b/ogre2/src/Ogre2SegmentationCamera.cc
@@ -17,25 +17,25 @@
 
 #include <string>
 
-#include <ignition/common/Console.hh>
-#include <ignition/math/Color.hh>
-
-#include "ignition/rendering/ogre2/Ogre2Camera.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2SegmentationCamera.hh"
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/Utils.hh"
+#include <gz/common/Console.hh>
+#include <gz/math/Color.hh>
+
+#include "gz/rendering/ogre2/Ogre2Camera.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2SegmentationCamera.hh"
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/Utils.hh"
 
 #include "Ogre2SegmentationMaterialSwitcher.hh"
 
 /// \brief Private data for the Ogre2SegmentationCamera class
-class ignition::rendering::Ogre2SegmentationCameraPrivate
+class gz::rendering::Ogre2SegmentationCameraPrivate
 {
   /// \brief buffer to store render texture data & to be sent to listeners
   public: uint8_t *buffer {nullptr};
@@ -61,7 +61,7 @@ class ignition::rendering::Ogre2SegmentationCameraPrivate
   /// \param[in] _height Height of the image
   /// \param[in] _channels Number of channels
   /// \param[in] _format Image Format
-  public: ignition::common::EventT<void(const uint8_t *_data,
+  public: gz::common::EventT<void(const uint8_t *_data,
     unsigned int _width, unsigned int _height, unsigned int _channels,
     const std::string &_format)> newSegmentationFrame;
 
@@ -71,7 +71,7 @@ class ignition::rendering::Ogre2SegmentationCameraPrivate
           materialSwitcher {nullptr};
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /////////////////////////////////////////////////
@@ -141,7 +141,7 @@ void Ogre2SegmentationCamera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   else
   {
@@ -168,14 +168,14 @@ void Ogre2SegmentationCamera::CreateCamera()
   auto ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
   this->ogreCamera = ogreSceneManager->createCamera(this->Name());
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -298,7 +298,7 @@ void Ogre2SegmentationCamera::PostRender()
 }
 
 /////////////////////////////////////////////////
-ignition::common::ConnectionPtr
+gz::common::ConnectionPtr
   Ogre2SegmentationCamera::ConnectNewSegmentationFrame(
   std::function<void(const uint8_t *, unsigned int, unsigned int,
   unsigned int, const std::string &)>  _subscriber)
diff --git a/ogre2/src/Ogre2SegmentationMaterialSwitcher.cc b/ogre2/src/Ogre2SegmentationMaterialSwitcher.cc
index 0a541ae45..6fdaeb3b2 100644
--- a/ogre2/src/Ogre2SegmentationMaterialSwitcher.cc
+++ b/ogre2/src/Ogre2SegmentationMaterialSwitcher.cc
@@ -21,13 +21,13 @@
 #include <utility>
 #include <vector>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Heightmap.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
-#include "ignition/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Heightmap.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/RenderTypes.hh"
 
 #include "Terra/Terra.h"
 
@@ -43,7 +43,7 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /////////////////////////////////////////////////
@@ -286,7 +286,7 @@ void Ogre2SegmentationMaterialSwitcher::cameraPreRenderScene(
       }
       catch(Ogre::Exception &e)
       {
-        ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+        gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
       }
 
       const Ogre::Vector4 customParameter =
@@ -306,7 +306,7 @@ void Ogre2SegmentationMaterialSwitcher::cameraPreRenderScene(
           // We need to keep the material's vertex shader
           // to keep vertex deformation consistent; so we use
           // a cloned material with a different pixel shader
-          // https://github.com/ignitionrobotics/ign-rendering/issues/544
+          // https://github.com/gazebosim/gz-rendering/issues/544
           //
           // material may be a nullptr if we called setMaterial directly
           // (i.e. it's not using Ogre2Material interface).
diff --git a/ogre2/src/Ogre2SegmentationMaterialSwitcher.hh b/ogre2/src/Ogre2SegmentationMaterialSwitcher.hh
index 90825382b..c3f7b039e 100644
--- a/ogre2/src/Ogre2SegmentationMaterialSwitcher.hh
+++ b/ogre2/src/Ogre2SegmentationMaterialSwitcher.hh
@@ -15,8 +15,8 @@
  *
 */
 
-#ifndef IGNITION_RENDERING_OGRE2_OGRE2SEGMENTATIONMATERIALSWITCHER_HH_
-#define IGNITION_RENDERING_OGRE2_OGRE2SEGMENTATIONMATERIALSWITCHER_HH_
+#ifndef GZ_RENDERING_OGRE2_OGRE2SEGMENTATIONMATERIALSWITCHER_HH_
+#define GZ_RENDERING_OGRE2_OGRE2SEGMENTATIONMATERIALSWITCHER_HH_
 
 #include <random>
 #include <string>
@@ -25,19 +25,19 @@
 #include <utility>
 #include <vector>
 
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/ogre2/Export.hh"
-#include "ignition/rendering/ogre2/Ogre2Camera.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/SegmentationCamera.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/ogre2/Export.hh"
+#include "gz/rendering/ogre2/Ogre2Camera.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/SegmentationCamera.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 
 /// \brief Helper class to assign unique colors to renderables
 /// Due to historic reasons it's called "MaterialSwitcher" although
@@ -45,7 +45,7 @@ inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
 ///
 /// Hlms customizations take care of running custom code that outputs
 /// a flat colour
-class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SegmentationMaterialSwitcher :
+class GZ_RENDERING_OGRE2_VISIBLE Ogre2SegmentationMaterialSwitcher :
   public Ogre::Camera::Listener
 {
   /// \brief Constructor
@@ -142,6 +142,6 @@ class IGNITION_RENDERING_OGRE2_VISIBLE Ogre2SegmentationMaterialSwitcher :
 };
 }
 }  // namespace rendering
-}  // namespace ignition
+}  // namespace gz
 
-#endif  // IGNITION_RENDERING_OGRE2_OGRE2SEGMENTATIONMATERIALSWITCHER_HH_
+#endif  // GZ_RENDERING_OGRE2_OGRE2SEGMENTATIONMATERIALSWITCHER_HH_
diff --git a/ogre2/src/Ogre2SelectionBuffer.cc b/ogre2/src/Ogre2SelectionBuffer.cc
index b5d621796..d7c0855b7 100644
--- a/ogre2/src/Ogre2SelectionBuffer.cc
+++ b/ogre2/src/Ogre2SelectionBuffer.cc
@@ -16,16 +16,16 @@
 */
 
 #include <memory>
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
-#include "ignition/common/Console.hh"
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2MaterialSwitcher.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2SelectionBuffer.hh"
+#include "gz/common/Console.hh"
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2MaterialSwitcher.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2SelectionBuffer.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -48,10 +48,10 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
-class ignition::rendering::Ogre2SelectionBufferPrivate
+class gz::rendering::Ogre2SelectionBufferPrivate
 {
   /// \brief This is a material listener and a RenderTargetListener.
   /// The material switcher is applied to only the selection camera
@@ -114,7 +114,7 @@ Ogre2SelectionBuffer::Ogre2SelectionBuffer(const std::string &_cameraName,
       _cameraName);
   if (!this->dataPtr->camera)
   {
-    ignerr << "No camera found. Unable to create Ogre 2 selection buffer "
+    gzerr << "No camera found. Unable to create Ogre 2 selection buffer "
            << std::endl;
     return;
   }
@@ -471,7 +471,7 @@ bool Ogre2SelectionBuffer::ExecuteQuery(const int _x, const int _y,
   math::Pose3d p(pos, rot);
   point = rot * point + pos;
 
-  ignition::math::Color cv;
+  gz::math::Color cv;
   cv.A(1.0);
   cv.R(r / 255.0);
   cv.G(g / 255.0);
diff --git a/ogre2/src/Ogre2Sensor.cc b/ogre2/src/Ogre2Sensor.cc
index 7c919314b..b5a3c831b 100644
--- a/ogre2/src/Ogre2Sensor.cc
+++ b/ogre2/src/Ogre2Sensor.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/ogre2/Ogre2Sensor.hh"
+#include "gz/rendering/ogre2/Ogre2Sensor.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/ogre2/src/Ogre2ThermalCamera.cc b/ogre2/src/Ogre2ThermalCamera.cc
index ba7913699..d13760633 100644
--- a/ogre2/src/Ogre2ThermalCamera.cc
+++ b/ogre2/src/Ogre2ThermalCamera.cc
@@ -49,33 +49,33 @@
 #pragma warning(pop)
 #endif
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/math/Helpers.hh>
-
-#include "ignition/rendering/RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Heightmap.hh"
-#include "ignition/rendering/ogre2/Ogre2Includes.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderEngine.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTarget.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2Sensor.hh"
-#include "ignition/rendering/ogre2/Ogre2ThermalCamera.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
-
-#include <ignition/common/Image.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/math/Helpers.hh>
+
+#include "gz/rendering/RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Heightmap.hh"
+#include "gz/rendering/ogre2/Ogre2Includes.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RenderEngine.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTarget.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2Sensor.hh"
+#include "gz/rendering/ogre2/Ogre2ThermalCamera.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
+
+#include <gz/common/Image.hh>
 
 #include "Terra/Terra.h"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /// \brief Helper class for switching the ogre item's material to heat source
 /// material when a thermal camera is being rendered.
@@ -158,7 +158,7 @@ class Ogre2ThermalCameraMaterialSwitcher : public Ogre::Camera::Listener
 
 /// \internal
 /// \brief Private data for the Ogre2ThermalCamera class
-class ignition::rendering::Ogre2ThermalCameraPrivate
+class gz::rendering::Ogre2ThermalCameraPrivate
 {
   /// \brief Outgoing thermal data, used by newThermalFrame event.
   public: uint16_t *thermalImage = nullptr;
@@ -188,7 +188,7 @@ class ignition::rendering::Ogre2ThermalCameraPrivate
   public: Ogre::MaterialPtr thermalMaterial;
 
   /// \brief Event used to signal thermal image data
-  public: ignition::common::EventT<void(const uint16_t *,
+  public: gz::common::EventT<void(const uint16_t *,
               unsigned int, unsigned int, unsigned int,
               const std::string &)> newThermalFrame;
 
@@ -205,7 +205,7 @@ class ignition::rendering::Ogre2ThermalCameraPrivate
   public: unsigned int bitDepth = 16u;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -278,7 +278,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
       }
       catch(Ogre::Exception &e)
       {
-        ignerr << "Ogre Error:" << e.getFullDescription() << "\n";
+        gzerr << "Ogre Error:" << e.getFullDescription() << "\n";
       }
       Ogre2VisualPtr ogreVisual =
           std::dynamic_pointer_cast<Ogre2Visual>(result);
@@ -307,7 +307,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
             }
             catch(std::bad_variant_access &e)
             {
-              ignerr << "Error casting user data: " << e.what() << "\n";
+              gzerr << "Error casting user data: " << e.what() << "\n";
               temp = -1.0;
               foundTemp = false;
             }
@@ -318,7 +318,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
         if (foundTemp && temp < 0.0)
         {
           temp = 0.0;
-          ignwarn << "Unable to set negatve temperature for: "
+          gzwarn << "Unable to set negatve temperature for: "
               << ogreVisual->Name() << ". Value cannot be lower than absolute "
               << "zero. Clamping temperature to 0 degrees Kelvin."
               << std::endl;
@@ -345,7 +345,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
             // We need to keep the material's vertex shader
             // to keep vertex deformation consistent; so we use
             // a cloned material with a different pixel shader
-            // https://github.com/ignitionrobotics/ign-rendering/issues/544
+            // https://github.com/gazebosim/gz-rendering/issues/544
             //
             // material may be a nullptr if we called setMaterial directly
             // (i.e. it's not using Ogre2Material interface).
@@ -462,7 +462,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
           {
             // TODO(anyone): We need to keep the material's vertex shader
             // to keep vertex deformation consistent. See
-            // https://github.com/ignitionrobotics/ign-rendering/issues/544
+            // https://github.com/gazebosim/gz-rendering/issues/544
             this->materialMap.push_back({ subItem, subItem->getMaterial() });
           }
           else
@@ -508,7 +508,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
             // We need to keep the material's vertex shader
             // to keep vertex deformation consistent; so we use
             // a cloned material with a different pixel shader
-            // https://github.com/ignitionrobotics/ign-rendering/issues/544
+            // https://github.com/gazebosim/gz-rendering/issues/544
             //
             // material may be a nullptr if we called setMaterial directly
             // (i.e. it's not using Ogre2Material interface).
@@ -586,7 +586,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
             }
             catch (std::bad_variant_access &e)
             {
-              ignerr << "Error casting user data: " << e.what() << "\n";
+              gzerr << "Error casting user data: " << e.what() << "\n";
               temp = -1.0;
               foundTemp = false;
             }
@@ -597,7 +597,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
         if (foundTemp && temp < 0.0)
         {
           temp = 0.0;
-          ignwarn << "Unable to set negatve temperature for: " << visual->Name()
+          gzwarn << "Unable to set negatve temperature for: " << visual->Name()
                   << ". Value cannot be lower than absolute "
                   << "zero. Clamping temperature to 0 degrees Kelvin."
                   << std::endl;
@@ -614,7 +614,7 @@ void Ogre2ThermalCameraMaterialSwitcher::cameraPreRenderScene(
       // get heat signature and the corresponding min/max temperature values
       else if (std::get_if<std::string>(&tempAny))
       {
-        ignerr << "Heat Signature not yet supported by Heightmaps. Simulation "
+        gzerr << "Heat Signature not yet supported by Heightmaps. Simulation "
                   "may crash!\n";
       }
       else
@@ -776,7 +776,7 @@ void Ogre2ThermalCamera::Destroy()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
   }
   else
   {
@@ -796,14 +796,14 @@ void Ogre2ThermalCamera::CreateCamera()
   ogreSceneManager = this->scene->OgreSceneManager();
   if (ogreSceneManager == nullptr)
   {
-    ignerr << "Scene manager cannot be obtained" << std::endl;
+    gzerr << "Scene manager cannot be obtained" << std::endl;
     return;
   }
 
   this->ogreCamera = ogreSceneManager->createCamera(this->name);
   if (this->ogreCamera == nullptr)
   {
-    ignerr << "Ogre camera cannot be created" << std::endl;
+    gzerr << "Ogre camera cannot be created" << std::endl;
     return;
   }
 
@@ -1046,7 +1046,7 @@ void Ogre2ThermalCamera::CreateThermalTexture()
 
   if (!wsDef)
   {
-    ignerr << "Unable to add workspace definition [" << wsDefName << "] "
+    gzerr << "Unable to add workspace definition [" << wsDefName << "] "
            << " for " << this->Name();
   }
 
diff --git a/ogre2/src/Ogre2Visual.cc b/ogre2/src/Ogre2Visual.cc
index ba2658e41..e4ac1c90f 100644
--- a/ogre2/src/Ogre2Visual.cc
+++ b/ogre2/src/Ogre2Visual.cc
@@ -15,15 +15,15 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2Conversions.hh"
-#include "ignition/rendering/ogre2/Ogre2Geometry.hh"
-#include "ignition/rendering/ogre2/Ogre2ParticleEmitter.hh"
-#include "ignition/rendering/ogre2/Ogre2RenderTypes.hh"
-#include "ignition/rendering/ogre2/Ogre2Storage.hh"
-#include "ignition/rendering/ogre2/Ogre2Visual.hh"
-#include "ignition/rendering/Utils.hh"
+#include "gz/rendering/ogre2/Ogre2Conversions.hh"
+#include "gz/rendering/ogre2/Ogre2Geometry.hh"
+#include "gz/rendering/ogre2/Ogre2ParticleEmitter.hh"
+#include "gz/rendering/ogre2/Ogre2RenderTypes.hh"
+#include "gz/rendering/ogre2/Ogre2Storage.hh"
+#include "gz/rendering/ogre2/Ogre2Visual.hh"
+#include "gz/rendering/Utils.hh"
 
 #ifdef _MSC_VER
   #pragma warning(push, 0)
@@ -33,11 +33,11 @@
   #pragma warning(pop)
 #endif
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /// \brief Private data for the Ogre2Visual class
-class ignition::rendering::Ogre2VisualPrivate
+class gz::rendering::Ogre2VisualPrivate
 {
   /// \brief True if wireframe mode is enabled
   public: bool wireframe;
@@ -131,14 +131,14 @@ bool Ogre2Visual::AttachGeometry(GeometryPtr _geometry)
 {
   if (!_geometry)
   {
-    ignerr << "Cannot attach null geometry." << std::endl;
+    gzerr << "Cannot attach null geometry." << std::endl;
 
     return false;
   }
 
   if (!this->ogreNode)
   {
-    ignerr << "Cannot attach geometry, null Ogre node." << std::endl;
+    gzerr << "Cannot attach geometry, null Ogre node." << std::endl;
     return false;
   }
 
@@ -147,7 +147,7 @@ bool Ogre2Visual::AttachGeometry(GeometryPtr _geometry)
 
   if (!derived)
   {
-    ignerr << "Cannot attach geometry created by another render-engine"
+    gzerr << "Cannot attach geometry created by another render-engine"
           << std::endl;
 
     return false;
@@ -156,7 +156,7 @@ bool Ogre2Visual::AttachGeometry(GeometryPtr _geometry)
   Ogre::MovableObject *ogreObj = derived->OgreObject();
   if (!ogreObj)
   {
-    ignerr << "Cannot attach a null geometry object" << std::endl;
+    gzerr << "Cannot attach a null geometry object" << std::endl;
     return false;
   }
 
@@ -178,7 +178,7 @@ bool Ogre2Visual::DetachGeometry(GeometryPtr _geometry)
 {
   if (!this->ogreNode)
   {
-    ignerr << "Cannot detach geometry, null Ogre node." << std::endl;
+    gzerr << "Cannot detach geometry, null Ogre node." << std::endl;
     return false;
   }
 
@@ -187,7 +187,7 @@ bool Ogre2Visual::DetachGeometry(GeometryPtr _geometry)
 
   if (!derived)
   {
-    ignerr << "Cannot detach geometry created by another render-engine"
+    gzerr << "Cannot detach geometry created by another render-engine"
           << std::endl;
 
     return false;
@@ -200,36 +200,36 @@ bool Ogre2Visual::DetachGeometry(GeometryPtr _geometry)
 }
 
 //////////////////////////////////////////////////
-ignition::math::AxisAlignedBox Ogre2Visual::LocalBoundingBox() const
+gz::math::AxisAlignedBox Ogre2Visual::LocalBoundingBox() const
 {
-  ignition::math::AxisAlignedBox box;
+  gz::math::AxisAlignedBox box;
   this->BoundsHelper(box, true /* local frame */);
   return box;
 }
 
 //////////////////////////////////////////////////
-ignition::math::AxisAlignedBox Ogre2Visual::BoundingBox() const
+gz::math::AxisAlignedBox Ogre2Visual::BoundingBox() const
 {
-  ignition::math::AxisAlignedBox box;
+  gz::math::AxisAlignedBox box;
   this->BoundsHelper(box, false /* world frame */);
   return box;
 }
 
 //////////////////////////////////////////////////
-void Ogre2Visual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
+void Ogre2Visual::BoundsHelper(gz::math::AxisAlignedBox &_box,
     bool _local) const
 {
   this->BoundsHelper(_box, _local, this->WorldPose());
 }
 
 //////////////////////////////////////////////////
-void Ogre2Visual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
-    bool _local, const ignition::math::Pose3d &_pose) const
+void Ogre2Visual::BoundsHelper(gz::math::AxisAlignedBox &_box,
+    bool _local, const gz::math::Pose3d &_pose) const
 {
   if (!this->ogreNode)
     return;
 
-  ignition::math::Vector3d scale = this->WorldScale();
+  gz::math::Vector3d scale = this->WorldScale();
 
   for (size_t i = 0; i < this->ogreNode->numAttachedObjects(); i++)
   {
@@ -239,15 +239,15 @@ void Ogre2Visual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
     {
       Ogre::Aabb bb = obj->getLocalAabb();
 
-      ignition::math::Vector3d min(0, 0, 0);
-      ignition::math::Vector3d max(0, 0, 0);
-      ignition::math::AxisAlignedBox box(min, max);
+      gz::math::Vector3d min(0, 0, 0);
+      gz::math::Vector3d max(0, 0, 0);
+      gz::math::AxisAlignedBox box(min, max);
 
       // Ogre does not return a valid bounding box for lights.
       if (obj->getMovableType() == Ogre::LightFactory::FACTORY_TYPE_NAME)
       {
-        box.Min() = ignition::math::Vector3d(-0.5, -0.5, -0.5);
-        box.Max()  = ignition::math::Vector3d(0.5, 0.5, 0.5);
+        box.Min() = gz::math::Vector3d(-0.5, -0.5, -0.5);
+        box.Max()  = gz::math::Vector3d(0.5, 0.5, 0.5);
       }
       else
       {
@@ -255,22 +255,22 @@ void Ogre2Visual::BoundsHelper(ignition::math::AxisAlignedBox &_box,
         Ogre::Vector3 ogreMax = bb.getMaximum();
 
         // Get ogre bounding boxes and size to object's scale
-        min = scale * ignition::math::Vector3d(ogreMin.x, ogreMin.y, ogreMin.z);
-        max = scale * ignition::math::Vector3d(ogreMax.x, ogreMax.y, ogreMax.z);
+        min = scale * gz::math::Vector3d(ogreMin.x, ogreMin.y, ogreMin.z);
+        max = scale * gz::math::Vector3d(ogreMax.x, ogreMax.y, ogreMax.z);
         box.Min() = min,
         box.Max() = max;
 
         // Assume world transform
-        ignition::math::Pose3d transform = _pose;
+        gz::math::Pose3d transform = _pose;
 
         // If local frame, calculate transform matrix and set
         if (_local)
         {
-          ignition::math::Pose3d worldPose = this->WorldPose();
-          ignition::math::Vector3d parentPos = _pose.Pos();
-          ignition::math::Quaternion parentRotInv = _pose.Rot().Inverse();
-          ignition::math::Pose3d localTransform =
-            ignition::math::Pose3d(
+          gz::math::Pose3d worldPose = this->WorldPose();
+          gz::math::Vector3d parentPos = _pose.Pos();
+          gz::math::Quaternion parentRotInv = _pose.Rot().Inverse();
+          gz::math::Pose3d localTransform =
+            gz::math::Pose3d(
                 (parentRotInv * (worldPose.Pos() - parentPos)),
                 (parentRotInv * worldPose.Rot()));
           transform = localTransform;
diff --git a/ogre2/src/Ogre2WireBox.cc b/ogre2/src/Ogre2WireBox.cc
index 4e6e7ec28..40505660b 100644
--- a/ogre2/src/Ogre2WireBox.cc
+++ b/ogre2/src/Ogre2WireBox.cc
@@ -15,17 +15,17 @@
  *
 */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ogre2/Ogre2WireBox.hh"
-#include "ignition/rendering/ogre2/Ogre2Material.hh"
-#include "ignition/rendering/ogre2/Ogre2Scene.hh"
-#include "ignition/rendering/ogre2/Ogre2DynamicRenderable.hh"
+#include "gz/rendering/ogre2/Ogre2WireBox.hh"
+#include "gz/rendering/ogre2/Ogre2Material.hh"
+#include "gz/rendering/ogre2/Ogre2Scene.hh"
+#include "gz/rendering/ogre2/Ogre2DynamicRenderable.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
-class ignition::rendering::Ogre2WireBoxPrivate
+class gz::rendering::Ogre2WireBoxPrivate
 {
   /// \brief Wirebox material
   public: Ogre2MaterialPtr material;
@@ -81,8 +81,8 @@ void Ogre2WireBox::Create()
 
   this->dataPtr->wireBox->SetOperationType(MarkerType::MT_LINE_LIST);
 
-  ignition::math::Vector3d max = this->box.Max();
-  ignition::math::Vector3d min = this->box.Min();
+  gz::math::Vector3d max = this->box.Max();
+  gz::math::Vector3d min = this->box.Min();
 
   // line 0
   this->dataPtr->wireBox->AddPoint({min.X(), min.Y(), min.Z()});
@@ -145,7 +145,7 @@ void Ogre2WireBox::SetMaterial(MaterialPtr _material, bool _unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/ogre2/src/media/materials/programs/GLSL/depth_camera_final_fs.glsl b/ogre2/src/media/materials/programs/GLSL/depth_camera_final_fs.glsl
index fd5ad7db2..6a0fbc9e8 100644
--- a/ogre2/src/media/materials/programs/GLSL/depth_camera_final_fs.glsl
+++ b/ogre2/src/media/materials/programs/GLSL/depth_camera_final_fs.glsl
@@ -41,7 +41,7 @@ void main()
   // (even w/ point filtering) causes p.a to loss information (e.g.
   // values close to 0 get rounded to 0)
   //
-  // See https://github.com/ignitionrobotics/ign-rendering/issues/332
+  // See https://github.com/gazebosim/gz-rendering/issues/332
   vec4 p = texelFetch(inputTexture, ivec2(inPs.uv0 *texResolution.xy), 0);
 
   vec3 point = p.xyz;
diff --git a/ogre2/src/media/materials/programs/Metal/depth_camera_final_fs.metal b/ogre2/src/media/materials/programs/Metal/depth_camera_final_fs.metal
index 8133f0872..605f43fe7 100644
--- a/ogre2/src/media/materials/programs/Metal/depth_camera_final_fs.metal
+++ b/ogre2/src/media/materials/programs/Metal/depth_camera_final_fs.metal
@@ -48,7 +48,7 @@ fragment float4 main_metal
   // (even w/ point filtering) causes p.a to loss information (e.g.
   // values close to 0 get rounded to 0)
   //
-  // See https://github.com/ignitionrobotics/ign-rendering/issues/332
+  // See https://github.com/gazebosim/gz-rendering/issues/332
   // Either: Metal equivalent of texelFetch
   float4 p = inputTexture.read(uint2(inPs.uv0 * params.texResolution.xy), 0);
   // Or: Use standard sampler
diff --git a/optix/include/gz/rendering/optix/OptixArrowVisual.hh b/optix/include/gz/rendering/optix/OptixArrowVisual.hh
index 260fa8dad..da7f9b027 100644
--- a/optix/include/gz/rendering/optix/OptixArrowVisual.hh
+++ b/optix/include/gz/rendering/optix/OptixArrowVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseArrowVisual.hh"
 #include "gz/rendering/optix/OptixVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixArrowVisual :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixArrowVisual :
       public BaseArrowVisual<OptixVisual>
     {
       protected: OptixArrowVisual();
diff --git a/optix/include/gz/rendering/optix/OptixAxisVisual.hh b/optix/include/gz/rendering/optix/OptixAxisVisual.hh
index 37f93f619..eba28e974 100644
--- a/optix/include/gz/rendering/optix/OptixAxisVisual.hh
+++ b/optix/include/gz/rendering/optix/OptixAxisVisual.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseAxisVisual.hh"
 #include "gz/rendering/optix/OptixVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixAxisVisual :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixAxisVisual :
       public BaseAxisVisual<OptixVisual>
     {
       protected: OptixAxisVisual();
diff --git a/optix/include/gz/rendering/optix/OptixBox.hh b/optix/include/gz/rendering/optix/OptixBox.hh
index 872173cfb..aee28eb8c 100644
--- a/optix/include/gz/rendering/optix/OptixBox.hh
+++ b/optix/include/gz/rendering/optix/OptixBox.hh
@@ -19,13 +19,13 @@
 
 #include "gz/rendering/optix/OptixPrimitive.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixBox :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixBox :
       public OptixPrimitive
     {
       protected: OptixBox();
diff --git a/optix/include/gz/rendering/optix/OptixCamera.hh b/optix/include/gz/rendering/optix/OptixCamera.hh
index 5ac597500..5584ab592 100644
--- a/optix/include/gz/rendering/optix/OptixCamera.hh
+++ b/optix/include/gz/rendering/optix/OptixCamera.hh
@@ -22,13 +22,13 @@
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 #include "gz/rendering/optix/OptixSensor.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixCamera :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixCamera :
       public BaseCamera<OptixSensor>
     {
       protected: OptixCamera();
diff --git a/optix/include/gz/rendering/optix/OptixCone.hh b/optix/include/gz/rendering/optix/OptixCone.hh
index d3a4d6352..30b5c95c8 100644
--- a/optix/include/gz/rendering/optix/OptixCone.hh
+++ b/optix/include/gz/rendering/optix/OptixCone.hh
@@ -19,13 +19,13 @@
 
 #include "gz/rendering/optix/OptixPrimitive.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixCone :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixCone :
       public OptixPrimitive
     {
       protected: OptixCone();
diff --git a/optix/include/gz/rendering/optix/OptixConversions.hh b/optix/include/gz/rendering/optix/OptixConversions.hh
index bc6ac6a91..0d7122292 100644
--- a/optix/include/gz/rendering/optix/OptixConversions.hh
+++ b/optix/include/gz/rendering/optix/OptixConversions.hh
@@ -25,11 +25,11 @@
 #include "gz/rendering/optix/OptixIncludes.hh"
 #include "gz/rendering/optix/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \addtogroup ign_rendering
     /// \{
@@ -37,7 +37,7 @@ namespace ignition
     /// \brief Conversions Conversions.hh rendering/Conversions.hh
     /// \brief A set of utility function to convert between Gazebo and Optix
     /// data types
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixConversions
+    class GZ_RENDERING_OPTIX_VISIBLE OptixConversions
     {
       /// \brief Return the equivalent optix color
       /// \param[in] _color Gazebo color to convert
diff --git a/optix/include/gz/rendering/optix/OptixCylinder.hh b/optix/include/gz/rendering/optix/OptixCylinder.hh
index 08ac588fc..650adc4a6 100644
--- a/optix/include/gz/rendering/optix/OptixCylinder.hh
+++ b/optix/include/gz/rendering/optix/OptixCylinder.hh
@@ -19,13 +19,13 @@
 
 #include "gz/rendering/optix/OptixPrimitive.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixCylinder :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixCylinder :
       public OptixPrimitive
     {
       protected: OptixCylinder();
diff --git a/optix/include/gz/rendering/optix/OptixGeometry.hh b/optix/include/gz/rendering/optix/OptixGeometry.hh
index 1f5b2b029..3569086ed 100644
--- a/optix/include/gz/rendering/optix/OptixGeometry.hh
+++ b/optix/include/gz/rendering/optix/OptixGeometry.hh
@@ -21,13 +21,13 @@
 #include "gz/rendering/optix/OptixIncludes.hh"
 #include "gz/rendering/optix/OptixObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixGeometry :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixGeometry :
       public BaseGeometry<OptixObject>
     {
       protected: OptixGeometry();
diff --git a/optix/include/gz/rendering/optix/OptixGrid.hh b/optix/include/gz/rendering/optix/OptixGrid.hh
index 9adbaf707..17b6e48b9 100644
--- a/optix/include/gz/rendering/optix/OptixGrid.hh
+++ b/optix/include/gz/rendering/optix/OptixGrid.hh
@@ -24,15 +24,15 @@
 #include "gz/rendering/optix/OptixObject.hh"
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// TODO Not implemented yet!
     /// \brief Optix implementation of a grid geometry
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixGrid
+    class GZ_RENDERING_OPTIX_VISIBLE OptixGrid
       : public BaseGrid<OptixPrimitive>
     {
       /// \brief Constructor
diff --git a/optix/include/gz/rendering/optix/OptixLight.hh b/optix/include/gz/rendering/optix/OptixLight.hh
index 82fd02e0a..2db0989db 100644
--- a/optix/include/gz/rendering/optix/OptixLight.hh
+++ b/optix/include/gz/rendering/optix/OptixLight.hh
@@ -22,28 +22,28 @@
 #include "gz/rendering/optix/OptixIncludes.hh"
 #include "gz/rendering/optix/OptixLightTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixLight :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixLight :
       public BaseLight<OptixNode>
     {
       protected: OptixLight();
 
       public: virtual ~OptixLight();
 
-      public: virtual ignition::math::Color DiffuseColor() const;
+      public: virtual gz::math::Color DiffuseColor() const;
 
       public: virtual void SetDiffuseColor(
-          const ignition::math::Color &_color);
+          const gz::math::Color &_color);
 
-      public: virtual ignition::math::Color SpecularColor() const;
+      public: virtual gz::math::Color SpecularColor() const;
 
       public: virtual void SetSpecularColor(
-          const ignition::math::Color &_color);
+          const gz::math::Color &_color);
 
       public: virtual double AttenuationConstant() const;
 
@@ -74,16 +74,16 @@ namespace ignition
       protected: virtual void Init();
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixDirectionalLight :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixDirectionalLight :
       public BaseDirectionalLight<OptixLight>
     {
       protected: OptixDirectionalLight();
 
       public: virtual ~OptixDirectionalLight();
 
-      public: virtual ignition::math::Vector3d Direction() const;
+      public: virtual gz::math::Vector3d Direction() const;
 
-      public: virtual void SetDirection(const ignition::math::Vector3d &_dir);
+      public: virtual void SetDirection(const gz::math::Vector3d &_dir);
 
       public: virtual OptixDirectionalLightData Data() const;
 
@@ -100,7 +100,7 @@ namespace ignition
       private: friend class OptixScene;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixPointLight :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixPointLight :
       public BasePointLight<OptixLight>
     {
       protected: OptixPointLight();
@@ -122,24 +122,24 @@ namespace ignition
       private: friend class OptixScene;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixSpotLight :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixSpotLight :
       public BaseSpotLight<OptixLight>
     {
       protected: OptixSpotLight();
 
       public: virtual ~OptixSpotLight();
 
-      public: virtual ignition::math::Vector3d Direction() const;
+      public: virtual gz::math::Vector3d Direction() const;
 
-      public: virtual void SetDirection(const ignition::math::Vector3d &_dir);
+      public: virtual void SetDirection(const gz::math::Vector3d &_dir);
 
-      public: virtual ignition::math::Angle InnerAngle() const;
+      public: virtual gz::math::Angle InnerAngle() const;
 
-      public: virtual void SetInnerAngle(const ignition::math::Angle &_angle);
+      public: virtual void SetInnerAngle(const gz::math::Angle &_angle);
 
-      public: virtual ignition::math::Angle OuterAngle() const;
+      public: virtual gz::math::Angle OuterAngle() const;
 
-      public: virtual void SetOuterAngle(const ignition::math::Angle &_angle);
+      public: virtual void SetOuterAngle(const gz::math::Angle &_angle);
 
       public: virtual double Falloff() const;
 
diff --git a/optix/include/gz/rendering/optix/OptixLightManager.hh b/optix/include/gz/rendering/optix/OptixLightManager.hh
index 36d321695..750ce2943 100644
--- a/optix/include/gz/rendering/optix/OptixLightManager.hh
+++ b/optix/include/gz/rendering/optix/OptixLightManager.hh
@@ -25,13 +25,13 @@
 #include "gz/rendering/optix/OptixIncludes.hh"
 #include "gz/rendering/optix/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixLightManager
+    class GZ_RENDERING_OPTIX_VISIBLE OptixLightManager
     {
       public: explicit OptixLightManager(OptixScenePtr _scene);
 
diff --git a/optix/include/gz/rendering/optix/OptixLightTypes.hh b/optix/include/gz/rendering/optix/OptixLightTypes.hh
index bfbe04593..0e2effedd 100644
--- a/optix/include/gz/rendering/optix/OptixLightTypes.hh
+++ b/optix/include/gz/rendering/optix/OptixLightTypes.hh
@@ -20,11 +20,11 @@
 #include <optix_math.h>
 
 #ifndef __CUDA_ARCH__
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-  inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+  inline namespace GZ_RENDERING_VERSION_NAMESPACE {
   //
 #endif
 
diff --git a/optix/include/gz/rendering/optix/OptixMaterial.hh b/optix/include/gz/rendering/optix/OptixMaterial.hh
index 1caa50378..020b9b2a6 100644
--- a/optix/include/gz/rendering/optix/OptixMaterial.hh
+++ b/optix/include/gz/rendering/optix/OptixMaterial.hh
@@ -22,13 +22,13 @@
 #include "gz/rendering/optix/OptixObject.hh"
 #include "gz/rendering/optix/OptixIncludes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixMaterial :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixMaterial :
       public BaseMaterial<OptixObject>
     {
       protected: OptixMaterial();
diff --git a/optix/include/gz/rendering/optix/OptixMesh.hh b/optix/include/gz/rendering/optix/OptixMesh.hh
index a9c777029..d0d1df984 100644
--- a/optix/include/gz/rendering/optix/OptixMesh.hh
+++ b/optix/include/gz/rendering/optix/OptixMesh.hh
@@ -24,13 +24,13 @@
 #include "gz/rendering/optix/OptixObject.hh"
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixMesh :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixMesh :
       public BaseMesh<OptixGeometry>
     {
       typedef std::vector<std::string> NameList;
@@ -56,7 +56,7 @@ namespace ignition
       private: friend class OptixMeshFactory;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixSubMesh :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixSubMesh :
       public BaseSubMesh<OptixObject>
     {
       protected: OptixSubMesh();
diff --git a/optix/include/gz/rendering/optix/OptixMeshFactory.hh b/optix/include/gz/rendering/optix/OptixMeshFactory.hh
index fc0681a1a..6d7a0c738 100644
--- a/optix/include/gz/rendering/optix/OptixMeshFactory.hh
+++ b/optix/include/gz/rendering/optix/OptixMeshFactory.hh
@@ -26,13 +26,13 @@
 #include "gz/rendering/optix/OptixMesh.hh"
 #include "gz/rendering/optix/OptixIncludes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixSubMeshStoreFactory
+    class GZ_RENDERING_OPTIX_VISIBLE OptixSubMeshStoreFactory
     {
       // cppcheck-suppress noExplicitConstructor
       public: OptixSubMeshStoreFactory(OptixScenePtr _scene);
@@ -52,7 +52,7 @@ namespace ignition
       protected: OptixScenePtr scene;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixMeshFactory
+    class GZ_RENDERING_OPTIX_VISIBLE OptixMeshFactory
     {
       // cppcheck-suppress noExplicitConstructor
       public: OptixMeshFactory(OptixScenePtr _scene);
@@ -68,7 +68,7 @@ namespace ignition
       protected: OptixScenePtr scene;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixMeshGeometryFactory
+    class GZ_RENDERING_OPTIX_VISIBLE OptixMeshGeometryFactory
     {
       public: OptixMeshGeometryFactory(OptixScenePtr _scene,
                   const common::SubMesh &_subMesh);
diff --git a/optix/include/gz/rendering/optix/OptixNode.hh b/optix/include/gz/rendering/optix/OptixNode.hh
index 5deb803e9..338d6632f 100644
--- a/optix/include/gz/rendering/optix/OptixNode.hh
+++ b/optix/include/gz/rendering/optix/OptixNode.hh
@@ -22,13 +22,13 @@
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 #include "gz/rendering/optix/OptixObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixNode :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixNode :
       public BaseNode<OptixObject>
     {
       protected: OptixNode();
diff --git a/optix/include/gz/rendering/optix/OptixObject.hh b/optix/include/gz/rendering/optix/OptixObject.hh
index 6ff746085..8dade991b 100644
--- a/optix/include/gz/rendering/optix/OptixObject.hh
+++ b/optix/include/gz/rendering/optix/OptixObject.hh
@@ -21,13 +21,13 @@
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 #include "gz/rendering/optix/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixObject :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixObject :
       public BaseObject
     {
       protected: OptixObject();
diff --git a/optix/include/gz/rendering/optix/OptixPrimitive.hh b/optix/include/gz/rendering/optix/OptixPrimitive.hh
index 649690aa2..27d667329 100644
--- a/optix/include/gz/rendering/optix/OptixPrimitive.hh
+++ b/optix/include/gz/rendering/optix/OptixPrimitive.hh
@@ -20,13 +20,13 @@
 #include <string>
 #include "gz/rendering/optix/OptixGeometry.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixPrimitive :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixPrimitive :
       public OptixGeometry
     {
       protected: OptixPrimitive();
diff --git a/optix/include/gz/rendering/optix/OptixRayTypes.hh b/optix/include/gz/rendering/optix/OptixRayTypes.hh
index b46c1ccf6..853f4fe28 100644
--- a/optix/include/gz/rendering/optix/OptixRayTypes.hh
+++ b/optix/include/gz/rendering/optix/OptixRayTypes.hh
@@ -20,11 +20,11 @@
 #include <optix.h>
 
 #ifndef __CUDA_ARCH__
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-  inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+  inline namespace GZ_RENDERING_VERSION_NAMESPACE {
   //
 #endif
 
diff --git a/optix/include/gz/rendering/optix/OptixRenderEngine.hh b/optix/include/gz/rendering/optix/OptixRenderEngine.hh
index 05635a883..e026d6831 100644
--- a/optix/include/gz/rendering/optix/OptixRenderEngine.hh
+++ b/optix/include/gz/rendering/optix/OptixRenderEngine.hh
@@ -25,14 +25,14 @@
 #include "gz/rendering/base/BaseRenderEngine.hh"
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     /// \brief Plugin for loading optix render engine
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixRenderEnginePlugin :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixRenderEnginePlugin :
       public RenderEnginePlugin
     {
       /// \brief Constructor
@@ -50,7 +50,7 @@ namespace ignition
       public: RenderEngine *Engine() const;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixRenderEngine :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixRenderEngine :
       public virtual BaseRenderEngine,
       public common::SingletonT<OptixRenderEngine>
     {
diff --git a/optix/include/gz/rendering/optix/OptixRenderTarget.hh b/optix/include/gz/rendering/optix/OptixRenderTarget.hh
index 5beffe443..09b99e389 100644
--- a/optix/include/gz/rendering/optix/OptixRenderTarget.hh
+++ b/optix/include/gz/rendering/optix/OptixRenderTarget.hh
@@ -22,13 +22,13 @@
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 #include "gz/rendering/optix/OptixObject.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixRenderTarget :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixRenderTarget :
       public virtual BaseRenderTarget<OptixObject>
     {
       protected: OptixRenderTarget();
@@ -44,7 +44,7 @@ namespace ignition
       protected: float *hostData;
     };
 
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixRenderTexture :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixRenderTexture :
       public virtual BaseRenderTexture<OptixRenderTarget>
     {
       protected: OptixRenderTexture();
@@ -65,7 +65,7 @@ namespace ignition
     };
 
     /// \brief Render window mocked using a render texture.
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixRenderWindow :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixRenderWindow :
       public virtual BaseRenderWindow<OptixRenderTexture>
     {
       /// \brief Constructor
diff --git a/optix/include/gz/rendering/optix/OptixRenderTypes.hh b/optix/include/gz/rendering/optix/OptixRenderTypes.hh
index 12202c74f..857864b0b 100644
--- a/optix/include/gz/rendering/optix/OptixRenderTypes.hh
+++ b/optix/include/gz/rendering/optix/OptixRenderTypes.hh
@@ -19,11 +19,11 @@
 
 #include "gz/rendering/base/BaseRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     class OptixArrowVisual;
     class OptixAxisVisual;
diff --git a/optix/include/gz/rendering/optix/OptixScene.hh b/optix/include/gz/rendering/optix/OptixScene.hh
index 6f94fcff4..a4c26fe41 100644
--- a/optix/include/gz/rendering/optix/OptixScene.hh
+++ b/optix/include/gz/rendering/optix/OptixScene.hh
@@ -25,13 +25,13 @@
 #include "gz/rendering/optix/OptixIncludes.hh"
 #include "gz/rendering/optix/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixScene :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixScene :
       public BaseScene
     {
       protected: OptixScene(unsigned int _id, const std::string &_name);
diff --git a/optix/include/gz/rendering/optix/OptixSensor.hh b/optix/include/gz/rendering/optix/OptixSensor.hh
index 7d3f2dc0f..4a8f5c571 100644
--- a/optix/include/gz/rendering/optix/OptixSensor.hh
+++ b/optix/include/gz/rendering/optix/OptixSensor.hh
@@ -20,13 +20,13 @@
 #include "gz/rendering/base/BaseSensor.hh"
 #include "gz/rendering/optix/OptixNode.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixSensor :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixSensor :
       public BaseSensor<OptixNode>
     {
       protected: OptixSensor();
diff --git a/optix/include/gz/rendering/optix/OptixSphere.hh b/optix/include/gz/rendering/optix/OptixSphere.hh
index 9b3092413..30b465944 100644
--- a/optix/include/gz/rendering/optix/OptixSphere.hh
+++ b/optix/include/gz/rendering/optix/OptixSphere.hh
@@ -19,13 +19,13 @@
 
 #include "gz/rendering/optix/OptixPrimitive.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixSphere :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixSphere :
       public OptixPrimitive
     {
       protected: OptixSphere();
diff --git a/optix/include/gz/rendering/optix/OptixStorage.hh b/optix/include/gz/rendering/optix/OptixStorage.hh
index 0e4fddd21..f4d6691a7 100644
--- a/optix/include/gz/rendering/optix/OptixStorage.hh
+++ b/optix/include/gz/rendering/optix/OptixStorage.hh
@@ -28,11 +28,11 @@
 #include "gz/rendering/optix/OptixSensor.hh"
 #include "gz/rendering/optix/OptixVisual.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
     template class BaseSceneStore<OptixScene>;
     template class BaseNodeStore<OptixNode>;
diff --git a/optix/include/gz/rendering/optix/OptixTextureFactory.hh b/optix/include/gz/rendering/optix/OptixTextureFactory.hh
index 62b1f3b47..d06450fda 100644
--- a/optix/include/gz/rendering/optix/OptixTextureFactory.hh
+++ b/optix/include/gz/rendering/optix/OptixTextureFactory.hh
@@ -22,13 +22,13 @@
 #include "gz/rendering/optix/OptixIncludes.hh"
 #include "gz/rendering/optix/Export.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixTextureFactory
+    class GZ_RENDERING_OPTIX_VISIBLE OptixTextureFactory
     {
       public: explicit OptixTextureFactory(OptixScenePtr _scene);
 
diff --git a/optix/include/gz/rendering/optix/OptixVisual.hh b/optix/include/gz/rendering/optix/OptixVisual.hh
index 990427f22..282f77fff 100644
--- a/optix/include/gz/rendering/optix/OptixVisual.hh
+++ b/optix/include/gz/rendering/optix/OptixVisual.hh
@@ -21,13 +21,13 @@
 #include "gz/rendering/optix/OptixNode.hh"
 #include "gz/rendering/optix/OptixRenderTypes.hh"
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
-    inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+    inline namespace GZ_RENDERING_VERSION_NAMESPACE {
     //
-    class IGNITION_RENDERING_OPTIX_VISIBLE OptixVisual :
+    class GZ_RENDERING_OPTIX_VISIBLE OptixVisual :
       public BaseVisual<OptixNode>
     {
       protected: OptixVisual();
diff --git a/optix/include/ignition/optix.hh b/optix/include/ignition/optix.hh
index 7d1f6ce18..130fc6f6d 100644
--- a/optix/include/ignition/optix.hh
+++ b/optix/include/ignition/optix.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/Export.hh b/optix/include/ignition/rendering/optix/Export.hh
index 9fc7ed7ef..cbf60d643 100644
--- a/optix/include/ignition/rendering/optix/Export.hh
+++ b/optix/include/ignition/rendering/optix/Export.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/Export.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixArrowVisual.hh b/optix/include/ignition/rendering/optix/OptixArrowVisual.hh
index aa929401b..23fcf89e7 100644
--- a/optix/include/ignition/rendering/optix/OptixArrowVisual.hh
+++ b/optix/include/ignition/rendering/optix/OptixArrowVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixArrowVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixAxisVisual.hh b/optix/include/ignition/rendering/optix/OptixAxisVisual.hh
index c8d0d2af6..ffd2eec0e 100644
--- a/optix/include/ignition/rendering/optix/OptixAxisVisual.hh
+++ b/optix/include/ignition/rendering/optix/OptixAxisVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixAxisVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixBox.hh b/optix/include/ignition/rendering/optix/OptixBox.hh
index cf3c79d80..042ee8c02 100644
--- a/optix/include/ignition/rendering/optix/OptixBox.hh
+++ b/optix/include/ignition/rendering/optix/OptixBox.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixBox.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixCamera.hh b/optix/include/ignition/rendering/optix/OptixCamera.hh
index 8cde9744b..40ed2d096 100644
--- a/optix/include/ignition/rendering/optix/OptixCamera.hh
+++ b/optix/include/ignition/rendering/optix/OptixCamera.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixCamera.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixCone.hh b/optix/include/ignition/rendering/optix/OptixCone.hh
index e9e7102a4..12ad8b32e 100644
--- a/optix/include/ignition/rendering/optix/OptixCone.hh
+++ b/optix/include/ignition/rendering/optix/OptixCone.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixCone.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixConversions.hh b/optix/include/ignition/rendering/optix/OptixConversions.hh
index 45b7d6319..616b76de8 100644
--- a/optix/include/ignition/rendering/optix/OptixConversions.hh
+++ b/optix/include/ignition/rendering/optix/OptixConversions.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixConversions.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixCylinder.hh b/optix/include/ignition/rendering/optix/OptixCylinder.hh
index dfbbf9b6d..5271b5093 100644
--- a/optix/include/ignition/rendering/optix/OptixCylinder.hh
+++ b/optix/include/ignition/rendering/optix/OptixCylinder.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixCylinder.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixGeometry.hh b/optix/include/ignition/rendering/optix/OptixGeometry.hh
index 415b69b39..cd0dd52b8 100644
--- a/optix/include/ignition/rendering/optix/OptixGeometry.hh
+++ b/optix/include/ignition/rendering/optix/OptixGeometry.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixGeometry.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixGrid.hh b/optix/include/ignition/rendering/optix/OptixGrid.hh
index 632692ed6..06cd38248 100644
--- a/optix/include/ignition/rendering/optix/OptixGrid.hh
+++ b/optix/include/ignition/rendering/optix/OptixGrid.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixGrid.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixIncludes.hh b/optix/include/ignition/rendering/optix/OptixIncludes.hh
index c315c10aa..0f62c208b 100644
--- a/optix/include/ignition/rendering/optix/OptixIncludes.hh
+++ b/optix/include/ignition/rendering/optix/OptixIncludes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixIncludes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixLight.hh b/optix/include/ignition/rendering/optix/OptixLight.hh
index 4d916c04a..5e3e62c41 100644
--- a/optix/include/ignition/rendering/optix/OptixLight.hh
+++ b/optix/include/ignition/rendering/optix/OptixLight.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixLight.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixLightManager.hh b/optix/include/ignition/rendering/optix/OptixLightManager.hh
index 5c89ec97b..dfcc97cae 100644
--- a/optix/include/ignition/rendering/optix/OptixLightManager.hh
+++ b/optix/include/ignition/rendering/optix/OptixLightManager.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixLightManager.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixLightTypes.hh b/optix/include/ignition/rendering/optix/OptixLightTypes.hh
index e08570d7f..b77e5b017 100644
--- a/optix/include/ignition/rendering/optix/OptixLightTypes.hh
+++ b/optix/include/ignition/rendering/optix/OptixLightTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixLightTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixMaterial.hh b/optix/include/ignition/rendering/optix/OptixMaterial.hh
index 7924615d3..0614219df 100644
--- a/optix/include/ignition/rendering/optix/OptixMaterial.hh
+++ b/optix/include/ignition/rendering/optix/OptixMaterial.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixMaterial.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixMesh.hh b/optix/include/ignition/rendering/optix/OptixMesh.hh
index 272cdf1af..8a38ef946 100644
--- a/optix/include/ignition/rendering/optix/OptixMesh.hh
+++ b/optix/include/ignition/rendering/optix/OptixMesh.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixMesh.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixMeshFactory.hh b/optix/include/ignition/rendering/optix/OptixMeshFactory.hh
index beaa42ce0..9e24aebaf 100644
--- a/optix/include/ignition/rendering/optix/OptixMeshFactory.hh
+++ b/optix/include/ignition/rendering/optix/OptixMeshFactory.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixMeshFactory.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixNode.hh b/optix/include/ignition/rendering/optix/OptixNode.hh
index 2e4d7dfa1..affd1a681 100644
--- a/optix/include/ignition/rendering/optix/OptixNode.hh
+++ b/optix/include/ignition/rendering/optix/OptixNode.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixNode.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixObject.hh b/optix/include/ignition/rendering/optix/OptixObject.hh
index 00359730e..dd4a25a61 100644
--- a/optix/include/ignition/rendering/optix/OptixObject.hh
+++ b/optix/include/ignition/rendering/optix/OptixObject.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixObject.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixPrimitive.hh b/optix/include/ignition/rendering/optix/OptixPrimitive.hh
index 42e5cc0ab..68b362864 100644
--- a/optix/include/ignition/rendering/optix/OptixPrimitive.hh
+++ b/optix/include/ignition/rendering/optix/OptixPrimitive.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixPrimitive.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixRayTypes.hh b/optix/include/ignition/rendering/optix/OptixRayTypes.hh
index a69f2024b..2bcfb9d2c 100644
--- a/optix/include/ignition/rendering/optix/OptixRayTypes.hh
+++ b/optix/include/ignition/rendering/optix/OptixRayTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixRayTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixRenderEngine.hh b/optix/include/ignition/rendering/optix/OptixRenderEngine.hh
index 6cfe01196..1e42bd799 100644
--- a/optix/include/ignition/rendering/optix/OptixRenderEngine.hh
+++ b/optix/include/ignition/rendering/optix/OptixRenderEngine.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixRenderEngine.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixRenderTarget.hh b/optix/include/ignition/rendering/optix/OptixRenderTarget.hh
index 75a5be849..74fe0bf31 100644
--- a/optix/include/ignition/rendering/optix/OptixRenderTarget.hh
+++ b/optix/include/ignition/rendering/optix/OptixRenderTarget.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixRenderTarget.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixRenderTypes.hh b/optix/include/ignition/rendering/optix/OptixRenderTypes.hh
index 566085df7..76e305f04 100644
--- a/optix/include/ignition/rendering/optix/OptixRenderTypes.hh
+++ b/optix/include/ignition/rendering/optix/OptixRenderTypes.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixRenderTypes.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixScene.hh b/optix/include/ignition/rendering/optix/OptixScene.hh
index c15110665..00dcc7308 100644
--- a/optix/include/ignition/rendering/optix/OptixScene.hh
+++ b/optix/include/ignition/rendering/optix/OptixScene.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixScene.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixSensor.hh b/optix/include/ignition/rendering/optix/OptixSensor.hh
index 87e98f48c..1eaf00b11 100644
--- a/optix/include/ignition/rendering/optix/OptixSensor.hh
+++ b/optix/include/ignition/rendering/optix/OptixSensor.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixSensor.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixSphere.hh b/optix/include/ignition/rendering/optix/OptixSphere.hh
index 8cfc10231..a7e56ed7b 100644
--- a/optix/include/ignition/rendering/optix/OptixSphere.hh
+++ b/optix/include/ignition/rendering/optix/OptixSphere.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixSphere.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixStorage.hh b/optix/include/ignition/rendering/optix/OptixStorage.hh
index 9bf6e77df..21c072f32 100644
--- a/optix/include/ignition/rendering/optix/OptixStorage.hh
+++ b/optix/include/ignition/rendering/optix/OptixStorage.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixStorage.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixTextureFactory.hh b/optix/include/ignition/rendering/optix/OptixTextureFactory.hh
index 9ae930569..a1e4d0a8a 100644
--- a/optix/include/ignition/rendering/optix/OptixTextureFactory.hh
+++ b/optix/include/ignition/rendering/optix/OptixTextureFactory.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixTextureFactory.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/OptixVisual.hh b/optix/include/ignition/rendering/optix/OptixVisual.hh
index 218ff401b..ca322248b 100644
--- a/optix/include/ignition/rendering/optix/OptixVisual.hh
+++ b/optix/include/ignition/rendering/optix/OptixVisual.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/OptixVisual.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/detail/Export.hh b/optix/include/ignition/rendering/optix/detail/Export.hh
index 9fc7ed7ef..cbf60d643 100644
--- a/optix/include/ignition/rendering/optix/detail/Export.hh
+++ b/optix/include/ignition/rendering/optix/detail/Export.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/Export.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/include/ignition/rendering/optix/optix.hh b/optix/include/ignition/rendering/optix/optix.hh
index 3d3b78b0c..74f197bc0 100644
--- a/optix/include/ignition/rendering/optix/optix.hh
+++ b/optix/include/ignition/rendering/optix/optix.hh
@@ -16,3 +16,4 @@
  */
 
 #include <gz/rendering/optix/optix.hh>
+#include <ignition/rendering/config.hh>
diff --git a/optix/src/CMakeLists.txt b/optix/src/CMakeLists.txt
index abf802c31..0267903cd 100644
--- a/optix/src/CMakeLists.txt
+++ b/optix/src/CMakeLists.txt
@@ -30,7 +30,7 @@ set(cuda_sources
 set_property(
   SOURCE OptixRenderEngine.cc
   PROPERTY COMPILE_DEFINITIONS
-  IGN_RENDERING_RESOURCE_PATH="${IGN_RENDERING_RESOURCE_PATH}"
+  GZ_RENDERING_RESOURCE_PATH="${GZ_RENDERING_RESOURCE_PATH}"
 )
 
 target_link_libraries(${optix_target}
@@ -46,7 +46,7 @@ target_link_libraries(${optix_target}
 ign_build_tests(TYPE UNIT SOURCES ${gtest_sources})
 
 # Note that plugins are currently being installed in 2 places: /lib and the engine-plugins dir
-install(TARGETS ${optix_target} DESTINATION ${IGNITION_RENDERING_ENGINE_INSTALL_DIR})
+install(TARGETS ${optix_target} DESTINATION ${GZ_RENDERING_ENGINE_INSTALL_DIR})
 
 set (versioned ${CMAKE_SHARED_LIBRARY_PREFIX}${PROJECT_NAME_LOWER}-${engine_name}${CMAKE_SHARED_LIBRARY_SUFFIX})
 set (unversioned ${CMAKE_SHARED_LIBRARY_PREFIX}${PROJECT_NAME_NO_VERSION_LOWER}-${engine_name}${CMAKE_SHARED_LIBRARY_SUFFIX})
@@ -55,11 +55,11 @@ if (WIN32)
   # disable MSVC inherit via dominance warning
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /wd4250")
   INSTALL(CODE "EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E copy
-  ${IGNITION_RENDERING_ENGINE_INSTALL_DIR}\/${versioned} 
-  ${IGNITION_RENDERING_ENGINE_INSTALL_DIR}\/${unversioned})")
+  ${GZ_RENDERING_ENGINE_INSTALL_DIR}\/${versioned} 
+  ${GZ_RENDERING_ENGINE_INSTALL_DIR}\/${unversioned})")
 else()
   EXECUTE_PROCESS(COMMAND ${CMAKE_COMMAND} -E create_symlink ${versioned} ${unversioned})
-  INSTALL(FILES ${PROJECT_BINARY_DIR}/${unversioned} DESTINATION ${IGNITION_RENDERING_ENGINE_INSTALL_DIR})
+  INSTALL(FILES ${PROJECT_BINARY_DIR}/${unversioned} DESTINATION ${GZ_RENDERING_ENGINE_INSTALL_DIR})
 endif()
 
 if("${CUDA_VERSION}" VERSION_LESS "9")
@@ -72,7 +72,7 @@ add_custom_target(${optix_target}-ptx ALL
                   DEPENDS ${ptx_files} ${cuda_sources}
                   SOURCES ${cuda_sources})
 
-set(ptx_dir "${IGN_RENDERING_RESOURCE_PATH}/optix")
+set(ptx_dir "${GZ_RENDERING_RESOURCE_PATH}/optix")
 install(FILES ${ptx_files} DESTINATION ${ptx_dir})
 
 
diff --git a/optix/src/OptixArrowVisual.cc b/optix/src/OptixArrowVisual.cc
index 107b24f17..5492e1668 100644
--- a/optix/src/OptixArrowVisual.cc
+++ b/optix/src/OptixArrowVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixArrowVisual.hh"
+#include "gz/rendering/optix/OptixArrowVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixAxisVisual.cc b/optix/src/OptixAxisVisual.cc
index e3b6d9f62..e12593d77 100644
--- a/optix/src/OptixAxisVisual.cc
+++ b/optix/src/OptixAxisVisual.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixAxisVisual.hh"
+#include "gz/rendering/optix/OptixAxisVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixBox.cc b/optix/src/OptixBox.cc
index 0138980c1..2d51ee2a9 100644
--- a/optix/src/OptixBox.cc
+++ b/optix/src/OptixBox.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixBox.hh"
+#include "gz/rendering/optix/OptixBox.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixCamera.cc b/optix/src/OptixCamera.cc
index caf345b39..b0bc8d9cb 100644
--- a/optix/src/OptixCamera.cc
+++ b/optix/src/OptixCamera.cc
@@ -14,14 +14,14 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixCamera.hh"
+#include "gz/rendering/optix/OptixCamera.hh"
 
-#include <ignition/math/Matrix3.hh>
-#include "ignition/rendering/optix/OptixIncludes.hh"
-#include "ignition/rendering/optix/OptixRenderTarget.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
+#include <gz/math/Matrix3.hh>
+#include "gz/rendering/optix/OptixIncludes.hh"
+#include "gz/rendering/optix/OptixRenderTarget.hh"
+#include "gz/rendering/optix/OptixScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixCamera.cu b/optix/src/OptixCamera.cu
index 70b8021b3..370239064 100644
--- a/optix/src/OptixCamera.cu
+++ b/optix/src/OptixCamera.cu
@@ -16,7 +16,7 @@
  */
 #include <optix.h>
 #include <optix_math.h>
-#include <ignition/rendering/optix/OptixRayTypes.hh>
+#include <gz/rendering/optix/OptixRayTypes.hh>
 
 // camera variables
 rtDeclareVariable(float3, eye, , );
diff --git a/optix/src/OptixCone.cc b/optix/src/OptixCone.cc
index 6ab546321..a5f731bca 100644
--- a/optix/src/OptixCone.cc
+++ b/optix/src/OptixCone.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixCone.hh"
+#include "gz/rendering/optix/OptixCone.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixConversions.cc b/optix/src/OptixConversions.cc
index 27fa476ce..3f7193947 100644
--- a/optix/src/OptixConversions.cc
+++ b/optix/src/OptixConversions.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixConversions.hh"
+#include "gz/rendering/optix/OptixConversions.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixCylinder.cc b/optix/src/OptixCylinder.cc
index 69a0939e9..be0539d05 100644
--- a/optix/src/OptixCylinder.cc
+++ b/optix/src/OptixCylinder.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixCylinder.hh"
+#include "gz/rendering/optix/OptixCylinder.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixGeometry.cc b/optix/src/OptixGeometry.cc
index 03721eea4..4d703df24 100644
--- a/optix/src/OptixGeometry.cc
+++ b/optix/src/OptixGeometry.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include "ignition/rendering/optix/OptixGeometry.hh"
+#include "gz/rendering/optix/OptixGeometry.hh"
 
-#include "ignition/rendering/optix/OptixScene.hh"
-#include "ignition/rendering/optix/OptixVisual.hh"
+#include "gz/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixGrid.cc b/optix/src/OptixGrid.cc
index 6d2c438bb..1ec8f0cd8 100644
--- a/optix/src/OptixGrid.cc
+++ b/optix/src/OptixGrid.cc
@@ -15,11 +15,11 @@
  *
  */
 
-#include "ignition/rendering/optix/OptixGrid.hh"
-#include "ignition/rendering/optix/OptixIncludes.hh"
-#include "ignition/rendering/optix/OptixVisual.hh"
+#include "gz/rendering/optix/OptixGrid.hh"
+#include "gz/rendering/optix/OptixIncludes.hh"
+#include "gz/rendering/optix/OptixVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixLight.cc b/optix/src/OptixLight.cc
index ab759dad6..64e7df818 100644
--- a/optix/src/OptixLight.cc
+++ b/optix/src/OptixLight.cc
@@ -14,14 +14,14 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixLight.hh"
+#include "gz/rendering/optix/OptixLight.hh"
 
-#include "ignition/rendering/optix/OptixConversions.hh"
-#include "ignition/rendering/optix/OptixLightManager.hh"
-#include "ignition/rendering/optix/OptixIncludes.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixConversions.hh"
+#include "gz/rendering/optix/OptixLightManager.hh"
+#include "gz/rendering/optix/OptixIncludes.hh"
+#include "gz/rendering/optix/OptixScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixLightManager.cc b/optix/src/OptixLightManager.cc
index a7ee354af..ea12678c8 100644
--- a/optix/src/OptixLightManager.cc
+++ b/optix/src/OptixLightManager.cc
@@ -14,13 +14,13 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixLightManager.hh"
+#include "gz/rendering/optix/OptixLightManager.hh"
 
-#include "ignition/rendering/optix/OptixLight.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
-#include "ignition/rendering/optix/OptixVisual.hh"
+#include "gz/rendering/optix/OptixLight.hh"
+#include "gz/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixMaterial.cc b/optix/src/OptixMaterial.cc
index a9b0561c8..9218c73d8 100644
--- a/optix/src/OptixMaterial.cc
+++ b/optix/src/OptixMaterial.cc
@@ -14,14 +14,14 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixMaterial.hh"
-#include "ignition/rendering/optix/OptixConversions.hh"
-#include "ignition/rendering/optix/OptixRayTypes.hh"
-#include "ignition/rendering/optix/OptixRenderEngine.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
-#include "ignition/rendering/optix/OptixTextureFactory.hh"
-
-using namespace ignition;
+#include "gz/rendering/optix/OptixMaterial.hh"
+#include "gz/rendering/optix/OptixConversions.hh"
+#include "gz/rendering/optix/OptixRayTypes.hh"
+#include "gz/rendering/optix/OptixRenderEngine.hh"
+#include "gz/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixTextureFactory.hh"
+
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixMaterial.cu b/optix/src/OptixMaterial.cu
index 7539048fd..46ec0fa62 100644
--- a/optix/src/OptixMaterial.cu
+++ b/optix/src/OptixMaterial.cu
@@ -17,8 +17,8 @@
 #include <optix.h>
 #include <optix_math.h>
 #include <optixu/optixu_matrix_namespace.h>
-#include "ignition/rendering/optix/OptixRayTypes.hh"
-#include "ignition/rendering/optix/OptixLightTypes.hh"
+#include "gz/rendering/optix/OptixRayTypes.hh"
+#include "gz/rendering/optix/OptixLightTypes.hh"
 
 // scene variables
 rtDeclareVariable(float3, ambientLightColor, , );
diff --git a/optix/src/OptixMesh.cc b/optix/src/OptixMesh.cc
index 8e0e0aa6b..7860d967d 100644
--- a/optix/src/OptixMesh.cc
+++ b/optix/src/OptixMesh.cc
@@ -15,14 +15,14 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/optix/OptixMesh.hh"
-#include "ignition/rendering/optix/OptixIncludes.hh"
-#include "ignition/rendering/optix/OptixMaterial.hh"
-#include "ignition/rendering/optix/OptixStorage.hh"
+#include "gz/rendering/optix/OptixMesh.hh"
+#include "gz/rendering/optix/OptixIncludes.hh"
+#include "gz/rendering/optix/OptixMaterial.hh"
+#include "gz/rendering/optix/OptixStorage.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -81,7 +81,7 @@ void OptixSubMesh::SetMaterialImpl(MaterialPtr _material)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
         << std::endl;
 
     return;
diff --git a/optix/src/OptixMeshFactory.cc b/optix/src/OptixMeshFactory.cc
index 24ad23035..c96010c55 100644
--- a/optix/src/OptixMeshFactory.cc
+++ b/optix/src/OptixMeshFactory.cc
@@ -14,15 +14,15 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixMeshFactory.hh"
+#include "gz/rendering/optix/OptixMeshFactory.hh"
 
 #include <sstream>
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/SubMesh.hh>
-#include "ignition/rendering/optix/OptixMesh.hh"
-#include "ignition/rendering/optix/OptixStorage.hh"
+#include <gz/common/Mesh.hh>
+#include <gz/common/SubMesh.hh>
+#include "gz/rendering/optix/OptixMesh.hh"
+#include "gz/rendering/optix/OptixStorage.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixMissProgram.cu b/optix/src/OptixMissProgram.cu
index 55a003a73..800b55b29 100644
--- a/optix/src/OptixMissProgram.cu
+++ b/optix/src/OptixMissProgram.cu
@@ -16,7 +16,7 @@
  */
 #include <optix.h>
 #include <optix_math.h>
-#include "ignition/rendering/optix/OptixRayTypes.hh"
+#include "gz/rendering/optix/OptixRayTypes.hh"
 
 rtDeclareVariable(float3, color, , );
 rtDeclareVariable(OptixRadianceRayData, payload, rtPayload, );
diff --git a/optix/src/OptixNode.cc b/optix/src/OptixNode.cc
index 9cbea0566..da817eba9 100644
--- a/optix/src/OptixNode.cc
+++ b/optix/src/OptixNode.cc
@@ -14,13 +14,13 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixNode.hh"
-#include "ignition/rendering/optix/OptixConversions.hh"
-#include "ignition/rendering/optix/OptixIncludes.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
-#include "ignition/rendering/optix/OptixStorage.hh"
+#include "gz/rendering/optix/OptixNode.hh"
+#include "gz/rendering/optix/OptixConversions.hh"
+#include "gz/rendering/optix/OptixIncludes.hh"
+#include "gz/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixStorage.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -151,7 +151,7 @@ bool OptixNode::AttachChild(NodePtr _child)
 
   if (!derived)
   {
-    ignerr << "Cannot attach node created by another render-engine"
+    gzerr << "Cannot attach node created by another render-engine"
         << std::endl;
     return false;
   }
diff --git a/optix/src/OptixObject.cc b/optix/src/OptixObject.cc
index d30572cd9..07f25a4ab 100644
--- a/optix/src/OptixObject.cc
+++ b/optix/src/OptixObject.cc
@@ -14,11 +14,11 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixObject.hh"
+#include "gz/rendering/optix/OptixObject.hh"
 
-#include "ignition/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixPrimitive.cc b/optix/src/OptixPrimitive.cc
index 82eec6b7c..55ffa03da 100644
--- a/optix/src/OptixPrimitive.cc
+++ b/optix/src/OptixPrimitive.cc
@@ -15,13 +15,13 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/optix/OptixPrimitive.hh"
-#include "ignition/rendering/optix/OptixMaterial.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixPrimitive.hh"
+#include "gz/rendering/optix/OptixMaterial.hh"
+#include "gz/rendering/optix/OptixScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -53,7 +53,7 @@ void OptixPrimitive::SetMaterial(MaterialPtr _material, bool unique)
 
   if (!_material)
   {
-    ignerr << "Cannot assign null material" << std::endl;
+    gzerr << "Cannot assign null material" << std::endl;
     return;
   }
 
@@ -64,7 +64,7 @@ void OptixPrimitive::SetMaterial(MaterialPtr _material, bool unique)
 
   if (!derived)
   {
-    ignerr << "Cannot assign material created by another render-engine"
+    gzerr << "Cannot assign material created by another render-engine"
            << std::endl;
 
     return;
diff --git a/optix/src/OptixRenderEngine.cc b/optix/src/OptixRenderEngine.cc
index 32402adeb..9f7e9b2c9 100644
--- a/optix/src/OptixRenderEngine.cc
+++ b/optix/src/OptixRenderEngine.cc
@@ -17,15 +17,15 @@
 
 #include <vector>
 
-#include <ignition/plugin/Register.hh>
+#include <gz/plugin/Register.hh>
 
-#include "ignition/rendering/RenderEngineManager.hh"
-#include "ignition/rendering/optix/OptixIncludes.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
-#include "ignition/rendering/optix/OptixStorage.hh"
-#include "ignition/rendering/optix/OptixRenderEngine.hh"
+#include "gz/rendering/RenderEngineManager.hh"
+#include "gz/rendering/optix/OptixIncludes.hh"
+#include "gz/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixStorage.hh"
+#include "gz/rendering/optix/OptixRenderEngine.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -80,9 +80,10 @@ std::string OptixRenderEngine::PtxFile(const std::string& _fileBase) const
 
   std::vector<std::string> folders;
 
-  const char *env= std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env= std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
   resourcePath = common::joinPaths(resourcePath, "optix");
   folders.push_back(resourcePath);
 
@@ -134,5 +135,5 @@ bool OptixRenderEngine::InitImpl()
 }
 
 // Register this plugin
-IGNITION_ADD_PLUGIN(ignition::rendering::OptixRenderEnginePlugin,
-                    ignition::rendering::RenderEnginePlugin)
+IGNITION_ADD_PLUGIN(gz::rendering::OptixRenderEnginePlugin,
+                    gz::rendering::RenderEnginePlugin)
diff --git a/optix/src/OptixRenderTarget.cc b/optix/src/OptixRenderTarget.cc
index 890d31958..e311de254 100644
--- a/optix/src/OptixRenderTarget.cc
+++ b/optix/src/OptixRenderTarget.cc
@@ -15,14 +15,14 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/optix/OptixRenderTarget.hh"
+#include "gz/rendering/optix/OptixRenderTarget.hh"
 
-#include "ignition/rendering/optix/OptixConversions.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixConversions.hh"
+#include "gz/rendering/optix/OptixScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -46,7 +46,7 @@ void OptixRenderTarget::Copy(Image &_image) const
 
   if (_image.Width() != this->width || _image.Height() != this->height)
   {
-    ignerr << "Invalid image dimensions" << std::endl;
+    gzerr << "Invalid image dimensions" << std::endl;
     return;
   }
 
diff --git a/optix/src/OptixScene.cc b/optix/src/OptixScene.cc
index d7e97063c..5180fbd89 100644
--- a/optix/src/OptixScene.cc
+++ b/optix/src/OptixScene.cc
@@ -13,27 +13,27 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-
-#include "ignition/rendering/optix/OptixArrowVisual.hh"
-#include "ignition/rendering/optix/OptixAxisVisual.hh"
-#include "ignition/rendering/optix/OptixBox.hh"
-#include "ignition/rendering/optix/OptixCamera.hh"
-#include "ignition/rendering/optix/OptixCone.hh"
-#include "ignition/rendering/optix/OptixCylinder.hh"
-#include "ignition/rendering/optix/OptixGeometry.hh"
-#include "ignition/rendering/optix/OptixGrid.hh"
-#include "ignition/rendering/optix/OptixLightManager.hh"
-#include "ignition/rendering/optix/OptixMeshFactory.hh"
-#include "ignition/rendering/optix/OptixRayTypes.hh"
-#include "ignition/rendering/optix/OptixRenderEngine.hh"
-#include "ignition/rendering/optix/OptixRenderTarget.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
-#include "ignition/rendering/optix/OptixSphere.hh"
-#include "ignition/rendering/optix/OptixStorage.hh"
-#include "ignition/rendering/optix/OptixVisual.hh"
-
-using namespace ignition;
+#include <gz/common/Console.hh>
+
+#include "gz/rendering/optix/OptixArrowVisual.hh"
+#include "gz/rendering/optix/OptixAxisVisual.hh"
+#include "gz/rendering/optix/OptixBox.hh"
+#include "gz/rendering/optix/OptixCamera.hh"
+#include "gz/rendering/optix/OptixCone.hh"
+#include "gz/rendering/optix/OptixCylinder.hh"
+#include "gz/rendering/optix/OptixGeometry.hh"
+#include "gz/rendering/optix/OptixGrid.hh"
+#include "gz/rendering/optix/OptixLightManager.hh"
+#include "gz/rendering/optix/OptixMeshFactory.hh"
+#include "gz/rendering/optix/OptixRayTypes.hh"
+#include "gz/rendering/optix/OptixRenderEngine.hh"
+#include "gz/rendering/optix/OptixRenderTarget.hh"
+#include "gz/rendering/optix/OptixScene.hh"
+#include "gz/rendering/optix/OptixSphere.hh"
+#include "gz/rendering/optix/OptixStorage.hh"
+#include "gz/rendering/optix/OptixVisual.hh"
+
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -108,7 +108,7 @@ void OptixScene::SetGradientBackgroundColor(
   this->gradientBackgroundColor = _colors;
   this->isGradientBackgroundColor = true;
 
-  ignwarn << "SetGradientBackgroundColor not implemented for Optix"
+  gzwarn << "SetGradientBackgroundColor not implemented for Optix"
           << std::endl;
 }
 
@@ -116,7 +116,7 @@ void OptixScene::SetGradientBackgroundColor(
 void OptixScene::RemoveGradientBackgroundColor()
 {
   this->isGradientBackgroundColor = false;
-  ignwarn << "RemoveGradientBackgroundColor not implemented for Optix"
+  gzwarn << "RemoveGradientBackgroundColor not implemented for Optix"
           << std::endl;
 }
 
@@ -483,7 +483,7 @@ void OptixScene::CreateRootVisual()
   // check if root visual created successfully
   if (!this->InitObject(this->rootVisual, rootId, rootName))
   {
-    ignerr << "Unable to create root visual" << std::endl;
+    gzerr << "Unable to create root visual" << std::endl;
     this->rootVisual = nullptr;
   }
 
diff --git a/optix/src/OptixSensor.cc b/optix/src/OptixSensor.cc
index 59d3d69bf..6efeb9203 100644
--- a/optix/src/OptixSensor.cc
+++ b/optix/src/OptixSensor.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixSensor.hh"
+#include "gz/rendering/optix/OptixSensor.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixSphere.cc b/optix/src/OptixSphere.cc
index da64723db..45f7e8943 100644
--- a/optix/src/OptixSphere.cc
+++ b/optix/src/OptixSphere.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/optix/OptixSphere.hh"
+#include "gz/rendering/optix/OptixSphere.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/optix/src/OptixTextureFactory.cc b/optix/src/OptixTextureFactory.cc
index 29b369d1f..3330bf40e 100644
--- a/optix/src/OptixTextureFactory.cc
+++ b/optix/src/OptixTextureFactory.cc
@@ -15,13 +15,13 @@
  */
 
 #include <FreeImage.h>
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/optix/OptixTextureFactory.hh"
-#include "ignition/rendering/optix/OptixScene.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/optix/OptixTextureFactory.hh"
+#include "gz/rendering/optix/OptixScene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 // TODO: clone texture sampler, reuse texture buffers
@@ -55,7 +55,7 @@ optix::Buffer OptixTextureFactory::CreateBuffer(const std::string &_filename)
 {
   if (_filename.empty())
   {
-    ignerr << "Cannot load texture from empty filename" << std::endl;
+    gzerr << "Cannot load texture from empty filename" << std::endl;
     return this->CreateBuffer();
   }
 
@@ -64,7 +64,7 @@ optix::Buffer OptixTextureFactory::CreateBuffer(const std::string &_filename)
 
   if (!image)
   {
-    ignerr << "Unable to load texture: " << _filename << std::endl;
+    gzerr << "Unable to load texture: " << _filename << std::endl;
     return this->CreateBuffer();
   }
 
diff --git a/optix/src/OptixVisual.cc b/optix/src/OptixVisual.cc
index 3596a1551..d0873765d 100644
--- a/optix/src/OptixVisual.cc
+++ b/optix/src/OptixVisual.cc
@@ -15,13 +15,13 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/optix/OptixVisual.hh"
-#include "ignition/rendering/optix/OptixConversions.hh"
-#include "ignition/rendering/optix/OptixStorage.hh"
+#include "gz/rendering/optix/OptixVisual.hh"
+#include "gz/rendering/optix/OptixConversions.hh"
+#include "gz/rendering/optix/OptixStorage.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -76,7 +76,7 @@ bool OptixVisual::AttachGeometry(GeometryPtr _geometry)
 
   if (!derived)
   {
-    ignerr << "Cannot attach geometry created by another render-engine"
+    gzerr << "Cannot attach geometry created by another render-engine"
           << std::endl;
 
     return false;
@@ -97,7 +97,7 @@ bool OptixVisual::DetachGeometry(GeometryPtr _geometry)
 
   if (!derived)
   {
-    ignerr << "Cannot detach geometry created by another render-engine"
+    gzerr << "Cannot detach geometry created by another render-engine"
           << std::endl;
 
     return false;
diff --git a/src/ArrowVisual_TEST.cc b/src/ArrowVisual_TEST.cc
index 0be3c0854..1ef443cf3 100644
--- a/src/ArrowVisual_TEST.cc
+++ b/src/ArrowVisual_TEST.cc
@@ -18,17 +18,17 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/ArrowVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/ArrowVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Visual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class ArrowVisualTest : public testing::Test,
@@ -44,7 +44,7 @@ void ArrowVisualTest::ArrowVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -103,7 +103,7 @@ TEST_P(ArrowVisualTest, ArrowVisual)
 
 INSTANTIATE_TEST_CASE_P(ArrowVisual, ArrowVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/AxisVisual_TEST.cc b/src/AxisVisual_TEST.cc
index 717bb87de..ef223244b 100644
--- a/src/AxisVisual_TEST.cc
+++ b/src/AxisVisual_TEST.cc
@@ -18,18 +18,18 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/ArrowVisual.hh"
-#include "ignition/rendering/AxisVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/ArrowVisual.hh"
+#include "gz/rendering/AxisVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Visual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class AxisVisualTest : public testing::Test,
@@ -45,7 +45,7 @@ void AxisVisualTest::AxisVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -100,7 +100,7 @@ TEST_P(AxisVisualTest, AxisVisual)
 
 INSTANTIATE_TEST_CASE_P(AxisVisual, AxisVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/BoundingBox.cc b/src/BoundingBox.cc
index 505ec5b00..a9f64899e 100644
--- a/src/BoundingBox.cc
+++ b/src/BoundingBox.cc
@@ -16,13 +16,13 @@
  */
 
 
-#include "ignition/rendering/BoundingBox.hh"
+#include "gz/rendering/BoundingBox.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
-class ignition::rendering::BoundingBoxPrivate
+class gz::rendering::BoundingBoxPrivate
 {
 };
 
diff --git a/src/BoundingBox_TEST.cc b/src/BoundingBox_TEST.cc
index d4ee62aab..b54defd66 100644
--- a/src/BoundingBox_TEST.cc
+++ b/src/BoundingBox_TEST.cc
@@ -18,9 +18,9 @@
 #include <gtest/gtest.h>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/BoundingBox.hh"
+#include "gz/rendering/BoundingBox.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class BoundingBoxTest : public testing::Test
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 8fc6d41a7..4326bcda9 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -30,7 +30,7 @@ ign_create_core_library(SOURCES ${sources} CXX_STANDARD 17)
 set_property(
   SOURCE RenderEngineManager.cc
   PROPERTY COMPILE_DEFINITIONS
-  IGN_RENDERING_PLUGIN_PATH="${IGN_RENDERING_PLUGIN_PATH}"
+  GZ_RENDERING_PLUGIN_PATH="${GZ_RENDERING_PLUGIN_PATH}"
 )
 
 target_link_libraries(${PROJECT_LIBRARY_TARGET_NAME}
diff --git a/src/COMVisual_TEST.cc b/src/COMVisual_TEST.cc
index 9038114e8..5b4176bb3 100644
--- a/src/COMVisual_TEST.cc
+++ b/src/COMVisual_TEST.cc
@@ -18,16 +18,16 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/COMVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/COMVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class COMVisualTest : public testing::Test,
@@ -43,7 +43,7 @@ void COMVisualTest::COMVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -54,16 +54,16 @@ void COMVisualTest::COMVisual(const std::string &_renderEngine)
   COMVisualPtr comVisual = scene->CreateCOMVisual();
   ASSERT_NE(nullptr, comVisual);
 
-  ignition::math::MassMatrix3d massMatrix(
+  gz::math::MassMatrix3d massMatrix(
       0.0, {2.0, 1.5, 1.0}, {0.0, 0.0, 0.0});
-  ignition::math::Pose3d p(0.0, 1.0, 2.5, 1.0, 0.4, 0.4);
-  ignition::math::Inertiald inertial;
+  gz::math::Pose3d p(0.0, 1.0, 2.5, 1.0, 0.4, 0.4);
+  gz::math::Inertiald inertial;
   inertial.SetMassMatrix(massMatrix);
   inertial.SetPose(p);
 
   // check initial values
   EXPECT_EQ(nullptr, comVisual->SphereVisual());
-  EXPECT_EQ(ignition::math::Pose3d::Zero, comVisual->InertiaPose());
+  EXPECT_EQ(gz::math::Pose3d::Zero, comVisual->InertiaPose());
   EXPECT_DOUBLE_EQ(1.0, comVisual->Mass());
 
   // set invalid mass
@@ -71,7 +71,7 @@ void COMVisualTest::COMVisual(const std::string &_renderEngine)
   comVisual->PreRender();
   EXPECT_EQ(nullptr, comVisual->SphereVisual());
   EXPECT_DOUBLE_EQ(1.0, comVisual->Mass());
-  EXPECT_EQ(ignition::math::Pose3d::Zero, comVisual->InertiaPose());
+  EXPECT_EQ(gz::math::Pose3d::Zero, comVisual->InertiaPose());
 
   // set invalid inertial
   comVisual->SetInertial(inertial);
@@ -104,7 +104,7 @@ TEST_P(COMVisualTest, COMVisual)
 
 INSTANTIATE_TEST_CASE_P(Visual, COMVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/CameraLens.cc b/src/CameraLens.cc
index eb6793ad9..b7cedcca4 100644
--- a/src/CameraLens.cc
+++ b/src/CameraLens.cc
@@ -21,13 +21,13 @@
 #include <utility>
 #include <vector>
 
-#include <ignition/common/Console.hh>
-#include <ignition/math/Vector3.hh>
+#include <gz/common/Console.hh>
+#include <gz/math/Vector3.hh>
 
-#include "ignition/rendering/CameraLens.hh"
+#include "gz/rendering/CameraLens.hh"
 
 /// \brief Private fields of camera lens
-class ignition::rendering::CameraLens::Implementation
+class gz::rendering::CameraLens::Implementation
 {
   /// \brief Linear scale factor
   public: double c1 = 1.0;
@@ -89,7 +89,7 @@ class ignition::rendering::CameraLens::Implementation
               throw std::invalid_argument("Unknown angle function");
             }
 
-            /// \brief Cast to ignition::math::Vector3d,
+            /// \brief Cast to gz::math::Vector3d,
             ///   this vector is passed to shader to avoid branching
             /// \return Vector3 Vector whose one component is 1
             ///   and the rest are nulls
@@ -137,7 +137,7 @@ class ignition::rendering::CameraLens::Implementation
   public: MapFunctionEnum fun = MapFunctionEnum(AFT_IDENTITY);
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -182,7 +182,7 @@ void CameraLens::SetCustomMappingFunction(double _c1, double _c2,
   }
   catch(const std::exception &ex)
   {
-    ignerr << "Angle functionis not known, "
+    gzerr << "Angle functionis not known, "
            << "[tan] will be used instead" << std::endl;
 
     this->dataPtr->fun = CameraLens::Implementation::MapFunctionEnum(AFT_TAN);
@@ -269,7 +269,7 @@ void CameraLens::SetType(MappingFunctionType _type)
   }
   catch(...)
   {
-    ignerr << "Unknown lens type." << std::endl;
+    gzerr << "Unknown lens type." << std::endl;
     return;
   }
 
@@ -297,7 +297,7 @@ void CameraLens::SetType(MappingFunctionType _type)
     }
     catch(const std::exception &ex)
     {
-      ignerr << "`fun` value [" << std::get<4>(params)
+      gzerr << "`fun` value [" << std::get<4>(params)
              << "] is not known, keeping the old one" << std::endl;
     }
   }
@@ -351,7 +351,7 @@ void CameraLens::SetAngleFunction(AngleFunctionType _fun)
   }
   catch(const std::exception &ex)
   {
-    ignerr << "`Fun` value [" << _fun << "] is not known, "
+    gzerr << "`Fun` value [" << _fun << "] is not known, "
            << "keeping the old one" << std::endl;
     return;
   }
diff --git a/src/Camera_TEST.cc b/src/Camera_TEST.cc
index e6f497801..46ab314f1 100644
--- a/src/Camera_TEST.cc
+++ b/src/Camera_TEST.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/GaussianNoisePass.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/Scene.hh"
-
-using namespace ignition;
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/GaussianNoisePass.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/Scene.hh"
+
+using namespace gz;
 using namespace rendering;
 
 class CameraTest : public testing::Test,
@@ -56,7 +56,7 @@ void CameraTest::ViewProjectionMatrix(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -159,7 +159,7 @@ void CameraTest::RenderTexture(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -204,7 +204,7 @@ void CameraTest::TrackFollow(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -276,7 +276,7 @@ void CameraTest::AddRemoveRenderPass(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -293,7 +293,7 @@ void CameraTest::AddRemoveRenderPass(const std::string &_renderEngine)
   RenderPassSystemPtr rpSystem = engine->RenderPassSystem();
   if (!rpSystem)
   {
-    ignwarn << "Render engin '" << _renderEngine << "' does not support "
+    gzwarn << "Render engin '" << _renderEngine << "' does not support "
             << "render pass system" << std::endl;
     return;
   }
@@ -330,7 +330,7 @@ void CameraTest::VisibilityMask(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -388,7 +388,7 @@ TEST_P(CameraTest, VisibilityMask)
 
 INSTANTIATE_TEST_CASE_P(Camera, CameraTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Capsule_TEST.cc b/src/Capsule_TEST.cc
index d59fbe811..1112c9797 100644
--- a/src/Capsule_TEST.cc
+++ b/src/Capsule_TEST.cc
@@ -19,15 +19,15 @@
 
 #include <memory>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Capsule.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Capsule.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class CapsuleTest : public testing::Test,
@@ -41,7 +41,7 @@ void CapsuleTest::Capsule(const std::string &_renderEngine)
 {
   if (_renderEngine != "ogre" && _renderEngine != "ogre2")
   {
-    igndbg << "Capsule not supported yet in rendering engine: "
+    gzdbg << "Capsule not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -49,7 +49,7 @@ void CapsuleTest::Capsule(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -117,7 +117,7 @@ TEST_P(CapsuleTest, Capsule)
 
 INSTANTIATE_TEST_CASE_P(Capsule, CapsuleTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/DistortionPass.cc b/src/DistortionPass.cc
index 3d18d1f0a..a21b48a40 100644
--- a/src/DistortionPass.cc
+++ b/src/DistortionPass.cc
@@ -15,9 +15,9 @@
  *
  */
 
-#include "ignition/rendering/DistortionPass.hh"
+#include "gz/rendering/DistortionPass.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/GaussianNoisePass.cc b/src/GaussianNoisePass.cc
index 9fed44dbc..231225416 100644
--- a/src/GaussianNoisePass.cc
+++ b/src/GaussianNoisePass.cc
@@ -16,9 +16,9 @@
  */
 
 
-#include "ignition/rendering/GaussianNoisePass.hh"
+#include "gz/rendering/GaussianNoisePass.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/GaussianNoisePass_TEST.cc b/src/GaussianNoisePass_TEST.cc
index 61c73b6d9..3b75c6dde 100644
--- a/src/GaussianNoisePass_TEST.cc
+++ b/src/GaussianNoisePass_TEST.cc
@@ -18,15 +18,15 @@
 #include <gtest/gtest.h>
 #include <cmath>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/GaussianNoisePass.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/RenderPassSystem.hh"
+#include "gz/rendering/GaussianNoisePass.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/RenderPassSystem.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class GaussianNoisePassTest : public testing::Test,
@@ -43,7 +43,7 @@ void GaussianNoisePassTest::GaussianNoise(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -52,7 +52,7 @@ void GaussianNoisePassTest::GaussianNoise(const std::string &_renderEngine)
   RenderPassSystemPtr rpSystem = engine->RenderPassSystem();
   if (!rpSystem)
   {
-    ignwarn << "Render engin '" << _renderEngine << "' does not support "
+    gzwarn << "Render engin '" << _renderEngine << "' does not support "
             << "render pass system" << std::endl;
     return;
   }
@@ -98,7 +98,7 @@ TEST_P(GaussianNoisePassTest, GaussianNoise)
 
 INSTANTIATE_TEST_CASE_P(GaussianNoise, GaussianNoisePassTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/GizmoVisual_TEST.cc b/src/GizmoVisual_TEST.cc
index 7387e231c..0c98c32cb 100644
--- a/src/GizmoVisual_TEST.cc
+++ b/src/GizmoVisual_TEST.cc
@@ -18,16 +18,16 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/GizmoVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/GizmoVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class GizmoVisualTest : public testing::Test,
@@ -46,7 +46,7 @@ void GizmoVisualTest::GizmoVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -117,7 +117,7 @@ void GizmoVisualTest::Material(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -210,7 +210,7 @@ TEST_P(GizmoVisualTest, Material)
 
 INSTANTIATE_TEST_CASE_P(Visual, GizmoVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/GraphicsAPI.cc b/src/GraphicsAPI.cc
index 5ecad1c32..636023ac3 100644
--- a/src/GraphicsAPI.cc
+++ b/src/GraphicsAPI.cc
@@ -15,14 +15,14 @@
  *
  */
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/GraphicsAPI.hh"
-#include <ignition/common/EnumIface.hh>
+#include "gz/rendering/config.hh"
+#include "gz/rendering/GraphicsAPI.hh"
+#include <gz/common/EnumIface.hh>
 
 #include <algorithm>
 #include <string>
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/Grid_TEST.cc b/src/Grid_TEST.cc
index 12448f4ba..bb2c84856 100644
--- a/src/Grid_TEST.cc
+++ b/src/Grid_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Grid.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Grid.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class GridTest : public testing::Test,
@@ -39,7 +39,7 @@ void GridTest::Grid(const std::string &_renderEngine)
 {
   if (_renderEngine != "ogre" && _renderEngine != "ogre2")
   {
-    igndbg << "Grid not supported yet in rendering engine: "
+    gzdbg << "Grid not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -47,7 +47,7 @@ void GridTest::Grid(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -96,7 +96,7 @@ TEST_P(GridTest, Grid)
 
 INSTANTIATE_TEST_CASE_P(Grid, GridTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/HeightmapDescriptor.cc b/src/HeightmapDescriptor.cc
index f10ca52cd..ec2e7421f 100644
--- a/src/HeightmapDescriptor.cc
+++ b/src/HeightmapDescriptor.cc
@@ -16,13 +16,13 @@
  */
 
 
-#include "ignition/rendering/HeightmapDescriptor.hh"
+#include "gz/rendering/HeightmapDescriptor.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
-class ignition::rendering::HeightmapTexturePrivate
+class gz::rendering::HeightmapTexturePrivate
 {
   /// \brief Texture size.
   public: double size{1.0};
@@ -35,7 +35,7 @@ class ignition::rendering::HeightmapTexturePrivate
 };
 
 //////////////////////////////////////////////////
-class ignition::rendering::HeightmapBlendPrivate
+class gz::rendering::HeightmapBlendPrivate
 {
   /// \brief Minimum height to blend from.
   public: double minHeight{0.0};
@@ -45,7 +45,7 @@ class ignition::rendering::HeightmapBlendPrivate
 };
 
 //////////////////////////////////////////////////
-class ignition::rendering::HeightmapDescriptorPrivate
+class gz::rendering::HeightmapDescriptorPrivate
 {
   /// \brief Name used for caching
   public: std::string name;
diff --git a/src/Heightmap_TEST.cc b/src/Heightmap_TEST.cc
index 65c737511..b1020e8ac 100644
--- a/src/Heightmap_TEST.cc
+++ b/src/Heightmap_TEST.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/geospatial/ImageHeightmap.hh>
-#include <ignition/utils/ExtraTestMacros.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/geospatial/ImageHeightmap.hh>
+#include <gz/utils/ExtraTestMacros.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Heightmap.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Heightmap.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class HeightmapTest : public testing::Test,
@@ -52,7 +52,7 @@ TEST_P(HeightmapTest, IGN_UTILS_TEST_DISABLED_ON_WIN32(Heightmap))
   std::string renderEngine{this->GetParam()};
   if (renderEngine != "ogre")
   {
-    igndbg << "Heightmap not supported yet in rendering engine: "
+    gzdbg << "Heightmap not supported yet in rendering engine: "
             << renderEngine << std::endl;
     return;
   }
@@ -60,7 +60,7 @@ TEST_P(HeightmapTest, IGN_UTILS_TEST_DISABLED_ON_WIN32(Heightmap))
   auto engine = rendering::engine(renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << renderEngine
+    gzdbg << "Engine '" << renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -174,8 +174,8 @@ TEST_P(HeightmapTest, MoveConstructor)
   descriptor.SetSampling(123u);
 
   HeightmapDescriptor descriptor2(std::move(descriptor));
-  EXPECT_EQ(ignition::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
-  EXPECT_EQ(ignition::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
+  EXPECT_EQ(gz::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
+  EXPECT_EQ(gz::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
   EXPECT_TRUE(descriptor2.UseTerrainPaging());
   EXPECT_EQ(123u, descriptor2.Sampling());
 
@@ -208,8 +208,8 @@ TEST_P(HeightmapTest, CopyConstructor)
   descriptor.SetSampling(123u);
 
   HeightmapDescriptor descriptor2(descriptor);
-  EXPECT_EQ(ignition::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
-  EXPECT_EQ(ignition::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
+  EXPECT_EQ(gz::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
+  EXPECT_EQ(gz::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
   EXPECT_TRUE(descriptor2.UseTerrainPaging());
   EXPECT_EQ(123u, descriptor2.Sampling());
 
@@ -243,8 +243,8 @@ TEST_P(HeightmapTest, CopyAssignmentOperator)
 
   HeightmapDescriptor descriptor2;
   descriptor2 = descriptor;
-  EXPECT_EQ(ignition::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
-  EXPECT_EQ(ignition::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
+  EXPECT_EQ(gz::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
+  EXPECT_EQ(gz::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
   EXPECT_TRUE(descriptor2.UseTerrainPaging());
   EXPECT_EQ(123u, descriptor2.Sampling());
 
@@ -280,8 +280,8 @@ TEST_P(HeightmapTest, MoveAssignmentOperator)
 
   HeightmapDescriptor descriptor2;
   descriptor2 = std::move(descriptor);
-  EXPECT_EQ(ignition::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
-  EXPECT_EQ(ignition::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
+  EXPECT_EQ(gz::math::Vector3d(0.1, 0.2, 0.3), descriptor2.Size());
+  EXPECT_EQ(gz::math::Vector3d(0.5, 0.6, 0.7), descriptor2.Position());
   EXPECT_TRUE(descriptor2.UseTerrainPaging());
   EXPECT_EQ(123u, descriptor2.Sampling());
 
@@ -352,10 +352,10 @@ TEST_P(HeightmapTest, CopyAssignmentAfterMove)
 }
 
 // TODO(anyone) Running test with Ogre1. Update once Ogre2 is supported.
-// https://github.com/ignitionrobotics/ign-rendering/issues/187
+// https://github.com/gazebosim/gz-rendering/issues/187
 INSTANTIATE_TEST_CASE_P(Heightmap, HeightmapTest,
     ::testing::ValuesIn({"ogre"}),
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 /////////////////////////////////////////////////
 int main(int argc, char **argv)
diff --git a/src/Image.cc b/src/Image.cc
index a2ad9cc43..983022e66 100644
--- a/src/Image.cc
+++ b/src/Image.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/Image.hh"
+#include "gz/rendering/Image.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/InertiaVisual_TEST.cc b/src/InertiaVisual_TEST.cc
index 0d958cadf..56c4d5693 100644
--- a/src/InertiaVisual_TEST.cc
+++ b/src/InertiaVisual_TEST.cc
@@ -18,16 +18,16 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/InertiaVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/InertiaVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class InertiaVisualTest : public testing::Test,
@@ -43,7 +43,7 @@ void InertiaVisualTest::InertiaVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -57,10 +57,10 @@ void InertiaVisualTest::InertiaVisual(const std::string &_renderEngine)
   // check initial values
   EXPECT_EQ(nullptr, inertiaVisual->BoxVisual());
 
-  ignition::math::MassMatrix3d massMatrix(
+  gz::math::MassMatrix3d massMatrix(
       2.0, {2.0, 1.5, 1.0}, {0.0, 0.0, 0.0});
-  ignition::math::Pose3d p(0.0, 1.0, 2.5, 1.0, 0.4, 0.4);
-  ignition::math::Inertiald inertial;
+  gz::math::Pose3d p(0.0, 1.0, 2.5, 1.0, 0.4, 0.4);
+  gz::math::Inertiald inertial;
 
   inertiaVisual->SetInertial(inertial);
   EXPECT_EQ(nullptr, inertiaVisual->BoxVisual());
@@ -83,7 +83,7 @@ TEST_P(InertiaVisualTest, InertiaVisual)
 
 INSTANTIATE_TEST_CASE_P(Visual, InertiaVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/JointVisual_TEST.cc b/src/JointVisual_TEST.cc
index 8994719a5..63fbac426 100644
--- a/src/JointVisual_TEST.cc
+++ b/src/JointVisual_TEST.cc
@@ -18,16 +18,16 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/JointVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/JointVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class JointVisualTest : public testing::Test,
@@ -43,7 +43,7 @@ void JointVisualTest::JointVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -109,7 +109,7 @@ TEST_P(JointVisualTest, JointVisual)
 
 INSTANTIATE_TEST_CASE_P(Visual, JointVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/LidarVisual.cc b/src/LidarVisual.cc
index fdacfb3f5..1ef14ebe9 100644
--- a/src/LidarVisual.cc
+++ b/src/LidarVisual.cc
@@ -16,9 +16,9 @@
  */
 
 
-#include "ignition/rendering/LidarVisual.hh"
+#include "gz/rendering/LidarVisual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/LidarVisual_TEST.cc b/src/LidarVisual_TEST.cc
index 5cc600e7b..26dda682d 100644
--- a/src/LidarVisual_TEST.cc
+++ b/src/LidarVisual_TEST.cc
@@ -16,15 +16,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/LidarVisual.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/LidarVisual.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 using namespace std::chrono_literals;
 
@@ -39,7 +39,7 @@ void LidarVisualTest::LidarVisual(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "LidarVisual not supported yet in rendering engine: "
+    gzdbg << "LidarVisual not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -48,7 +48,7 @@ void LidarVisualTest::LidarVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -111,7 +111,7 @@ void LidarVisualTest::LidarVisual(const std::string &_renderEngine)
   lidar->SetSize(12.0);
   EXPECT_DOUBLE_EQ(12.0, lidar->Size());
 
-  ignition::math::Pose3d p(0.5, 2.56, 3.67, 1.4, 2, 4.5);
+  gz::math::Pose3d p(0.5, 2.56, 3.67, 1.4, 2, 4.5);
   lidar->SetOffset(p);
   EXPECT_EQ(lidar->Offset(), p);
 
@@ -137,7 +137,7 @@ TEST_P(LidarVisualTest, LidarVisual)
 
 INSTANTIATE_TEST_CASE_P(LidarVisual, LidarVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/LightVisual_TEST.cc b/src/LightVisual_TEST.cc
index 13f20cb13..137c5557a 100644
--- a/src/LightVisual_TEST.cc
+++ b/src/LightVisual_TEST.cc
@@ -18,16 +18,16 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/LightVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/LightVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class LightVisualTest : public testing::Test,
@@ -43,7 +43,7 @@ void LightVisualTest::LightVisual(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -79,7 +79,7 @@ TEST_P(LightVisualTest, LightVisual)
 
 INSTANTIATE_TEST_CASE_P(Visual, LightVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Light_TEST.cc b/src/Light_TEST.cc
index 821d54af2..03014c77c 100644
--- a/src/Light_TEST.cc
+++ b/src/Light_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/Light.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Light.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class LightTest : public testing::Test,
@@ -43,7 +43,7 @@ void LightTest::Light(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -160,7 +160,7 @@ TEST_P(LightTest, Light)
 
 INSTANTIATE_TEST_CASE_P(Light, LightTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Marker.cc b/src/Marker.cc
index d83c181df..71481eabe 100644
--- a/src/Marker.cc
+++ b/src/Marker.cc
@@ -16,9 +16,9 @@
  */
 
 
-#include "ignition/rendering/Marker.hh"
+#include "gz/rendering/Marker.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/Marker_TEST.cc b/src/Marker_TEST.cc
index 7510df123..b3fac9c6b 100644
--- a/src/Marker_TEST.cc
+++ b/src/Marker_TEST.cc
@@ -16,15 +16,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Marker.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Marker.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 using namespace std::chrono_literals;
 
@@ -39,7 +39,7 @@ void MarkerTest::Marker(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "Marker not supported yet in rendering engine: "
+    gzdbg << "Marker not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -48,7 +48,7 @@ void MarkerTest::Marker(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -126,7 +126,7 @@ TEST_P(MarkerTest, Marker)
 
 INSTANTIATE_TEST_CASE_P(Marker, MarkerTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Material_TEST.cc b/src/Material_TEST.cc
index 67a7d4b81..bb34a24f7 100644
--- a/src/Material_TEST.cc
+++ b/src/Material_TEST.cc
@@ -18,19 +18,19 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Material.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Material.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/Material.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/ShaderType.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/Material.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/ShaderType.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class MaterialTest : public testing::Test,
@@ -39,7 +39,7 @@ class MaterialTest : public testing::Test,
   // Documentation inherited
   public: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 
   /// \brief Test material basic API
@@ -59,7 +59,7 @@ void MaterialTest::MaterialProperties(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -293,7 +293,7 @@ void MaterialTest::Copy(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -510,7 +510,7 @@ TEST_P(MaterialTest, Copy)
 
 INSTANTIATE_TEST_CASE_P(Material, MaterialTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/MeshDescriptor.cc b/src/MeshDescriptor.cc
index f1a9d0690..00a8ed905 100644
--- a/src/MeshDescriptor.cc
+++ b/src/MeshDescriptor.cc
@@ -15,13 +15,13 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
 
-#include "ignition/rendering/MeshDescriptor.hh"
+#include "gz/rendering/MeshDescriptor.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -53,12 +53,12 @@ void MeshDescriptor::Load()
     this->mesh = common::MeshManager::Instance()->MeshByName(this->meshName);
     if (!this->mesh)
     {
-      ignerr << "Mesh manager can't find mesh named [" << this->meshName << "]"
+      gzerr << "Mesh manager can't find mesh named [" << this->meshName << "]"
              << std::endl;
     }
   }
   else
   {
-    ignerr << "Missing mesh or mesh name" << std::endl;
+    gzerr << "Missing mesh or mesh name" << std::endl;
   }
 }
diff --git a/src/MeshDescriptor_TEST.cc b/src/MeshDescriptor_TEST.cc
index 5d0bf9e01..c32bb0032 100644
--- a/src/MeshDescriptor_TEST.cc
+++ b/src/MeshDescriptor_TEST.cc
@@ -18,18 +18,18 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/MeshManager.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/MeshManager.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/MeshDescriptor.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/MeshDescriptor.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class MeshDescriptorTest : public testing::Test,
@@ -45,7 +45,7 @@ void MeshDescriptorTest::Descriptor(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -95,7 +95,7 @@ TEST_P(MeshDescriptorTest, Descriptor)
 
 INSTANTIATE_TEST_CASE_P(MeshDescriptor, MeshDescriptorTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Mesh_TEST.cc b/src/Mesh_TEST.cc
index 6a148bb78..f2ab11cf0 100644
--- a/src/Mesh_TEST.cc
+++ b/src/Mesh_TEST.cc
@@ -19,19 +19,19 @@
 #include <memory>
 #include <string>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/MeshManager.hh>
-#include <ignition/common/Skeleton.hh>
-#include <ignition/common/SkeletonAnimation.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/MeshManager.hh>
+#include <gz/common/Skeleton.hh>
+#include <gz/common/SkeletonAnimation.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/Mesh.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/Mesh.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class MeshTest : public testing::Test,
@@ -57,7 +57,7 @@ void MeshTest::MeshSubMesh(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -116,7 +116,7 @@ void MeshTest::MeshSkeletonAnimation(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -212,7 +212,7 @@ void MeshTest::MeshClone(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -273,7 +273,7 @@ void MeshTest::MeshClone(const std::string &_renderEngine)
   {
     // since the "top level mesh" has a material, the submesh materials are not
     // unique copies:
-    // https://github.com/ignitionrobotics/ign-rendering/blob/8f961d0c4cc755b6a2ca217d5a73de268ef95514/include/ignition/rendering/base/BaseMesh.hh#L293
+    // https://github.com/gazebosim/gz-rendering/blob/8f961d0c4cc755b6a2ca217d5a73de268ef95514/include/ignition/rendering/base/BaseMesh.hh#L293
     auto clonedSubMesh = clonedMesh->SubMeshByIndex(i);
     auto originalSubMesh = clonedMesh->SubMeshByIndex(i);
     compareMaterials(clonedSubMesh->Material(), originalSubMesh->Material(),
@@ -293,7 +293,7 @@ TEST_P(MeshTest, MeshClone)
 
 INSTANTIATE_TEST_CASE_P(Mesh, MeshTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/MoveToHelper.cc b/src/MoveToHelper.cc
index e0ca641fe..15b301208 100644
--- a/src/MoveToHelper.cc
+++ b/src/MoveToHelper.cc
@@ -15,17 +15,17 @@
  *
  */
 
-#include "ignition/rendering/MoveToHelper.hh"
+#include "gz/rendering/MoveToHelper.hh"
 
 #include <memory>
 
-#include <ignition/common/Animation.hh>
-#include <ignition/common/KeyFrame.hh>
-#include <ignition/math/Pose3.hh>
+#include <gz/common/Animation.hh>
+#include <gz/common/KeyFrame.hh>
+#include <gz/math/Pose3.hh>
 
-#include "ignition/rendering/Camera.hh"
+#include "gz/rendering/Camera.hh"
 
-class ignition::rendering::MoveToHelperPrivate
+class gz::rendering::MoveToHelperPrivate
 {
   /// \brief Pose animation object
   public: std::unique_ptr<common::PoseAnimation> poseAnim;
@@ -40,7 +40,7 @@ class ignition::rendering::MoveToHelperPrivate
   public: math::Pose3d initCameraPose;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 ////////////////////////////////////////////////
@@ -54,7 +54,7 @@ MoveToHelper::~MoveToHelper() = default;
 
 ////////////////////////////////////////////////
 void MoveToHelper::MoveTo(const rendering::CameraPtr &_camera,
-    const ignition::math::Pose3d &_target,
+    const gz::math::Pose3d &_target,
     double _duration, std::function<void()> _onAnimationComplete)
 {
   this->dataPtr->camera = _camera;
@@ -146,7 +146,7 @@ void MoveToHelper::LookDirection(const rendering::CameraPtr &_camera,
 
   // Calculate camera orientation
   math::Quaterniond endRot =
-    ignition::math::Matrix4d::LookAt(endPos, _lookAt).Rotation();
+    gz::math::Matrix4d::LookAt(endPos, _lookAt).Rotation();
 
   // Move camera to that pose
   common::PoseKeyFrame *key = this->dataPtr->poseAnim->CreateKeyFrame(0);
diff --git a/src/MoveToHelper_TEST.cc b/src/MoveToHelper_TEST.cc
index c07f3c619..e44303ac8 100644
--- a/src/MoveToHelper_TEST.cc
+++ b/src/MoveToHelper_TEST.cc
@@ -18,16 +18,16 @@
 
 #include <chrono>
 
-#include <ignition/rendering/MoveToHelper.hh>
-#include <ignition/common/Console.hh>
+#include <gz/rendering/MoveToHelper.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class MoveToHelperTest : public testing::Test,
@@ -77,7 +77,7 @@ void MoveToHelperTest::MoveTo(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -148,7 +148,7 @@ TEST_P(MoveToHelperTest, MoveToHelper)
 
 INSTANTIATE_TEST_CASE_P(MoveToHelper, MoveToHelperTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Node_TEST.cc b/src/Node_TEST.cc
index f8f913b82..6bb18671b 100644
--- a/src/Node_TEST.cc
+++ b/src/Node_TEST.cc
@@ -18,17 +18,17 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Node.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/Node.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Visual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class NodeTest : public testing::Test,
@@ -44,7 +44,7 @@ void NodeTest::Pose(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -132,7 +132,7 @@ TEST_P(NodeTest, Pose)
 
 INSTANTIATE_TEST_CASE_P(Node, NodeTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/OrbitViewController.cc b/src/OrbitViewController.cc
index d7bd50b65..62a23789e 100644
--- a/src/OrbitViewController.cc
+++ b/src/OrbitViewController.cc
@@ -15,13 +15,13 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/OrbitViewController.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/OrbitViewController.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Visual.hh"
 
-class ignition::rendering::OrbitViewControllerPrivate
+class gz::rendering::OrbitViewControllerPrivate
 {
   /// \brief Pointer to camera
   public: CameraPtr camera;
@@ -38,7 +38,7 @@ class ignition::rendering::OrbitViewControllerPrivate
   public: double NormalizePitch(double _pitch);
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 static const float PITCH_LIMIT_LOW = -static_cast<float>(IGN_PI)*0.5f + 0.001f;
@@ -94,7 +94,7 @@ void OrbitViewController::Zoom(const double _value)
 {
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera is NULL" << std::endl;
+    gzerr << "Camera is NULL" << std::endl;
     return;
   }
 
@@ -115,7 +115,7 @@ void OrbitViewController::Pan(const math::Vector2d &_value)
 {
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera is NULL" << std::endl;
+    gzerr << "Camera is NULL" << std::endl;
     return;
   }
 
@@ -128,7 +128,7 @@ void OrbitViewController::Pan(const math::Vector2d &_value)
   double vfov = 2.0f * atan(tan(hfov / 2.0f) /
         this->dataPtr->camera->AspectRatio());
 
-  ignition::math::Vector3d translation;
+  gz::math::Vector3d translation;
 
   double factor = 2.0;
 
@@ -150,7 +150,7 @@ void OrbitViewController::Orbit(const math::Vector2d &_value)
 {
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera is NULL" << std::endl;
+    gzerr << "Camera is NULL" << std::endl;
     return;
   }
 
diff --git a/src/OrbitViewController_TEST.cc b/src/OrbitViewController_TEST.cc
index 5be427c78..4174092dd 100644
--- a/src/OrbitViewController_TEST.cc
+++ b/src/OrbitViewController_TEST.cc
@@ -17,16 +17,16 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/OrbitViewController.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/OrbitViewController.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class OrbitViewControllerTest : public testing::Test,
@@ -45,7 +45,7 @@ void OrbitViewControllerTest::OrbitViewControl(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -89,7 +89,7 @@ void OrbitViewControllerTest::Control(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -237,7 +237,7 @@ TEST_P(OrbitViewControllerTest, Control)
 
 INSTANTIATE_TEST_CASE_P(OrbitViewController, OrbitViewControllerTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/OrthoViewController.cc b/src/OrthoViewController.cc
index 154862f47..ff1669800 100644
--- a/src/OrthoViewController.cc
+++ b/src/OrthoViewController.cc
@@ -15,15 +15,15 @@
  *
 */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/OrthoViewController.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/OrthoViewController.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Visual.hh"
 
 /// \internal
 /// \brief OrthoViewController private data.
-class ignition::rendering::OrthoViewControllerPrivate
+class gz::rendering::OrthoViewControllerPrivate
 {
   /// \brief Build a custom scaled orthographic projection matrix.
   /// \param[in] _left Left position
@@ -48,7 +48,7 @@ class ignition::rendering::OrthoViewControllerPrivate
   public: math::Vector3d target;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -116,7 +116,7 @@ void OrthoViewController::Zoom(double _value)
   // Zoom by changing the orthographic window size
   // Translate back to mouse cursor position
 
-  ignition::math::Vector3d translation;
+  gz::math::Vector3d translation;
   int width = this->dataPtr->camera->ImageWidth();
   int height = this->dataPtr->camera->ImageHeight();
 
@@ -192,14 +192,14 @@ void OrthoViewController::Pan(const math::Vector2d &_value)
 {
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera is NULL" << std::endl;
+    gzerr << "Camera is NULL" << std::endl;
     return;
   }
 
   double viewportWidth = this->dataPtr->camera->ImageWidth();
   double viewportHeight = this->dataPtr->camera->ImageHeight();
 
-  ignition::math::Vector3d translation;
+  gz::math::Vector3d translation;
 
   double factor = 1.0;
 
@@ -224,7 +224,7 @@ void OrthoViewController::Orbit(const math::Vector2d &_value)
 {
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera is NULL" << std::endl;
+    gzerr << "Camera is NULL" << std::endl;
     return;
   }
 
diff --git a/src/OrthoViewController_TEST.cc b/src/OrthoViewController_TEST.cc
index a7b92596d..941b646a5 100644
--- a/src/OrthoViewController_TEST.cc
+++ b/src/OrthoViewController_TEST.cc
@@ -17,16 +17,16 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/OrthoViewController.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/OrthoViewController.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class OrthoViewControllerTest : public testing::Test,
@@ -45,7 +45,7 @@ void OrthoViewControllerTest::OrthoViewControl(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -88,7 +88,7 @@ void OrthoViewControllerTest::Control(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -240,7 +240,7 @@ TEST_P(OrthoViewControllerTest, Control)
 
 INSTANTIATE_TEST_CASE_P(OrthoViewController, OrthoViewControllerTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/ParticleEmitter_TEST.cc b/src/ParticleEmitter_TEST.cc
index 7b14c1ae0..e4649db39 100644
--- a/src/ParticleEmitter_TEST.cc
+++ b/src/ParticleEmitter_TEST.cc
@@ -18,17 +18,17 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
-#include <ignition/math/Color.hh>
+#include <gz/common/Console.hh>
+#include <gz/math/Color.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/ParticleEmitter.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/ParticleEmitter.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /// \brief The test fixture.
@@ -62,7 +62,7 @@ bool ParticleEmitterTest::SetUp(const std::string &_renderEngine)
   this->engine = rendering::engine(_renderEngine);
   if (!this->engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return false;
   }
 
@@ -78,7 +78,7 @@ void ParticleEmitterTest::CheckBasicAPI()
 
   // Default values.
   EmitterType    expectedEmitterType     = EmitterType::EM_POINT;
-  math::Vector3d expectedEmitterSize     = ignition::math::Vector3d::One;
+  math::Vector3d expectedEmitterSize     = gz::math::Vector3d::One;
   double         expectedRate            = 10.0;
   double         expectedDuration        = 0;
   bool           expectedEmitting        = false;
@@ -87,8 +87,8 @@ void ParticleEmitterTest::CheckBasicAPI()
   MaterialPtr    expectedMaterial        = nullptr;
   double         expectedMinVel          = 1;
   double         expectedMaxVel          = 1;
-  math::Color    expectedColorStart      = ignition::math::Color::White;
-  math::Color    expectedColorEnd        = ignition::math::Color::White;
+  math::Color    expectedColorStart      = gz::math::Color::White;
+  math::Color    expectedColorEnd        = gz::math::Color::White;
   double         expectedScaleRate       = 1;
   std::string    expectedColorRangeImage = "";
   float          particleScatterRatio    = 0.65f;
@@ -122,8 +122,8 @@ void ParticleEmitterTest::CheckBasicAPI()
   expectedMaterial        = nullptr;
   expectedMinVel          = 2;
   expectedMaxVel          = 3;
-  expectedColorStart      = ignition::math::Color::Red;
-  expectedColorEnd        = ignition::math::Color::Blue;
+  expectedColorStart      = gz::math::Color::Red;
+  expectedColorEnd        = gz::math::Color::Blue;
   expectedScaleRate       = 10;
   expectedColorRangeImage = common::joinPaths(TEST_MEDIA_PATH, "texture.png");
   float expectedScatterRatio  = 0.24f;
@@ -185,7 +185,7 @@ TEST_P(ParticleEmitterTest, ParticleEmitter)
 
 INSTANTIATE_TEST_CASE_P(ParticleEmitter, ParticleEmitterTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/PixelFormat.cc b/src/PixelFormat.cc
index 9fc1f0829..bd0ea411b 100644
--- a/src/PixelFormat.cc
+++ b/src/PixelFormat.cc
@@ -15,11 +15,11 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/PixelFormat.hh"
+#include "gz/rendering/PixelFormat.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -114,7 +114,7 @@ PixelFormat PixelUtil::Sanitize(PixelFormat _format)
   // check if value within enum bounds
   if (!PixelUtil::IsValid(_format))
   {
-    ignerr << "Invalid PixelFormat value: " << _format << std::endl;
+    gzerr << "Invalid PixelFormat value: " << _format << std::endl;
     return PF_UNKNOWN;
   }
 
diff --git a/src/PixelFormat_TEST.cc b/src/PixelFormat_TEST.cc
index 622bf442e..664732358 100644
--- a/src/PixelFormat_TEST.cc
+++ b/src/PixelFormat_TEST.cc
@@ -19,9 +19,9 @@
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/PixelFormat.hh"
+#include "gz/rendering/PixelFormat.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /////////////////////////////////////////////////
diff --git a/src/RayQuery_TEST.cc b/src/RayQuery_TEST.cc
index 8c03b0f7c..8ed6b7dde 100644
--- a/src/RayQuery_TEST.cc
+++ b/src/RayQuery_TEST.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/RayQuery.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/RayQuery.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class RayQueryTest : public testing::Test,
@@ -42,7 +42,7 @@ void RayQueryTest::RayQuery(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "RayQuery not supported yet in rendering engine: "
+    gzdbg << "RayQuery not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -51,7 +51,7 @@ void RayQueryTest::RayQuery(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -113,7 +113,7 @@ TEST_P(RayQueryTest, RayQuery)
 
 INSTANTIATE_TEST_CASE_P(RayQuery, RayQueryTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/RenderEngineManager.cc b/src/RenderEngineManager.cc
index 6baf15999..d255d184a 100644
--- a/src/RenderEngineManager.cc
+++ b/src/RenderEngineManager.cc
@@ -18,15 +18,15 @@
 #include <map>
 #include <mutex>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/SystemPaths.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/SystemPaths.hh>
 
-#include <ignition/plugin/Loader.hh>
+#include <gz/plugin/Loader.hh>
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderEngineManager.hh"
-#include "ignition/rendering/RenderEnginePlugin.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderEngineManager.hh"
+#include "gz/rendering/RenderEnginePlugin.hh"
 
 /// \brief Holds information about an engine
 struct EngineInfo
@@ -36,11 +36,11 @@ struct EngineInfo
   std::string name;
 
   /// \brief The pointer to the render engine.
-  ignition::rendering::RenderEngine *engine;
+  gz::rendering::RenderEngine *engine;
 };
 
 /// \brief Private implementation of the RenderEngineManager class.
-class ignition::rendering::RenderEngineManagerPrivate
+class gz::rendering::RenderEngineManagerPrivate
 {
   /// \brief EngineMap that maps engine name to an engine pointer.
   typedef std::map<std::string, RenderEngine *> EngineMap;
@@ -93,10 +93,14 @@ class ignition::rendering::RenderEngineManagerPrivate
   public: std::map<std::string, std::string> enginePlugins;
 
   /// \brief Plugin loader for managing render engine plugin libraries.
-  public: ignition::plugin::Loader pluginLoader;
+  public: gz::plugin::Loader pluginLoader;
+
+  /// \brief Deprecated environment variable which holds paths to look for
+  /// plugins
+  public: std::string pluginPathEnvDeprecated = "IGN_RENDERING_PLUGIN_PATH";
 
   /// \brief Environment variable which holds paths to look for plugins
-  public: std::string pluginPathEnv = "IGN_RENDERING_PLUGIN_PATH";
+  public: std::string pluginPathEnv = "GZ_RENDERING_PLUGIN_PATH";
 
   /// \brief List which holds paths to look for engine plugins.
   public: std::list<std::string> pluginPaths;
@@ -105,7 +109,7 @@ class ignition::rendering::RenderEngineManagerPrivate
   public: std::recursive_mutex enginesMutex;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -224,7 +228,7 @@ RenderEngine *RenderEngineManager::EngineAt(unsigned int _index,
 {
   if (_index >= this->EngineCount())
   {
-    ignerr << "Invalid render-engine index: " << _index << std::endl;
+    gzerr << "Invalid render-engine index: " << _index << std::endl;
     return nullptr;
   }
 
@@ -251,7 +255,7 @@ bool RenderEngineManager::UnloadEngine(const std::string &_name)
 
     if (iter == this->dataPtr->engines.end())
     {
-      ignerr << "No render-engine registered with name: " << _name << std::endl;
+      gzerr << "No render-engine registered with name: " << _name << std::endl;
       return false;
     }
   }
@@ -264,7 +268,7 @@ bool RenderEngineManager::UnloadEngineAt(unsigned int _index)
 {
   if (_index >= this->EngineCount())
   {
-    ignerr << "Invalid render-engine index: " << _index << std::endl;
+    gzerr << "Invalid render-engine index: " << _index << std::endl;
     return false;
   }
 
@@ -280,13 +284,13 @@ void RenderEngineManager::RegisterEngine(const std::string &_name,
 {
   if (!_engine)
   {
-    ignerr << "Render-engine cannot be null" << std::endl;
+    gzerr << "Render-engine cannot be null" << std::endl;
     return;
   }
 
   if (this->HasEngine(_name))
   {
-    ignerr << "Render-engine already registered with name: "
+    gzerr << "Render-engine already registered with name: "
           << _name << std::endl;
 
     return;
@@ -333,7 +337,7 @@ void RenderEngineManager::UnregisterEngineAt(unsigned int _index)
 {
   if (_index >= this->EngineCount())
   {
-    ignerr << "Invalid render-engine index: " << _index << std::endl;
+    gzerr << "Invalid render-engine index: " << _index << std::endl;
     return;
   }
 
@@ -439,14 +443,14 @@ void RenderEngineManagerPrivate::RegisterDefaultEngines()
 bool RenderEngineManagerPrivate::LoadEnginePlugin(
     const std::string &_filename, const std::string &_path)
 {
-  ignmsg << "Loading plugin [" << _filename << "]" << std::endl;
+  gzmsg << "Loading plugin [" << _filename << "]" << std::endl;
 
-  ignition::common::SystemPaths systemPaths;
+  gz::common::SystemPaths systemPaths;
   systemPaths.SetPluginPathEnv(this->pluginPathEnv);
 
   // Add default install folder.
-  systemPaths.AddPluginPaths(std::string(IGN_RENDERING_PLUGIN_PATH));
-  systemPaths.AddPluginPaths({IGNITION_RENDERING_ENGINE_INSTALL_DIR});
+  systemPaths.AddPluginPaths(std::string(GZ_RENDERING_PLUGIN_PATH));
+  systemPaths.AddPluginPaths({GZ_RENDERING_ENGINE_INSTALL_DIR});
 
   // Add any preset plugin paths.
   for (const auto &path : this->pluginPaths)
@@ -458,23 +462,37 @@ bool RenderEngineManagerPrivate::LoadEnginePlugin(
   auto pathToLib = systemPaths.FindSharedLibrary(_filename);
   if (pathToLib.empty())
   {
-    ignerr << "Failed to load plugin [" << _filename <<
-              "] : couldn't find shared library." << std::endl;
-    return false;
+    // Try deprecated environment variable
+    common::SystemPaths systemPathsDep;
+    systemPathsDep.SetPluginPathEnv(this->pluginPathEnvDeprecated);
+    pathToLib = systemPathsDep.FindSharedLibrary(_filename);
+    if (pathToLib.empty())
+    {
+      gzerr << "Failed to load plugin [" << _filename <<
+               "] : couldn't find shared library." << std::endl;
+      return false;
+    }
+    else
+    {
+      gzwarn << "Found plugin [" << _filename
+             << "] using deprecated environment variable ["
+             << this->pluginPathEnvDeprecated << "]. Please use ["
+             << this->pluginPathEnv << "] instead." << std::endl;
+    }
   }
 
   // Load plugin
   auto pluginNames = this->pluginLoader.LoadLib(pathToLib);
   if (pluginNames.empty())
   {
-    ignerr << "Failed to load plugin [" << _filename <<
+    gzerr << "Failed to load plugin [" << _filename <<
               "] : couldn't load library on path [" << pathToLib <<
               "]." << std::endl;
     return false;
   }
 
   auto engineNames = pluginLoader.PluginsImplementing<
-      ignition::rendering::RenderEnginePlugin>();
+      gz::rendering::RenderEnginePlugin>();
 
   if (engineNames.empty())
   {
@@ -486,7 +504,7 @@ bool RenderEngineManagerPrivate::LoadEnginePlugin(
     {
       error << "- " << pluginName << std::endl;
     }
-    ignerr << error.str();
+    gzerr << error.str();
     return false;
   }
 
@@ -502,23 +520,23 @@ bool RenderEngineManagerPrivate::LoadEnginePlugin(
       warn << "- " << pluginName << std::endl;
     }
     warn << "Loading [" << engineName << "]." << std::endl;
-    ignwarn << warn.str();
+    gzwarn << warn.str();
   }
 
   auto plugin = pluginLoader.Instantiate(engineName);
   if (!plugin)
   {
-    ignerr << "Failed to instantiate plugin [" << engineName << "]"
+    gzerr << "Failed to instantiate plugin [" << engineName << "]"
            << std::endl;
     return false;
   }
 
   auto renderPlugin =
-      plugin->QueryInterface<ignition::rendering::RenderEnginePlugin>();
+      plugin->QueryInterface<gz::rendering::RenderEnginePlugin>();
 
   if (!renderPlugin)
   {
-    ignerr << "Failed to query interface from [" << engineName << "]"
+    gzerr << "Failed to query interface from [" << engineName << "]"
            << std::endl;
     return false;
   }
@@ -542,7 +560,7 @@ bool RenderEngineManagerPrivate::UnloadEnginePlugin(
   auto it = this->enginePlugins.find(_engineName);
   if (it == this->enginePlugins.end())
   {
-    ignmsg << "Skip unloading engine plugin. [" << _engineName << "] "
+    gzmsg << "Skip unloading engine plugin. [" << _engineName << "] "
            << "not loaded from plugin." << std::endl;
     return false;
   }
@@ -555,7 +573,7 @@ bool RenderEngineManagerPrivate::UnloadEnginePlugin(
   // see issue #45
   if (!this->pluginLoader.ForgetLibraryOfPlugin(pluginName))
   {
-    ignerr << "Failed to unload plugin: " << pluginName << std::endl;
+    gzerr << "Failed to unload plugin: " << pluginName << std::endl;
   }
 #endif
 
diff --git a/src/RenderEnginePlugin.cc b/src/RenderEnginePlugin.cc
index e14d7aa06..7f89fa2b5 100644
--- a/src/RenderEnginePlugin.cc
+++ b/src/RenderEnginePlugin.cc
@@ -15,13 +15,13 @@
  *
  */
 
-#include "ignition/rendering/RenderEnginePlugin.hh"
+#include "gz/rendering/RenderEnginePlugin.hh"
 
-class ignition::rendering::RenderEnginePluginPrivate
+class gz::rendering::RenderEnginePluginPrivate
 {
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/RenderEngine_TEST.cc b/src/RenderEngine_TEST.cc
index 64818c0af..19ffb2983 100644
--- a/src/RenderEngine_TEST.cc
+++ b/src/RenderEngine_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class RenderEngineTest : public testing::Test,
@@ -41,7 +41,7 @@ void RenderEngineTest::RenderEngine(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -141,7 +141,7 @@ TEST_P(RenderEngineTest, RenderEngine)
 
 INSTANTIATE_TEST_CASE_P(RenderEngine, RenderEngineTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/RenderPassSystem.cc b/src/RenderPassSystem.cc
index 5d4116d39..9f60a5dc1 100644
--- a/src/RenderPassSystem.cc
+++ b/src/RenderPassSystem.cc
@@ -15,15 +15,15 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/RenderPassSystem.hh"
+#include "gz/rendering/RenderPassSystem.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /// \brief Private implementation of the RenderPassSystem class
-class ignition::rendering::RenderPassSystemPrivate
+class gz::rendering::RenderPassSystemPrivate
 {
 };
 
@@ -53,7 +53,7 @@ RenderPassPtr RenderPassSystem::CreateImpl(const std::string &_type)
   }
   else
   {
-    ignerr << "RenderPass of typeid '" << _type << "' is not registered"
+    gzerr << "RenderPass of typeid '" << _type << "' is not registered"
            << std::endl;
   }
   return pass;
diff --git a/src/RenderPassSystem_TEST.cc b/src/RenderPassSystem_TEST.cc
index 87d11a078..b860f2133 100644
--- a/src/RenderPassSystem_TEST.cc
+++ b/src/RenderPassSystem_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/GaussianNoisePass.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/RenderPassSystem.hh"
+#include "gz/rendering/GaussianNoisePass.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/RenderPassSystem.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class RenderPassSystemTest : public testing::Test,
@@ -42,7 +42,7 @@ void RenderPassSystemTest::RenderPassSystem(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -51,7 +51,7 @@ void RenderPassSystemTest::RenderPassSystem(const std::string &_renderEngine)
   RenderPassSystemPtr rpSystem = engine->RenderPassSystem();
   if (!rpSystem)
   {
-    ignwarn << "Render engin '" << _renderEngine << "' does not support "
+    gzwarn << "Render engin '" << _renderEngine << "' does not support "
             << "render pass system" << std::endl;
     return;
   }
@@ -80,7 +80,7 @@ TEST_P(RenderPassSystemTest, RenderPassSystem)
 
 INSTANTIATE_TEST_CASE_P(GaussianNoise, RenderPassSystemTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/RenderTarget_TEST.cc b/src/RenderTarget_TEST.cc
index a314583ad..5f318d8a5 100644
--- a/src/RenderTarget_TEST.cc
+++ b/src/RenderTarget_TEST.cc
@@ -17,19 +17,19 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/GaussianNoisePass.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/RenderTarget.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/GaussianNoisePass.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/RenderTarget.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class RenderTargetTest : public testing::Test,
@@ -52,7 +52,7 @@ void RenderTargetTest::RenderTexture(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -83,7 +83,7 @@ void RenderTargetTest::RenderWindow(const std::string &_renderEngine)
 {
   if (_renderEngine != "ogre")
   {
-    igndbg << "RenderWindow not supported yet in rendering engine: "
+    gzdbg << "RenderWindow not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -92,7 +92,7 @@ void RenderTargetTest::RenderWindow(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -132,7 +132,7 @@ void RenderTargetTest::AddRemoveRenderPass(const std::string &_renderEngine)
 {
   if (_renderEngine != "ogre")
   {
-    igndbg << "RenderWindow not supported yet in rendering engine: "
+    gzdbg << "RenderWindow not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -141,7 +141,7 @@ void RenderTargetTest::AddRemoveRenderPass(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -155,7 +155,7 @@ void RenderTargetTest::AddRemoveRenderPass(const std::string &_renderEngine)
   RenderPassSystemPtr rpSystem = engine->RenderPassSystem();
   if (!rpSystem)
   {
-    ignwarn << "Render engin '" << _renderEngine << "' does not support "
+    gzwarn << "Render engin '" << _renderEngine << "' does not support "
             << "render pass system" << std::endl;
     return;
   }
@@ -205,7 +205,7 @@ TEST_P(RenderTargetTest, AddRemoveRenderPass)
 
 INSTANTIATE_TEST_CASE_P(RenderTarget, RenderTargetTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/RenderingIface.cc b/src/RenderingIface.cc
index b4b586670..249a0e9f1 100644
--- a/src/RenderingIface.cc
+++ b/src/RenderingIface.cc
@@ -15,18 +15,18 @@
  *
  */
 
-#include "ignition/common/Console.hh"
+#include "gz/common/Console.hh"
 
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/RenderEngineManager.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/RenderEngineManager.hh"
+#include "gz/rendering/Scene.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /*//////////////////////////////////////////////////
 bool load()
@@ -129,50 +129,50 @@ void setPluginPaths(const std::list<std::string> &_paths)
 //////////////////////////////////////////////////
 ScenePtr sceneFromFirstRenderEngine()
 {
-  auto loadedEngNames = ignition::rendering::loadedEngines();
+  auto loadedEngNames = gz::rendering::loadedEngines();
   if (loadedEngNames.empty())
   {
-    igndbg << "No rendering engine is loaded yet" << std::endl;
+    gzdbg << "No rendering engine is loaded yet" << std::endl;
     return nullptr;
   }
 
   auto engineName = loadedEngNames[0];
   if (loadedEngNames.size() > 1)
   {
-    ignwarn << "More than one engine is available. "
+    gzwarn << "More than one engine is available. "
       << "Using engine [" << engineName << "]" << std::endl;
   }
 
-  auto engine = ignition::rendering::engine(engineName);
+  auto engine = gz::rendering::engine(engineName);
   if (!engine)
   {
-    ignerr << "Internal error: failed to load engine [" << engineName
+    gzerr << "Internal error: failed to load engine [" << engineName
       << "]." << std::endl;
     return nullptr;
   }
 
   if (engine->SceneCount() == 0)
   {
-    igndbg << "No scene has been created yet" << std::endl;
+    gzdbg << "No scene has been created yet" << std::endl;
     return nullptr;
   }
 
   auto scene = engine->SceneByIndex(0);
   if (nullptr == scene)
   {
-    ignerr << "Internal error: scene is null." << std::endl;
+    gzerr << "Internal error: scene is null." << std::endl;
     return nullptr;
   }
 
   if (engine->SceneCount() > 1)
   {
-    ignwarn << "More than one scene is available. "
+    gzwarn << "More than one scene is available. "
       << "Using scene [" << scene->Name() << "]" << std::endl;
   }
 
   if (!scene->IsInitialized() || nullptr == scene->RootVisual())
   {
-    igndbg << "Scene is not initialized yet" << std::endl;
+    gzdbg << "Scene is not initialized yet" << std::endl;
     return nullptr;
   }
 
diff --git a/src/RenderingIface_TEST.cc b/src/RenderingIface_TEST.cc
index 85dd26eee..b90190266 100644
--- a/src/RenderingIface_TEST.cc
+++ b/src/RenderingIface_TEST.cc
@@ -19,13 +19,13 @@
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/config.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
+#include "gz/rendering/config.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 /////////////////////////////////////////////////
@@ -66,7 +66,7 @@ TEST(RenderingIfaceTest, GetEngine)
   for (unsigned int i = 0; i < count; ++i)
   {
     RenderEngine *eng = engine(i, std::map<std::string, std::string>(),
-        IGN_RENDERING_TEST_PLUGIN_PATH);
+        GZ_RENDERING_TEST_PLUGIN_PATH);
     ASSERT_NE(nullptr, eng);
     EXPECT_TRUE(isEngineLoaded(eng->Name()));
     EXPECT_TRUE(hasEngine(eng->Name()));
diff --git a/src/Scene_TEST.cc b/src/Scene_TEST.cc
index aa0b6e431..9f1ef6329 100644
--- a/src/Scene_TEST.cc
+++ b/src/Scene_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderTarget.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderTarget.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class SceneTest : public testing::Test,
@@ -34,7 +34,7 @@ class SceneTest : public testing::Test,
   // Documentation inherited
   public: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 
   public: void Scene(const std::string &_renderEngine);
@@ -69,7 +69,7 @@ void SceneTest::Scene(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -134,7 +134,7 @@ void SceneTest::Nodes(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -218,7 +218,7 @@ void SceneTest::RemoveNodes(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -320,7 +320,7 @@ void SceneTest::DestroyNodes(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -469,7 +469,7 @@ void SceneTest::NodeCycle(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -535,7 +535,7 @@ void SceneTest::Materials(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -665,7 +665,7 @@ void SceneTest::Time(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -703,7 +703,7 @@ void SceneTest::BackgroundMaterial(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -730,13 +730,13 @@ void SceneTest::Sky(const std::string &_renderEngine)
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
   if (_renderEngine != "ogre2")
   {
-    igndbg << "Sky not supported yet in rendering engine: "
+    gzdbg << "Sky not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -828,7 +828,7 @@ TEST_P(SceneTest, Sky)
 
 INSTANTIATE_TEST_CASE_P(Scene, SceneTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/SegmentationCamera_TEST.cc b/src/SegmentationCamera_TEST.cc
index 4926125a3..b2ffc62f8 100644
--- a/src/SegmentationCamera_TEST.cc
+++ b/src/SegmentationCamera_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/SegmentationCamera.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/SegmentationCamera.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class SegmentationCameraTest : public testing::Test,
@@ -42,7 +42,7 @@ void SegmentationCameraTest::SegmentationCamera(
   // Currently, only ogre2 supports segmentation cameras
   if (_renderEngine.compare("ogre2") != 0)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
               << "' doesn't support segmentation cameras" << std::endl;
     return;
   }
@@ -51,7 +51,7 @@ void SegmentationCameraTest::SegmentationCamera(
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
               << "' was unable to be retrieved" << std::endl;
     return;
   }
@@ -88,7 +88,7 @@ TEST_P(SegmentationCameraTest, SegmentationCamera)
 
 INSTANTIATE_TEST_CASE_P(SegmentationCamera, SegmentationCameraTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/ShaderParam.cc b/src/ShaderParam.cc
index 00f13a846..4e07e274b 100644
--- a/src/ShaderParam.cc
+++ b/src/ShaderParam.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include "ignition/rendering/ShaderParam.hh"
+#include "gz/rendering/ShaderParam.hh"
 
-using namespace ignition::rendering;
+using namespace gz::rendering;
 
 
-class ignition::rendering::ShaderParamPrivate
+class gz::rendering::ShaderParamPrivate
 {
   /// \brief Type of parameter held
   public: ShaderParam::ParamType type = ShaderParam::PARAM_NONE;
diff --git a/src/ShaderParam_TEST.cc b/src/ShaderParam_TEST.cc
index 3e91702bd..6b2181c4e 100644
--- a/src/ShaderParam_TEST.cc
+++ b/src/ShaderParam_TEST.cc
@@ -17,9 +17,9 @@
 #include <gtest/gtest.h>
 
 
-#include "ignition/rendering/ShaderParam.hh"
+#include "gz/rendering/ShaderParam.hh"
 
-using namespace ignition::rendering;
+using namespace gz::rendering;
 
 
 /////////////////////////////////////////////////
diff --git a/src/ShaderParams.cc b/src/ShaderParams.cc
index 3f59c08cb..336473a49 100644
--- a/src/ShaderParams.cc
+++ b/src/ShaderParams.cc
@@ -15,14 +15,14 @@
  *
  */
 
-#include "ignition/rendering/ShaderParams.hh"
+#include "gz/rendering/ShaderParams.hh"
 
 #include <unordered_map>
 
-using namespace ignition::rendering;
+using namespace gz::rendering;
 
 
-class ignition::rendering::ShaderParamsPrivate
+class gz::rendering::ShaderParamsPrivate
 {
   /// \brief collection of parameters
   public: std::unordered_map<std::string, ShaderParam> parameters;
@@ -32,7 +32,7 @@ class ignition::rendering::ShaderParamsPrivate
 };
 
 
-class ignition::rendering::ShaderParams::IteratorPrivate
+class gz::rendering::ShaderParams::IteratorPrivate
 {
   /// \brief Iterator from the map in ShaderParamsPrivate
   public: std::unordered_map<std::string, ShaderParam>::const_iterator iter;
diff --git a/src/ShaderParams_TEST.cc b/src/ShaderParams_TEST.cc
index 49a8eaa77..cc06e21d8 100644
--- a/src/ShaderParams_TEST.cc
+++ b/src/ShaderParams_TEST.cc
@@ -17,9 +17,9 @@
 #include <gtest/gtest.h>
 
 
-#include "ignition/rendering/ShaderParams.hh"
+#include "gz/rendering/ShaderParams.hh"
 
-using namespace ignition::rendering;
+using namespace gz::rendering;
 
 
 /////////////////////////////////////////////////
diff --git a/src/ShaderType.cc b/src/ShaderType.cc
index 5b175a3b3..fbb00d94a 100644
--- a/src/ShaderType.cc
+++ b/src/ShaderType.cc
@@ -15,11 +15,11 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/ShaderType.hh"
+#include "gz/rendering/ShaderType.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -44,7 +44,7 @@ ShaderType ShaderUtil::Sanitize(ShaderType _type)
   // check if value within enum bounds
   if (!ShaderUtil::IsValid(_type))
   {
-    ignerr << "Invalid ShaderType value: " << _type << std::endl;
+    gzerr << "Invalid ShaderType value: " << _type << std::endl;
     return ST_UNKNOWN;
   }
 
diff --git a/src/Text_TEST.cc b/src/Text_TEST.cc
index f09ed59bf..8c1e4d519 100644
--- a/src/Text_TEST.cc
+++ b/src/Text_TEST.cc
@@ -16,15 +16,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Text.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Text.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class TextTest : public testing::Test,
@@ -38,7 +38,7 @@ void TextTest::Text(const std::string &_renderEngine)
 {
   if (_renderEngine != "ogre")
   {
-    igndbg << "Text not supported yet in rendering engine: "
+    gzdbg << "Text not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -46,7 +46,7 @@ void TextTest::Text(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -122,7 +122,7 @@ TEST_P(TextTest, Text)
 
 INSTANTIATE_TEST_CASE_P(Text, TextTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/ThermalCamera_TEST.cc b/src/ThermalCamera_TEST.cc
index 86aa41c19..2c94826c5 100644
--- a/src/ThermalCamera_TEST.cc
+++ b/src/ThermalCamera_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/ThermalCamera.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/ThermalCamera.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class ThermalCameraTest : public testing::Test,
@@ -42,7 +42,7 @@ void ThermalCameraTest::ThermalCamera(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -85,7 +85,7 @@ TEST_P(ThermalCameraTest, ThermalCamera)
 
 INSTANTIATE_TEST_CASE_P(ThermalCamera, ThermalCameraTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/TransformController.cc b/src/TransformController.cc
index 81eab74f5..67969cf13 100644
--- a/src/TransformController.cc
+++ b/src/TransformController.cc
@@ -15,17 +15,17 @@
  *
  */
 
-#include <ignition/common/Console.hh>
-#include <ignition/math/Plane.hh>
+#include <gz/common/Console.hh>
+#include <gz/math/Plane.hh>
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/GizmoVisual.hh"
-#include "ignition/rendering/RayQuery.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/TransformController.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/GizmoVisual.hh"
+#include "gz/rendering/RayQuery.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/TransformController.hh"
 
 /// \brief Private data class for TransformController
-class ignition::rendering::TransformControllerPrivate
+class gz::rendering::TransformControllerPrivate
 {
   /// \brief Gizmo visual that provides translation, rotation, and scale
   /// tandles for transformation
@@ -48,21 +48,21 @@ class ignition::rendering::TransformControllerPrivate
   public: RayQueryPtr ray;
 
   /// \brief Current active axis of transformation
-  public: ignition::math::Vector3d axis;
+  public: gz::math::Vector3d axis;
 
   /// \brief Flag to indicate that transfomation is in progress.
   public: bool active = false;
 
   /// \brief Initial pose of the node being transformed.
   /// This is set in Start();
-  public: ignition::math::Pose3d nodeStartPose;
+  public: gz::math::Pose3d nodeStartPose;
 
   /// \brief Initial scale of the node being transformed.
   /// This is set in Start();
-  public: ignition::math::Vector3d nodeStartScale;
+  public: gz::math::Vector3d nodeStartScale;
 };
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -265,7 +265,7 @@ void TransformController::Translate(
 {
   if (!this->dataPtr->node)
   {
-    ignerr << "No node attached for transformation" << std::endl;
+    gzerr << "No node attached for transformation" << std::endl;
     return;
   }
 
@@ -306,13 +306,13 @@ math::Vector3d TransformController::TranslationFrom2d(
 {
   if (!this->dataPtr->node)
   {
-    ignerr << "No node attached" << std::endl;
+    gzerr << "No node attached" << std::endl;
     return math::Vector3d::Zero;
   }
 
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera not set" << std::endl;
+    gzerr << "Camera not set" << std::endl;
     return math::Vector3d::Zero;
   }
 
@@ -386,13 +386,13 @@ math::Vector3d TransformController::ScaleFrom2d(
 {
   if (!this->dataPtr->node)
   {
-    ignerr << "No node attached" << std::endl;
+    gzerr << "No node attached" << std::endl;
     return math::Vector3d::Zero;
   }
 
   if (!this->dataPtr->camera)
   {
-    ignerr << "Camera not set" << std::endl;
+    gzerr << "Camera not set" << std::endl;
     return math::Vector3d::Zero;
   }
 
@@ -451,8 +451,8 @@ math::Planed TransformController::CreatePlaneForTransform(
   }
   else
   {
-    ignition::math::Vector3d projNorm(0, 0, 0);
-    ignition::math::Vector3d planeNormOther(0, 0, 0);
+    gz::math::Vector3d projNorm(0, 0, 0);
+    gz::math::Vector3d planeNormOther(0, 0, 0);
 
     if (_axis.X() > 0 && _axis.Y() > 0)
     {
@@ -530,7 +530,7 @@ void TransformController::Rotate(const math::Quaterniond &_rotation, bool _snap)
 {
   if (!this->dataPtr->node)
   {
-    ignerr << "No node attached for transformation" << std::endl;
+    gzerr << "No node attached for transformation" << std::endl;
     return;
   }
 
@@ -564,7 +564,7 @@ void TransformController::Scale(const math::Vector3d &_scale, bool _snap)
 {
   if (!this->dataPtr->node)
   {
-    ignerr << "No node attached for transformation" << std::endl;
+    gzerr << "No node attached for transformation" << std::endl;
     return;
   }
 
@@ -591,24 +591,24 @@ void TransformController::Scale(const math::Vector3d &_scale, bool _snap)
 }
 
 /////////////////////////////////////////////////
-ignition::math::Vector3d TransformController::SnapPoint(
-    const ignition::math::Vector3d &_point,
+gz::math::Vector3d TransformController::SnapPoint(
+    const gz::math::Vector3d &_point,
     double _interval, double _sensitivity)
 {
   if (_interval < 0)
   {
-    ignerr << "Interval distance must be greater than or equal to 0"
+    gzerr << "Interval distance must be greater than or equal to 0"
         << std::endl;
-    return ignition::math::Vector3d::Zero;
+    return gz::math::Vector3d::Zero;
   }
 
   if (_sensitivity < 0 || _sensitivity > 1.0)
   {
-    ignerr << "Sensitivity must be between 0 and 1" << std::endl;
-    return ignition::math::Vector3d::Zero;
+    gzerr << "Sensitivity must be between 0 and 1" << std::endl;
+    return gz::math::Vector3d::Zero;
   }
 
-  ignition::math::Vector3d point = _point;
+  gz::math::Vector3d point = _point;
   double snap = _interval * _sensitivity;
 
   double remainder = fmod(point.X(), _interval);
diff --git a/src/TransformController_TEST.cc b/src/TransformController_TEST.cc
index 607c6eec7..2750b9db4 100644
--- a/src/TransformController_TEST.cc
+++ b/src/TransformController_TEST.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/TransformController.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/TransformController.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class TransformControllerTest : public testing::Test,
@@ -52,7 +52,7 @@ void TransformControllerTest::TransformControl(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -139,7 +139,7 @@ void TransformControllerTest::WorldSpace(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -202,7 +202,7 @@ void TransformControllerTest::LocalSpace(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -271,7 +271,7 @@ void TransformControllerTest::Control2d(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -369,7 +369,7 @@ TEST_P(TransformControllerTest, Control2d)
 
 INSTANTIATE_TEST_CASE_P(TransformController, TransformControllerTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Utils.cc b/src/Utils.cc
index 394e7ab71..3e91ef3c9 100644
--- a/src/Utils.cc
+++ b/src/Utils.cc
@@ -20,19 +20,19 @@
 #include <X11/Xresource.h>
 #endif
 
-#include "ignition/math/Plane.hh"
-#include "ignition/math/Vector2.hh"
-#include "ignition/math/Vector3.hh"
+#include "gz/math/Plane.hh"
+#include "gz/math/Vector2.hh"
+#include "gz/math/Vector3.hh"
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/RayQuery.hh"
-#include "ignition/rendering/Utils.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/RayQuery.hh"
+#include "gz/rendering/Utils.hh"
 
-namespace ignition
+namespace gz
 {
 namespace rendering
 {
-inline namespace IGNITION_RENDERING_VERSION_NAMESPACE {
+inline namespace GZ_RENDERING_VERSION_NAMESPACE {
 //
 /////////////////////////////////////////////////
 math::Vector3d screenToScene(
@@ -91,7 +91,7 @@ math::Vector3d screenToPlane(
   _rayQuery->SetFromCamera(
       _camera, math::Vector2d(nx, ny));
 
-  ignition::math::Planed plane(ignition::math::Vector3d(0, 0, 1), offset);
+  gz::math::Planed plane(gz::math::Vector3d(0, 0, 1), offset);
 
   math::Vector3d origin = _rayQuery->Origin();
   math::Vector3d direction = _rayQuery->Direction();
@@ -106,7 +106,7 @@ float screenScalingFactor()
   float ratio = 1.0;
 
   // the scaling factor seems to cause issues with mouse picking.
-  // see https://github.com/ignitionrobotics/ign-gazebo/issues/147
+  // see https://github.com/gazebosim/gz-sim/issues/147
 #if 0
   auto closeDisplay = [](Display * display)
   {
@@ -164,37 +164,37 @@ float screenScalingFactor()
 }
 
 /////////////////////////////////////////////////
-ignition::math::AxisAlignedBox transformAxisAlignedBox(
-    const ignition::math::AxisAlignedBox &_bbox,
-    const ignition::math::Pose3d &_pose)
+gz::math::AxisAlignedBox transformAxisAlignedBox(
+    const gz::math::AxisAlignedBox &_bbox,
+    const gz::math::Pose3d &_pose)
 {
   auto center = _bbox.Center();
 
   // Get the 8 corners of the bounding box.
-  std::vector<ignition::math::Vector3d> vertices;
-  vertices.push_back(center + ignition::math::Vector3d(-_bbox.XLength()/2.0,
+  std::vector<gz::math::Vector3d> vertices;
+  vertices.push_back(center + gz::math::Vector3d(-_bbox.XLength()/2.0,
                                                        _bbox.YLength()/2.0,
                                                        _bbox.ZLength()/2.0));
-  vertices.push_back(center + ignition::math::Vector3d(_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(_bbox.XLength()/2.0,
                                                        _bbox.YLength()/2.0,
                                                        _bbox.ZLength()/2.0));
-  vertices.push_back(center + ignition::math::Vector3d(-_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(-_bbox.XLength()/2.0,
                                                        -_bbox.YLength()/2.0,
                                                        _bbox.ZLength()/2.0));
-  vertices.push_back(center + ignition::math::Vector3d(_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(_bbox.XLength()/2.0,
                                                        -_bbox.YLength()/2.0,
                                                        _bbox.ZLength()/2.0));
 
-  vertices.push_back(center + ignition::math::Vector3d(-_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(-_bbox.XLength()/2.0,
                                                        _bbox.YLength()/2.0,
                                                        -_bbox.ZLength()/2.0));
-  vertices.push_back(center + ignition::math::Vector3d(_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(_bbox.XLength()/2.0,
                                                        _bbox.YLength()/2.0,
                                                        -_bbox.ZLength()/2.0));
-  vertices.push_back(center + ignition::math::Vector3d(-_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(-_bbox.XLength()/2.0,
                                                        -_bbox.YLength()/2.0,
                                                        -_bbox.ZLength()/2.0));
-  vertices.push_back(center + ignition::math::Vector3d(_bbox.XLength()/2.0,
+  vertices.push_back(center + gz::math::Vector3d(_bbox.XLength()/2.0,
                                                        -_bbox.YLength()/2.0,
                                                        -_bbox.ZLength()/2.0));
 
@@ -206,8 +206,8 @@ ignition::math::AxisAlignedBox transformAxisAlignedBox(
     v = _pose.Rot() * v + _pose.Pos();
   }
 
-  ignition::math::Vector3d min = vertices[0];
-  ignition::math::Vector3d max = vertices[0];
+  gz::math::Vector3d min = vertices[0];
+  gz::math::Vector3d max = vertices[0];
 
   // find min / max of vertices
   for (unsigned int i = 1; i < vertices.size(); ++i)
@@ -227,7 +227,7 @@ ignition::math::AxisAlignedBox transformAxisAlignedBox(
     if (max.Z() < v.Z())
       max.Z() = v.Z();
   }
-  return ignition::math::AxisAlignedBox(min, max);
+  return gz::math::AxisAlignedBox(min, max);
 }
 }
 }
diff --git a/src/Utils_TEST.cc b/src/Utils_TEST.cc
index 1ab0973b2..d86fb53c4 100644
--- a/src/Utils_TEST.cc
+++ b/src/Utils_TEST.cc
@@ -15,19 +15,19 @@
 */
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/RayQuery.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Utils.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/RayQuery.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Utils.hh"
+#include "gz/rendering/Visual.hh"
 
 #include "test_config.h"  // NOLINT(build/include)
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class UtilTest : public testing::Test,
@@ -36,7 +36,7 @@ class UtilTest : public testing::Test,
   // Documentation inherited
   public: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 
   public: void ClickToScene(const std::string &_renderEngine);
@@ -47,7 +47,7 @@ void UtilTest::ClickToScene(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -66,7 +66,7 @@ void UtilTest::ClickToScene(const std::string &_renderEngine)
 
   const int halfWidth  = static_cast<int>(width / 2);
   const int halfHeight = static_cast<int>(height / 2);
-  ignition::math::Vector2i centerClick(halfWidth, halfHeight);
+  gz::math::Vector2i centerClick(halfWidth, halfHeight);
 
   RayQueryPtr rayQuery = scene->CreateRayQuery();
   EXPECT_TRUE(rayQuery != nullptr);
@@ -129,7 +129,7 @@ void UtilTest::ClickToScene(const std::string &_renderEngine)
   // the screenToPlane tests to fail so only modifying the pos here, and the
   // cause of test failure need to be investigated.
   if (_renderEngine == "ogre2")
-    centerClick = ignition::math::Vector2i(halfWidth-1, halfHeight-1);
+    centerClick = gz::math::Vector2i(halfWidth-1, halfHeight-1);
 
   // API without RayQueryResult and default max distance
   result = screenToScene(centerClick, camera, rayQuery, rayResult);
@@ -174,7 +174,7 @@ TEST_P(UtilTest, ClickToScene)
 
 INSTANTIATE_TEST_CASE_P(ClickToScene, UtilTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/Visual_TEST.cc b/src/Visual_TEST.cc
index 9552b3f86..9d99d2990 100644
--- a/src/Visual_TEST.cc
+++ b/src/Visual_TEST.cc
@@ -18,18 +18,18 @@
 #include <gtest/gtest.h>
 #include <string>
 
-#include <ignition/common/Console.hh>
-#include <ignition/math/AxisAlignedBox.hh>
+#include <gz/common/Console.hh>
+#include <gz/math/AxisAlignedBox.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Geometry.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/Visual.hh"
+#include "gz/rendering/Geometry.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/Visual.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class VisualTest : public testing::Test,
@@ -69,7 +69,7 @@ void VisualTest::Material(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -154,7 +154,7 @@ void VisualTest::Children(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -223,7 +223,7 @@ void VisualTest::Scale(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -314,7 +314,7 @@ void VisualTest::UserData(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -411,7 +411,7 @@ void VisualTest::UserData(const std::string &_renderEngine)
   EXPECT_THROW(
   {
     auto res = std::get<int>(value);
-    igndbg << res << std::endl;
+    gzdbg << res << std::endl;
   }, std::bad_variant_access);
 
   // Clean up
@@ -431,7 +431,7 @@ void VisualTest::Geometry(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -506,7 +506,7 @@ void VisualTest::VisibilityFlags(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -573,7 +573,7 @@ void VisualTest::BoundingBox(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -589,13 +589,13 @@ void VisualTest::BoundingBox(const std::string &_renderEngine)
   visual->AddGeometry(box);
   visual->SetWorldPosition(1.0, 2.0, 3.0);
 
-  ignition::math::AxisAlignedBox localBoundingBox = visual->LocalBoundingBox();
-  ignition::math::AxisAlignedBox boundingBox = visual->BoundingBox();
+  gz::math::AxisAlignedBox localBoundingBox = visual->LocalBoundingBox();
+  gz::math::AxisAlignedBox boundingBox = visual->BoundingBox();
 
-  EXPECT_EQ(ignition::math::Vector3d(-0.5, -0.5, -0.5), localBoundingBox.Min());
-  EXPECT_EQ(ignition::math::Vector3d(0.5, 0.5, 0.5), localBoundingBox.Max());
-  EXPECT_EQ(ignition::math::Vector3d(0.5, 1.5, 2.5), boundingBox.Min());
-  EXPECT_EQ(ignition::math::Vector3d(1.5, 2.5, 3.5), boundingBox.Max());
+  EXPECT_EQ(gz::math::Vector3d(-0.5, -0.5, -0.5), localBoundingBox.Min());
+  EXPECT_EQ(gz::math::Vector3d(0.5, 0.5, 0.5), localBoundingBox.Max());
+  EXPECT_EQ(gz::math::Vector3d(0.5, 1.5, 2.5), boundingBox.Min());
+  EXPECT_EQ(gz::math::Vector3d(1.5, 2.5, 3.5), boundingBox.Max());
 
   // Clean up
   engine->DestroyScene(scene);
@@ -614,7 +614,7 @@ void VisualTest::Wireframe(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported\n";
     return;
   }
@@ -643,7 +643,7 @@ void VisualTest::Clone(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -784,7 +784,7 @@ TEST_P(VisualTest, Clone)
 
 INSTANTIATE_TEST_CASE_P(Visual, VisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/WireBox.cc b/src/WireBox.cc
index a6a03c627..b6941c0c8 100644
--- a/src/WireBox.cc
+++ b/src/WireBox.cc
@@ -16,9 +16,9 @@
  */
 
 
-#include "ignition/rendering/WireBox.hh"
+#include "gz/rendering/WireBox.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/WireBox_TEST.cc b/src/WireBox_TEST.cc
index 5a053c14d..6fabb4fc8 100644
--- a/src/WireBox_TEST.cc
+++ b/src/WireBox_TEST.cc
@@ -17,15 +17,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/WireBox.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/WireBox.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class WireBoxTest : public testing::Test,
@@ -39,7 +39,7 @@ void WireBoxTest::WireBox(const std::string &_renderEngine)
 {
   if (_renderEngine != "ogre" && _renderEngine != "ogre2")
   {
-    igndbg << "WireBox not supported yet in rendering engine: "
+    gzdbg << "WireBox not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -47,7 +47,7 @@ void WireBoxTest::WireBox(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -56,11 +56,11 @@ void WireBoxTest::WireBox(const std::string &_renderEngine)
   WireBoxPtr wireBox = scene->CreateWireBox();
   ASSERT_NE(nullptr, wireBox);
 
-  ignition::math::AxisAlignedBox box(math::Vector3d(0.1, 0.2, 0.3),
+  gz::math::AxisAlignedBox box(math::Vector3d(0.1, 0.2, 0.3),
                                      math::Vector3d(5.1, 5.2, 5.3));
 
   wireBox->SetBox(box);
-  ignition::math::AxisAlignedBox aabb = wireBox->Box();
+  gz::math::AxisAlignedBox aabb = wireBox->Box();
   EXPECT_EQ(math::Vector3d(0.1, 0.2, 0.3), aabb.Min());
   EXPECT_EQ(math::Vector3d(5.1, 5.2, 5.3), aabb.Max());
 
@@ -90,7 +90,7 @@ TEST_P(WireBoxTest, WireBox)
 
 INSTANTIATE_TEST_CASE_P(WireBox, WireBoxTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/src/base/BaseObject.cc b/src/base/BaseObject.cc
index d27bcaa67..b00a5e987 100644
--- a/src/base/BaseObject.cc
+++ b/src/base/BaseObject.cc
@@ -14,9 +14,9 @@
  * limitations under the License.
  *
  */
-#include "ignition/rendering/base/BaseObject.hh"
+#include "gz/rendering/base/BaseObject.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
diff --git a/src/base/BaseRenderEngine.cc b/src/base/BaseRenderEngine.cc
index 0f61773b6..3d723093d 100644
--- a/src/base/BaseRenderEngine.cc
+++ b/src/base/BaseRenderEngine.cc
@@ -15,12 +15,12 @@
  *
  */
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/base/BaseRenderEngine.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/base/BaseRenderEngine.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -39,7 +39,7 @@ bool BaseRenderEngine::Load(const std::map<std::string, std::string> &_params)
 {
   if (this->loaded)
   {
-    ignwarn << "Render-engine has already been loaded" << std::endl;
+    gzwarn << "Render-engine has already been loaded" << std::endl;
     return true;
   }
 
@@ -52,13 +52,13 @@ bool BaseRenderEngine::Init()
 {
   if (!this->loaded)
   {
-    ignerr << "Render-engine must be loaded first" << std::endl;
+    gzerr << "Render-engine must be loaded first" << std::endl;
     return false;
   }
 
   if (this->initialized)
   {
-    ignwarn << "Render-engine has already been initialized" << std::endl;
+    gzwarn << "Render-engine has already been initialized" << std::endl;
     return true;
   }
 
@@ -212,19 +212,19 @@ ScenePtr BaseRenderEngine::CreateScene(unsigned int _id,
 {
   if (!this->IsInitialized())
   {
-    ignerr << "Render-engine has not been initialized" << std::endl;
+    gzerr << "Render-engine has not been initialized" << std::endl;
     return nullptr;
   }
 
   if (this->HasSceneId(_id))
   {
-    ignerr << "Scene already exists with id: " << _id << std::endl;
+    gzerr << "Scene already exists with id: " << _id << std::endl;
     return nullptr;
   }
 
   if (this->HasSceneName(_name))
   {
-    ignerr << "Scene already exists with id: " << _id << std::endl;
+    gzerr << "Scene already exists with id: " << _id << std::endl;
     return nullptr;
   }
 
@@ -280,7 +280,7 @@ RenderPassSystemPtr BaseRenderEngine::RenderPassSystem() const
 {
   if (!this->renderPassSystem)
   {
-    ignerr << "Render pass not supported by the requested render engine"
+    gzerr << "Render pass not supported by the requested render engine"
         << std::endl;
     return RenderPassSystemPtr();
   }
diff --git a/src/base/BaseScene.cc b/src/base/BaseScene.cc
index e79d4664a..036099c6d 100644
--- a/src/base/BaseScene.cc
+++ b/src/base/BaseScene.cc
@@ -17,38 +17,38 @@
 
 #include <sstream>
 
-#include <ignition/math/Helpers.hh>
-
-#include <ignition/common/Console.hh>
-#include <ignition/common/Mesh.hh>
-#include <ignition/common/MeshManager.hh>
-
-#include "ignition/rendering/ArrowVisual.hh"
-#include "ignition/rendering/AxisVisual.hh"
-#include "ignition/rendering/BoundingBoxCamera.hh"
-#include "ignition/rendering/COMVisual.hh"
-#include "ignition/rendering/InertiaVisual.hh"
-#include "ignition/rendering/JointVisual.hh"
-#include "ignition/rendering/LidarVisual.hh"
-#include "ignition/rendering/LightVisual.hh"
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/Capsule.hh"
-#include "ignition/rendering/DepthCamera.hh"
-#include "ignition/rendering/GizmoVisual.hh"
-#include "ignition/rendering/GpuRays.hh"
-#include "ignition/rendering/Grid.hh"
-#include "ignition/rendering/ParticleEmitter.hh"
-#include "ignition/rendering/RayQuery.hh"
-#include "ignition/rendering/RenderTarget.hh"
-#include "ignition/rendering/Text.hh"
-#include "ignition/rendering/ThermalCamera.hh"
-#include "ignition/rendering/SegmentationCamera.hh"
-#include "ignition/rendering/Visual.hh"
-#include "ignition/rendering/WideAngleCamera.hh"
-#include "ignition/rendering/base/BaseStorage.hh"
-#include "ignition/rendering/base/BaseScene.hh"
-
-using namespace ignition;
+#include <gz/math/Helpers.hh>
+
+#include <gz/common/Console.hh>
+#include <gz/common/Mesh.hh>
+#include <gz/common/MeshManager.hh>
+
+#include "gz/rendering/ArrowVisual.hh"
+#include "gz/rendering/AxisVisual.hh"
+#include "gz/rendering/BoundingBoxCamera.hh"
+#include "gz/rendering/COMVisual.hh"
+#include "gz/rendering/InertiaVisual.hh"
+#include "gz/rendering/JointVisual.hh"
+#include "gz/rendering/LidarVisual.hh"
+#include "gz/rendering/LightVisual.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/Capsule.hh"
+#include "gz/rendering/DepthCamera.hh"
+#include "gz/rendering/GizmoVisual.hh"
+#include "gz/rendering/GpuRays.hh"
+#include "gz/rendering/Grid.hh"
+#include "gz/rendering/ParticleEmitter.hh"
+#include "gz/rendering/RayQuery.hh"
+#include "gz/rendering/RenderTarget.hh"
+#include "gz/rendering/Text.hh"
+#include "gz/rendering/ThermalCamera.hh"
+#include "gz/rendering/SegmentationCamera.hh"
+#include "gz/rendering/Visual.hh"
+#include "gz/rendering/WideAngleCamera.hh"
+#include "gz/rendering/base/BaseStorage.hh"
+#include "gz/rendering/base/BaseScene.hh"
+
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -57,7 +57,7 @@ BaseScene::BaseScene(unsigned int _id, const std::string &_name) :
   name(_name),
   loaded(false),
   initialized(false),
-  nextObjectId(ignition::math::MAX_UI16),
+  nextObjectId(gz::math::MAX_UI16),
   nodes(nullptr)
 {
 }
@@ -81,7 +81,7 @@ void BaseScene::Init()
 {
   if (!this->loaded)
   {
-    ignerr << "Scene must be loaded first" << std::endl;
+    gzerr << "Scene must be loaded first" << std::endl;
     return;
   }
 
@@ -137,7 +137,7 @@ void BaseScene::SetTime(const std::chrono::steady_clock::duration &_time)
 
 //////////////////////////////////////////////////
 VisualPtr BaseScene::VisualAt(const CameraPtr &_camera,
-                              const ignition::math::Vector2i &_mousePos)
+                              const gz::math::Vector2i &_mousePos)
 {
   VisualPtr visual;
   RayQueryPtr rayQuery = this->CreateRayQuery();
@@ -292,7 +292,7 @@ void BaseScene::DestroyNodeRecursive(NodePtr _node,
   // check if we have visited this node before
   if (_nodeIds.find(_node->Id()) != _nodeIds.end())
   {
-    ignwarn << "Detected loop in scene tree while recursively destroying nodes."
+    gzwarn << "Detected loop in scene tree while recursively destroying nodes."
             << " Breaking loop." << std::endl;
     _node->RemoveParent();
     return;
@@ -1373,7 +1373,7 @@ void BaseScene::SetSkyEnabled(bool _enabled)  // NOLINT(readability/casting)
   // no op, let derived class implement this.
   if (_enabled)
   {
-    ignerr << "Sky not supported by: "
+    gzerr << "Sky not supported by: "
            << this->Engine()->Name() << std::endl;
   }
 }
@@ -1418,7 +1418,7 @@ void BaseScene::Clear()
 {
   this->nodes->DestroyAll();
   this->DestroyMaterials();
-  this->nextObjectId = ignition::math::MAX_UI16;
+  this->nextObjectId = gz::math::MAX_UI16;
 }
 
 //////////////////////////////////////////////////
@@ -1547,9 +1547,10 @@ void BaseScene::CreateMaterials()
   material->SetReceiveShadows(true);
   material->SetLightingEnabled(true);
 
-  const char *env = std::getenv("IGN_RENDERING_RESOURCE_PATH");
+  const char *env = std::getenv("GZ_RENDERING_RESOURCE_PATH");
+  env = (env) ? env : std::getenv("IGN_RENDERING_RESOURCE_PATH");
   std::string resourcePath = (env) ? std::string(env) :
-      IGN_RENDERING_RESOURCE_PATH;
+      GZ_RENDERING_RESOURCE_PATH;
 
   // path to look for CoM material texture
   std::string com_material_texture_path = common::joinPaths(
diff --git a/src/base/media/materials/textures/CMakeLists.txt b/src/base/media/materials/textures/CMakeLists.txt
index aec4532d5..5d9f3f249 100644
--- a/src/base/media/materials/textures/CMakeLists.txt
+++ b/src/base/media/materials/textures/CMakeLists.txt
@@ -1,4 +1,4 @@
 file(GLOB files "*.png")
 
-install(FILES ${files} DESTINATION ${IGN_RENDERING_RESOURCE_PATH}/media/materials/textures)
+install(FILES ${files} DESTINATION ${GZ_RENDERING_RESOURCE_PATH}/media/materials/textures)
 
diff --git a/test/integration/all_symbols_have_version.bash.in b/test/integration/all_symbols_have_version.bash.in
index 9be67a78c..f95072554 100644
--- a/test/integration/all_symbols_have_version.bash.in
+++ b/test/integration/all_symbols_have_version.bash.in
@@ -5,7 +5,7 @@ VERSIONED_NS=v@PROJECT_VERSION_MAJOR@
 IGN_PROJECT=@IGN_DESIGNATION@
 
 # Sanity check - there should be at least one symbol
-NUM_SYMBOLS=$(nm $LIBPATH | grep -e "ignition.*$IGN_PROJECT" | wc -l)
+NUM_SYMBOLS=$(nm $LIBPATH | grep -e "gz.*$IGN_PROJECT" | wc -l)
 
 if [ $NUM_SYMBOLS -eq 0 ]
 then
@@ -14,7 +14,7 @@ then
 fi
 
 # There must be no unversioned symbols
-UNVERSIONED_SYMBOLS=$(nm $LIBPATH | grep -e "ignition.*$IGN_PROJECT" | grep -e "$VERSIONED_NS" -v)
+UNVERSIONED_SYMBOLS=$(nm $LIBPATH | grep -e "gz.*$IGN_PROJECT" | grep -e "$VERSIONED_NS" -v)
 UNVERSIONED_SYMBOL_CHARS=$(printf "$UNVERSIONED_SYMBOLS" | wc -m)
 
 if [ $UNVERSIONED_SYMBOL_CHARS -ne 0 ]
diff --git a/test/integration/camera.cc b/test/integration/camera.cc
index 1ec37b8df..6eb4e6151 100644
--- a/test/integration/camera.cc
+++ b/test/integration/camera.cc
@@ -17,21 +17,21 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/GpuRays.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/SegmentationCamera.hh"
-#include "ignition/rendering/ShaderParams.hh"
-#include "ignition/rendering/ThermalCamera.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/GpuRays.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/SegmentationCamera.hh"
+#include "gz/rendering/ShaderParams.hh"
+#include "gz/rendering/ThermalCamera.hh"
 
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class CameraTest: public testing::Test,
@@ -40,7 +40,7 @@ class CameraTest: public testing::Test,
   // Documentation inherited
   public: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 
   // Test and verify camera tracking
@@ -60,7 +60,7 @@ class CameraTest: public testing::Test,
 
   // Path to test media directory
   public: const std::string TEST_MEDIA_PATH =
-          ignition::common::joinPaths(std::string(PROJECT_SOURCE_PATH),
+          gz::common::joinPaths(std::string(PROJECT_SOURCE_PATH),
                 "test", "media");
 };
 
@@ -71,7 +71,7 @@ void CameraTest::Track(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -201,7 +201,7 @@ void CameraTest::VisualAt(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "VisualAt not supported yet in rendering engine: "
+    gzdbg << "VisualAt not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -210,7 +210,7 @@ void CameraTest::VisualAt(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -330,7 +330,7 @@ void CameraTest::Follow(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -452,7 +452,7 @@ void CameraTest::Visibility(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -582,7 +582,7 @@ void CameraTest::ShaderSelection(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "Custom shaders are not supported yet in rendering engine: "
+    gzdbg << "Custom shaders are not supported yet in rendering engine: "
            << _renderEngine << std::endl;
     return;
   }
@@ -595,7 +595,7 @@ void CameraTest::ShaderSelection(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' is not supported" << std::endl;
     return;
   }
@@ -628,13 +628,13 @@ void CameraTest::ShaderSelection(const std::string &_renderEngine)
 
   // create shader materials
   // path to look for vertex and fragment shader parameters
-  std::string vertexShaderPath = ignition::common::joinPaths(
+  std::string vertexShaderPath = gz::common::joinPaths(
       TEST_MEDIA_PATH, "materials", "programs", vertexShaderFile);
-  std::string fragmentShaderPath = ignition::common::joinPaths(
+  std::string fragmentShaderPath = gz::common::joinPaths(
       TEST_MEDIA_PATH, "materials", "programs", fragmentShaderFile);
 
   // create shader material
-  ignition::rendering::MaterialPtr shader = scene->CreateMaterial();
+  gz::rendering::MaterialPtr shader = scene->CreateMaterial();
   shader->SetVertexShader(vertexShaderPath);
   shader->SetFragmentShader(fragmentShaderPath);
 
@@ -811,7 +811,7 @@ TEST_P(CameraTest, ShaderSelection)
 
 INSTANTIATE_TEST_CASE_P(Camera, CameraTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/deprecated_TEST.cc b/test/integration/deprecated_TEST.cc
new file mode 100644
index 000000000..226541f54
--- /dev/null
+++ b/test/integration/deprecated_TEST.cc
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2022 Open Source Robotics Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+*/
+
+#include <gtest/gtest.h>
+
+#define SUPPRESS_IGNITION_HEADER_DEPRECATION
+
+#include <ignition/rendering/Camera.hh>
+#include <ignition/utils/SuppressWarning.hh>
+
+/////////////////////////////////////////////////
+// Make sure the ignition namespace still works
+TEST(Deprecated, IgnitionNamespace)
+{
+  ignition::camera::Camera camera;
+}
+
+#undef SUPPRESS_IGNITION_HEADER_DEPRECATION
diff --git a/test/integration/depth_camera.cc b/test/integration/depth_camera.cc
index 189db783f..72595b636 100644
--- a/test/integration/depth_camera.cc
+++ b/test/integration/depth_camera.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Event.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Event.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/DepthCamera.hh"
-#include "ignition/rendering/ParticleEmitter.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/DepthCamera.hh"
+#include "gz/rendering/ParticleEmitter.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
 #define DEPTH_TOL 1e-4
 #define DOUBLE_TOL 1e-6
@@ -76,42 +76,42 @@ void DepthCameraTest::DepthCameraBoxes(
   double aspectRatio_ = imgWidth_/imgHeight_;
 
   double unitBoxSize = 1.0;
-  ignition::math::Vector3d boxPosition(1.8, 0.0, 0.0);
+  gz::math::Vector3d boxPosition(1.8, 0.0, 0.0);
 
   // Optix is not supported
   if (_renderEngine.compare("optix") == 0)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' doesn't support depth cameras" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
 
   // red background
   scene->SetBackgroundColor(1.0, 0.0, 0.0);
 
   // Create an scene with a box in it
   scene->SetAmbientLight(1.0, 1.0, 1.0);
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // create blue material
-  ignition::rendering::MaterialPtr blue = scene->CreateMaterial();
+  gz::rendering::MaterialPtr blue = scene->CreateMaterial();
   blue->SetAmbient(0.0, 0.0, 1.0);
   blue->SetDiffuse(0.0, 0.0, 1.0);
   blue->SetSpecular(0.0, 0.0, 1.0);
 
   // create box visual
-  ignition::rendering::VisualPtr box = scene->CreateVisual();
+  gz::rendering::VisualPtr box = scene->CreateVisual();
   box->AddGeometry(scene->CreateBox());
   box->SetOrigin(0.0, 0.0, 0.0);
   box->SetLocalPosition(boxPosition);
@@ -127,8 +127,8 @@ void DepthCameraTest::DepthCameraBoxes(
     auto depthCamera = scene->CreateDepthCamera("DepthCamera");
     ASSERT_NE(depthCamera, nullptr);
 
-    ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0),
-        ignition::math::Quaterniond::Identity);
+    gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0),
+        gz::math::Quaterniond::Identity);
     depthCamera->SetLocalPose(testPose);
 
     // Configure depth camera
@@ -152,7 +152,7 @@ void DepthCameraTest::DepthCameraBoxes(
 
     // Set a callback on the  camera sensor to get a depth camera frame
     float *scan = new float[imgHeight_ * imgWidth_];
-    ignition::common::ConnectionPtr connection =
+    gz::common::ConnectionPtr connection =
       depthCamera->ConnectNewDepthFrame(
           std::bind(&::OnNewDepthFrame, scan,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -162,7 +162,7 @@ void DepthCameraTest::DepthCameraBoxes(
     unsigned int pointCloudChannelCount = 4u;
     float *pointCloudData = new float[
         imgHeight_ * imgWidth_ * pointCloudChannelCount];
-    ignition::common::ConnectionPtr connection2 =
+    gz::common::ConnectionPtr connection2 =
       depthCamera->ConnectNewRgbPointCloud(
           std::bind(&::OnNewRgbPointCloud, pointCloudData,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -195,8 +195,8 @@ void DepthCameraTest::DepthCameraBoxes(
         * (depthCamera->ImageWidth() * pointCloudChannelCount)
         - pointCloudChannelCount;
 
-    float minVal = -ignition::math::INF_D;
-    float maxVal = ignition::math::INF_D;
+    float minVal = -gz::math::INF_D;
+    float maxVal = gz::math::INF_D;
 
     // Verify Depth
     // Depth sensor should see box in the middle of the image
@@ -256,7 +256,7 @@ void DepthCameraTest::DepthCameraBoxes(
       EXPECT_EQ(0u, mr);
       EXPECT_EQ(0u, mg);
 #ifndef __APPLE__
-      // https://github.com/ignitionrobotics/ign-rendering/issues/332
+      // https://github.com/gazebosim/gz-rendering/issues/332
       EXPECT_GT(mb, 0u);
 #endif
 
@@ -288,14 +288,14 @@ void DepthCameraTest::DepthCameraBoxes(
       // drivers are free to fill it with any value they want.
       // This should be fixed in ogre 2.2 in ign-rendering6 which forbids
       // the use of RGB format.
-      // see https://github.com/ignitionrobotics/ign-rendering/issues/315
+      // see https://github.com/gazebosim/gz-rendering/issues/315
       EXPECT_TRUE(255u == ma || 0u == ma);
       EXPECT_TRUE(255u == la || 0u == la);
       EXPECT_TRUE(255u == ra || 0u == ra);
     }
 
     // Check that for a box really close it returns it is not seen
-    ignition::math::Vector3d boxPositionNear(
+    gz::math::Vector3d boxPositionNear(
         unitBoxSize * 0.5 + nearDist * 0.5, 0.0, 0.0);
     box->SetLocalPosition(boxPositionNear);
 
@@ -352,7 +352,7 @@ void DepthCameraTest::DepthCameraBoxes(
     }
 
     // Check that for a box really far it returns max val
-    ignition::math::Vector3d boxPositionFar(
+    gz::math::Vector3d boxPositionFar(
         unitBoxSize * 0.5 + farDist * 1.5, 0.0, 0.0);
     box->SetLocalPosition(boxPositionFar);
 
@@ -411,7 +411,7 @@ void DepthCameraTest::DepthCameraBoxes(
     }
 
     // Check that the depth values for a box do not warp.
-    ignition::math::Vector3d boxPositionFillFrame(
+    gz::math::Vector3d boxPositionFillFrame(
         unitBoxSize * 0.5 + 0.2, 0.0, 0.0);
     box->SetLocalPosition(boxPositionFillFrame);
 
@@ -461,7 +461,7 @@ void DepthCameraTest::DepthCameraBoxes(
           EXPECT_EQ(0u, r);
           EXPECT_EQ(0u, g);
 #ifndef __APPLE__
-          // https://github.com/ignitionrobotics/ign-rendering/issues/332
+          // https://github.com/gazebosim/gz-rendering/issues/332
           EXPECT_GT(b, 0u);
           EXPECT_EQ(255u, a);
 #endif
@@ -477,7 +477,7 @@ void DepthCameraTest::DepthCameraBoxes(
   }
 
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 
@@ -490,43 +490,43 @@ void DepthCameraTest::DepthCameraParticles(
 
   // box should fill camera view
   // we will add particle emitter in between box and depth camera later
-  ignition::math::Vector3d boxSize(1.0, 10.0, 10.0);
-  ignition::math::Vector3d boxPosition(1.8, 0.0, 0.0);
+  gz::math::Vector3d boxSize(1.0, 10.0, 10.0);
+  gz::math::Vector3d boxPosition(1.8, 0.0, 0.0);
 
   // particle emitter is only supported in ogre2
   if (_renderEngine.compare("ogre2") != 0)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' doesn't support depth cameras" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
 
   // red background
   scene->SetBackgroundColor(1.0, 0.0, 0.0);
 
   // Create an scene with a box in it
   scene->SetAmbientLight(1.0, 1.0, 1.0);
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // create blue material
-  ignition::rendering::MaterialPtr blue = scene->CreateMaterial();
+  gz::rendering::MaterialPtr blue = scene->CreateMaterial();
   blue->SetAmbient(0.0, 0.0, 1.0);
   blue->SetDiffuse(0.0, 0.0, 1.0);
   blue->SetSpecular(0.0, 0.0, 1.0);
 
   // create box visual
-  ignition::rendering::VisualPtr box = scene->CreateVisual();
+  gz::rendering::VisualPtr box = scene->CreateVisual();
   box->AddGeometry(scene->CreateBox());
   box->SetOrigin(0.0, 0.0, 0.0);
   box->SetLocalPosition(boxPosition);
@@ -542,8 +542,8 @@ void DepthCameraTest::DepthCameraParticles(
     auto depthCamera = scene->CreateDepthCamera("DepthCamera");
     ASSERT_NE(depthCamera, nullptr);
 
-    ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0),
-        ignition::math::Quaterniond::Identity);
+    gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0),
+        gz::math::Quaterniond::Identity);
     depthCamera->SetLocalPose(testPose);
 
     // Configure depth camera
@@ -567,7 +567,7 @@ void DepthCameraTest::DepthCameraParticles(
 
     // Set a callback on the camera sensor to get a depth camera frame
     float *scan = new float[imgHeight_ * imgWidth_];
-    ignition::common::ConnectionPtr connection =
+    gz::common::ConnectionPtr connection =
       depthCamera->ConnectNewDepthFrame(
           std::bind(&::OnNewDepthFrame, scan,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -577,7 +577,7 @@ void DepthCameraTest::DepthCameraParticles(
     unsigned int pointCloudChannelCount = 4u;
     float *pointCloudData = new float[
         imgHeight_ * imgWidth_ * pointCloudChannelCount];
-    ignition::common::ConnectionPtr connection2 =
+    gz::common::ConnectionPtr connection2 =
       depthCamera->ConnectNewRgbPointCloud(
           std::bind(&::OnNewRgbPointCloud, pointCloudData,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -609,17 +609,17 @@ void DepthCameraTest::DepthCameraParticles(
         float d = scan[i * depthCamera->ImageWidth() + j];
         EXPECT_NEAR(expectedDepth, d, DEPTH_TOL);
 
-        pointAvg += ignition::math::Vector3d(x, y, z).Length();
+        pointAvg += gz::math::Vector3d(x, y, z).Length();
         depthAvg += d;
       }
     }
 
     // create particle emitter between depth camera and box
-    ignition::math::Vector3d particlePosition(1.0, 0, 0);
-    ignition::math::Quaterniond particleRotation(
-        ignition::math::Vector3d(0, -1.57, 0));
-    ignition::math::Vector3d particleSize(0.2, 0.2, 0.2);
-    ignition::rendering::ParticleEmitterPtr emitter =
+    gz::math::Vector3d particlePosition(1.0, 0, 0);
+    gz::math::Quaterniond particleRotation(
+        gz::math::Vector3d(0, -1.57, 0));
+    gz::math::Vector3d particleSize(0.2, 0.2, 0.2);
+    gz::rendering::ParticleEmitterPtr emitter =
         scene->CreateParticleEmitter();
     emitter->SetLocalPosition(particlePosition);
     emitter->SetLocalRotation(particleRotation);
@@ -628,8 +628,8 @@ void DepthCameraTest::DepthCameraParticles(
     emitter->SetLifetime(2);
     emitter->SetVelocityRange(0.1, 0.1);
     emitter->SetScaleRate(0.0);
-    emitter->SetColorRange(ignition::math::Color::Red,
-        ignition::math::Color::Black);
+    emitter->SetColorRange(gz::math::Color::Red,
+        gz::math::Color::Black);
     emitter->SetEmitting(true);
     root->AddChild(emitter);
 
@@ -672,19 +672,19 @@ void DepthCameraTest::DepthCameraParticles(
         //   * noisy particle depth (depth camera see particles but values
         //     are affected by noise)
         EXPECT_TRUE(
-            ignition::math::equal(expectedParticleDepth, xd, depthNoiseTol) ||
-            ignition::math::equal(expectedDepth, xd, DEPTH_TOL))
+            gz::math::equal(expectedParticleDepth, xd, depthNoiseTol) ||
+            gz::math::equal(expectedDepth, xd, DEPTH_TOL))
             << "actual vs expected particle depth: "
             << xd << " vs " << expectedParticleDepth;
         float depth = scan[i * depthCamera->ImageWidth() + j];
         double depthd = static_cast<double>(depth);
         EXPECT_TRUE(
-            ignition::math::equal(expectedParticleDepth, depthd, depthNoiseTol)
-            || ignition::math::equal(expectedDepth, depthd, DEPTH_TOL))
+            gz::math::equal(expectedParticleDepth, depthd, depthNoiseTol)
+            || gz::math::equal(expectedDepth, depthd, DEPTH_TOL))
             << "actual vs expected particle depth: "
             << depthd << " vs " << expectedParticleDepth;
 
-        pointParticleAvg += ignition::math::Vector3d(x, y, z).Length();
+        pointParticleAvg += gz::math::Vector3d(x, y, z).Length();
         depthParticleAvg += depthd;
       }
     }
@@ -737,20 +737,20 @@ void DepthCameraTest::DepthCameraParticles(
         //   * noisy particle depth (depth camera see particles but values
         //     are affected by noise)
         EXPECT_TRUE(
-            ignition::math::equal(expectedParticleDepth, xd, depthNoiseTol) ||
-            ignition::math::equal(expectedDepth, xd, DEPTH_TOL))
+            gz::math::equal(expectedParticleDepth, xd, depthNoiseTol) ||
+            gz::math::equal(expectedDepth, xd, DEPTH_TOL))
             << "actual vs expected particle depth: "
             << xd << " vs " << expectedParticleDepth;
         float depth = scan[i * depthCamera->ImageWidth() + j];
         double depthd = static_cast<double>(depth);
         EXPECT_TRUE(
-            ignition::math::equal(expectedParticleDepth, depthd, depthNoiseTol)
-            || ignition::math::equal(expectedDepth, depthd, DEPTH_TOL))
+            gz::math::equal(expectedParticleDepth, depthd, depthNoiseTol)
+            || gz::math::equal(expectedDepth, depthd, DEPTH_TOL))
             << "actual vs expected particle depth: "
             << depthd << " vs " << expectedParticleDepth;
 
         pointParticleLowScatterAvg +=
-            ignition::math::Vector3d(x, y, z).Length();
+            gz::math::Vector3d(x, y, z).Length();
         depthParticleLowScatterAvg += depthd;
       }
     }
@@ -772,7 +772,7 @@ void DepthCameraTest::DepthCameraParticles(
   }
 
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 TEST_P(DepthCameraTest, DepthCameraBoxes)
@@ -786,7 +786,7 @@ TEST_P(DepthCameraTest, DepthCameraParticles)
 }
 
 INSTANTIATE_TEST_CASE_P(DepthCamera, DepthCameraTest,
-    RENDER_ENGINE_VALUES, ignition::rendering::PrintToStringParam());
+    RENDER_ENGINE_VALUES, gz::rendering::PrintToStringParam());
 
 //////////////////////////////////////////////////
 int main(int argc, char **argv)
diff --git a/test/integration/gpu_rays.cc b/test/integration/gpu_rays.cc
index 475a51971..a487f2f88 100644
--- a/test/integration/gpu_rays.cc
+++ b/test/integration/gpu_rays.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Image.hh>
-#include <ignition/common/Filesystem.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Image.hh>
+#include <gz/common/Filesystem.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/GpuRays.hh"
-#include "ignition/rendering/ParticleEmitter.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/GpuRays.hh"
+#include "gz/rendering/ParticleEmitter.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
 #define LASER_TOL 2e-4
 #define DOUBLE_TOL 1e-6
@@ -37,7 +37,7 @@
 
 #define WAIT_TIME 0.02
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 void OnNewGpuRaysFrame(float *_scanDest, const float *_scan,
@@ -75,7 +75,7 @@ void GpuRaysTest::Configure(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "GpuRays not supported yet in rendering engine: "
+    gzdbg << "GpuRays not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -84,7 +84,7 @@ void GpuRaysTest::Configure(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -166,13 +166,13 @@ void GpuRaysTest::Configure(const std::string &_renderEngine)
 void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
 {
 #ifdef __APPLE__
-  ignerr << "Skipping test for apple, see issue #35." << std::endl;
+  gzerr << "Skipping test for apple, see issue #35." << std::endl;
   return;
 #endif
 
   if (_renderEngine == "optix")
   {
-    igndbg << "GpuRays not supported yet in rendering engine: "
+    gzdbg << "GpuRays not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -193,7 +193,7 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -204,8 +204,8 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   VisualPtr root = scene->RootVisual();
 
   // Create first ray caster
-  ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0.1),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0.1),
+      gz::math::Quaterniond::Identity);
 
   GpuRaysPtr gpuRays = scene->CreateGpuRays("gpu_rays_1");
   gpuRays->SetWorldPosition(testPose.Pos());
@@ -220,8 +220,8 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   root->AddChild(gpuRays);
 
   // Create a second ray caster rotated
-  ignition::math::Pose3d testPose2(ignition::math::Vector3d(0, 0, 0.1),
-      ignition::math::Quaterniond(IGN_PI/2.0, 0, 0));
+  gz::math::Pose3d testPose2(gz::math::Vector3d(0, 0, 0.1),
+      gz::math::Quaterniond(IGN_PI/2.0, 0, 0));
 
   GpuRaysPtr gpuRays2 = scene->CreateGpuRays("gpu_rays_2");
   gpuRays2->SetWorldPosition(testPose2.Pos());
@@ -242,8 +242,8 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
 
   // Create testing boxes
   // box in the center
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(3, 0, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(3, 0, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = scene->CreateVisual("UnitBox1");
   visualBox1->AddGeometry(scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -252,8 +252,8 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   root->AddChild(visualBox1);
 
   // box on the right of the first gpu rays caster
-  ignition::math::Pose3d box02Pose(ignition::math::Vector3d(0, -5, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box02Pose(gz::math::Vector3d(0, -5, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox2 = scene->CreateVisual("UnitBox2");
   visualBox2->AddGeometry(scene->CreateBox());
   visualBox2->SetWorldPosition(box02Pose.Pos());
@@ -262,9 +262,9 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   root->AddChild(visualBox2);
 
   // box on the left of the rays caster 1 but out of range
-  ignition::math::Pose3d box03Pose(
-      ignition::math::Vector3d(0, maxRange + 1, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box03Pose(
+      gz::math::Vector3d(0, maxRange + 1, 0.5),
+      gz::math::Quaterniond::Identity);
   VisualPtr visualBox3 = scene->CreateVisual("UnitBox3");
   visualBox3->AddGeometry(scene->CreateBox());
   visualBox3->SetWorldPosition(box03Pose.Pos());
@@ -293,7 +293,7 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   // rays caster 1 should see box01 and box02
   EXPECT_NEAR(scan[mid], expectedRangeAtMidPointBox1, LASER_TOL);
   EXPECT_NEAR(scan[0], expectedRangeAtMidPointBox2, LASER_TOL);
-  EXPECT_FLOAT_EQ(scan[last], ignition::math::INF_F);
+  EXPECT_FLOAT_EQ(scan[last], gz::math::INF_F);
 
   // laser retro is currently only supported in ogre2
   if (_renderEngine == "ogre2")
@@ -321,10 +321,10 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
 
   // Move all boxes out of range
   visualBox1->SetWorldPosition(
-      ignition::math::Vector3d(maxRange + 1, 0, 0));
+      gz::math::Vector3d(maxRange + 1, 0, 0));
   visualBox1->SetWorldRotation(box01Pose.Rot());
   visualBox2->SetWorldPosition(
-      ignition::math::Vector3d(0, -(maxRange + 1), 0));
+      gz::math::Vector3d(0, -(maxRange + 1), 0));
   visualBox2->SetWorldRotation(box02Pose.Rot());
 
   gpuRays->Update();
@@ -334,7 +334,7 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
   gpuRays2->Copy(scan2);
 
   for (int i = 0; i < gpuRays->RayCount(); ++i)
-    EXPECT_FLOAT_EQ(scan[i * 3], ignition::math::INF_F);
+    EXPECT_FLOAT_EQ(scan[i * 3], gz::math::INF_F);
 
   for (int i = 0; i < gpuRays2->RayCount(); ++i)
     EXPECT_FLOAT_EQ(scan2[i * 3], maxRange);
@@ -357,13 +357,13 @@ void GpuRaysTest::RaysUnitBox(const std::string &_renderEngine)
 void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
 {
 #ifdef __APPLE__
-  ignerr << "Skipping test for apple, see issue #35." << std::endl;
+  gzerr << "Skipping test for apple, see issue #35." << std::endl;
   return;
 #endif
 
   if (_renderEngine == "optix")
   {
-    igndbg << "GpuRays not supported yet in rendering engine: "
+    gzdbg << "GpuRays not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -385,7 +385,7 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -396,8 +396,8 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
   VisualPtr root = scene->RootVisual();
 
   // Create first ray caster
-  ignition::math::Pose3d testPose(ignition::math::Vector3d(0.25, 0, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d testPose(gz::math::Vector3d(0.25, 0, 0.5),
+      gz::math::Quaterniond::Identity);
 
   GpuRaysPtr gpuRays = scene->CreateGpuRays("vertical_gpu_rays");
   gpuRays->SetWorldPosition(testPose.Pos());
@@ -414,8 +414,8 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
 
   // Create testing boxes
   // box in front of ray sensor
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(1, 0, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(1, 0, 0.5),
+      gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = scene->CreateVisual("VerticalTestBox1");
   visualBox1->AddGeometry(scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -453,9 +453,9 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
 
     // check that the values in the extremes are infinity
     EXPECT_FLOAT_EQ(scan[i * hRayCount * channels],
-        ignition::math::INF_F);
+        gz::math::INF_F);
     EXPECT_FLOAT_EQ(scan[(i * hRayCount + (hRayCount - 1)) * channels],
-        ignition::math::INF_F);
+        gz::math::INF_F);
 
     // laser retro is currently only supported in ogre2
     if (_renderEngine == "ogre2")
@@ -467,9 +467,9 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
 
   // Move box out of range
   visualBox1->SetWorldPosition(
-      ignition::math::Vector3d(maxRange + 1, 0, 0));
+      gz::math::Vector3d(maxRange + 1, 0, 0));
   visualBox1->SetWorldRotation(
-      ignition::math::Quaterniond::Identity);
+      gz::math::Quaterniond::Identity);
 
   // wait for a few more laser scans
   gpuRays->Update();
@@ -480,7 +480,7 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
     for (int i = 0; i < gpuRays->RayCount(); ++i)
     {
       EXPECT_FLOAT_EQ(scan[j * gpuRays->RayCount() * channels+ i * channels],
-          ignition::math::INF_F);
+          gz::math::INF_F);
     }
   }
 
@@ -499,13 +499,13 @@ void GpuRaysTest::LaserVertical(const std::string &_renderEngine)
 void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
 {
 #ifdef __APPLE__
-  ignerr << "Skipping test for apple, see issue #35." << std::endl;
+  gzerr << "Skipping test for apple, see issue #35." << std::endl;
   return;
 #endif
 
   if (_renderEngine != "ogre2")
   {
-    igndbg << "GpuRays with particle effect is not supported yet in rendering "
+    gzdbg << "GpuRays with particle effect is not supported yet in rendering "
            << "engine: " << _renderEngine << std::endl;
     return;
   }
@@ -524,7 +524,7 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -535,8 +535,8 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
   VisualPtr root = scene->RootVisual();
 
   // Create ray caster
-  ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0.1),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0.1),
+      gz::math::Quaterniond::Identity);
 
   GpuRaysPtr gpuRays = scene->CreateGpuRays("gpu_rays_1");
   gpuRays->SetWorldPosition(testPose.Pos());
@@ -552,8 +552,8 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
 
   // Create testing boxes
   // box in the center
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(3, 0, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(3, 0, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = scene->CreateVisual("UnitBox1");
   visualBox1->AddGeometry(scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -561,8 +561,8 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
   root->AddChild(visualBox1);
 
   // box on the right of the first gpu rays caster
-  ignition::math::Pose3d box02Pose(ignition::math::Vector3d(0, -5, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box02Pose(gz::math::Vector3d(0, -5, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox2 = scene->CreateVisual("UnitBox2");
   visualBox2->AddGeometry(scene->CreateBox());
   visualBox2->SetWorldPosition(box02Pose.Pos());
@@ -570,9 +570,9 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
   root->AddChild(visualBox2);
 
   // box on the left of the rays caster 1 but out of range
-  ignition::math::Pose3d box03Pose(
-      ignition::math::Vector3d(0, maxRange + 1, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box03Pose(
+      gz::math::Vector3d(0, maxRange + 1, 0.5),
+      gz::math::Quaterniond::Identity);
   VisualPtr visualBox3 = scene->CreateVisual("UnitBox3");
   visualBox3->AddGeometry(scene->CreateBox());
   visualBox3->SetWorldPosition(box03Pose.Pos());
@@ -580,11 +580,11 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
   root->AddChild(visualBox3);
 
   // create particle emitter between sensor and box in the center
-  ignition::math::Vector3d particlePosition(1.0, 0, 0);
-  ignition::math::Quaterniond particleRotation(
-      ignition::math::Vector3d(0, -1.57, 0));
-  ignition::math::Vector3d particleSize(0.2, 0.2, 0.2);
-  ignition::rendering::ParticleEmitterPtr emitter =
+  gz::math::Vector3d particlePosition(1.0, 0, 0);
+  gz::math::Quaterniond particleRotation(
+      gz::math::Vector3d(0, -1.57, 0));
+  gz::math::Vector3d particleSize(0.2, 0.2, 0.2);
+  gz::rendering::ParticleEmitterPtr emitter =
       scene->CreateParticleEmitter();
   emitter->SetLocalPosition(particlePosition);
   emitter->SetLocalRotation(particleRotation);
@@ -593,8 +593,8 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
   emitter->SetLifetime(2);
   emitter->SetVelocityRange(0.1, 0.1);
   emitter->SetScaleRate(0.0);
-  emitter->SetColorRange(ignition::math::Color::Red,
-      ignition::math::Color::Black);
+  emitter->SetColorRange(gz::math::Color::Red,
+      gz::math::Color::Black);
   emitter->SetEmitting(true);
   root->AddChild(emitter);
 
@@ -633,9 +633,9 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
 
     // sensor should see ether a particle or box01
     double particleRange = static_cast<double>(scan[mid]);
-    bool particleHit = ignition::math::equal(
+    bool particleHit = gz::math::equal(
         expectedParticleRange, particleRange, laserNoiseTol);
-    bool particleMiss = ignition::math::equal(
+    bool particleMiss = gz::math::equal(
         expectedRangeAtMidPointBox1, particleRange, LASER_TOL);
     EXPECT_TRUE(particleHit || particleMiss)
         << "actual vs expected particle range: "
@@ -648,7 +648,7 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
     EXPECT_NEAR(expectedRangeAtMidPointBox2, scan[0], LASER_TOL);
 
     // sensor should not see box03 as it is out of range
-    EXPECT_DOUBLE_EQ(ignition::math::INF_F, scan[last]);
+    EXPECT_DOUBLE_EQ(gz::math::INF_F, scan[last]);
   }
 
   // there should be at least one hit
@@ -672,9 +672,9 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
 
     // sensor should see ether a particle or box01
     double particleRange = static_cast<double>(scan[mid]);
-    bool particleHit = ignition::math::equal(
+    bool particleHit = gz::math::equal(
         expectedParticleRange, particleRange, laserNoiseTol);
-    bool particleMiss = ignition::math::equal(
+    bool particleMiss = gz::math::equal(
         expectedRangeAtMidPointBox1, particleRange, LASER_TOL);
     EXPECT_TRUE(particleHit || particleMiss)
         << "actual vs expected particle range: "
@@ -687,7 +687,7 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
     EXPECT_NEAR(expectedRangeAtMidPointBox2, scan[0], LASER_TOL);
 
     // sensor should not see box03 as it is out of range
-    EXPECT_DOUBLE_EQ(ignition::math::INF_F, scan[last]);
+    EXPECT_DOUBLE_EQ(gz::math::INF_F, scan[last]);
   }
 
   // there should be at least one hit
@@ -716,13 +716,13 @@ void GpuRaysTest::RaysParticles(const std::string &_renderEngine)
 void GpuRaysTest::SingleRay(const std::string &_renderEngine)
 {
 #ifdef __APPLE__
-  ignerr << "Skipping test for apple, see issue #35." << std::endl;
+  gzerr << "Skipping test for apple, see issue #35." << std::endl;
   return;
 #endif
 
   if (_renderEngine == "optix")
   {
-    igndbg << "GpuRays not supported yet in rendering engine: "
+    gzdbg << "GpuRays not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -742,7 +742,7 @@ void GpuRaysTest::SingleRay(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -753,8 +753,8 @@ void GpuRaysTest::SingleRay(const std::string &_renderEngine)
   VisualPtr root = scene->RootVisual();
 
   // Create first ray caster
-  ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 7),
-      ignition::math::Quaterniond(0, IGN_PI/2.0, 0));
+  gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 7),
+      gz::math::Quaterniond(0, IGN_PI/2.0, 0));
 
   GpuRaysPtr gpuRays = scene->CreateGpuRays("gpu_rays");
   gpuRays->SetWorldPosition(testPose.Pos());
@@ -769,8 +769,8 @@ void GpuRaysTest::SingleRay(const std::string &_renderEngine)
   root->AddChild(gpuRays);
 
   // box in the center
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(0, 0, 4.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(0, 0, 4.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = scene->CreateVisual("UnitBox1");
   visualBox1->AddGeometry(scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -842,7 +842,7 @@ TEST_P(GpuRaysTest, SingleRay)
 
 INSTANTIATE_TEST_CASE_P(GpuRays, GpuRaysTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/lidar_visual.cc b/test/integration/lidar_visual.cc
index cc55a9470..f994337b5 100644
--- a/test/integration/lidar_visual.cc
+++ b/test/integration/lidar_visual.cc
@@ -17,17 +17,17 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Image.hh>
-#include <ignition/common/Filesystem.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Image.hh>
+#include <gz/common/Filesystem.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/GpuRays.hh"
-#include "ignition/rendering/LidarVisual.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/GpuRays.hh"
+#include "gz/rendering/LidarVisual.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
 #define LASER_TOL 2e-4
 #define DOUBLE_TOL 1e-6
@@ -35,7 +35,7 @@
 // vertical range values seem to be less accurate
 #define VERTICAL_LASER_TOL 1e-3
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 void OnNewGpuRaysFrame(float *_scanDest, const float *_scan,
@@ -67,7 +67,7 @@ void LidarVisualTest::Configure(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "LidarVisual not supported yet in rendering engine: "
+    gzdbg << "LidarVisual not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -76,7 +76,7 @@ void LidarVisualTest::Configure(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -123,7 +123,7 @@ void LidarVisualTest::Configure(const std::string &_renderEngine)
     lidarVis->SetVerticalRayCount(30);
     EXPECT_EQ(lidarVis->VerticalRayCount(), 30u);
 
-    ignition::math::Pose3d offset(1.5, 3.6, 2.9, 1.1, -5.3, -2.9);
+    gz::math::Pose3d offset(1.5, 3.6, 2.9, 1.1, -5.3, -2.9);
     lidarVis->SetOffset(offset);
     EXPECT_EQ(lidarVis->Offset(), offset);
 
@@ -165,7 +165,7 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
 
   if (_renderEngine == "optix")
   {
-    igndbg << "LidarVisual not supported yet in rendering engine: "
+    gzdbg << "LidarVisual not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -186,7 +186,7 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -197,8 +197,8 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   VisualPtr root = scene->RootVisual();
 
   // Create first ray caster
-  ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0.1),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0.1),
+      gz::math::Quaterniond::Identity);
 
   GpuRaysPtr gpuRays = scene->CreateGpuRays("gpu_rays_1");
   gpuRays->SetWorldPosition(testPose.Pos());
@@ -226,8 +226,8 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   root->AddChild(lidarVis);
 
   // Create a second ray caster rotated
-  ignition::math::Pose3d testPose2(ignition::math::Vector3d(0, 0, 0.1),
-      ignition::math::Quaterniond(IGN_PI/2.0, 0, 0));
+  gz::math::Pose3d testPose2(gz::math::Vector3d(0, 0, 0.1),
+      gz::math::Quaterniond(IGN_PI/2.0, 0, 0));
 
   GpuRaysPtr gpuRays2 = scene->CreateGpuRays("gpu_rays_2");
   gpuRays2->SetWorldPosition(testPose2.Pos());
@@ -257,8 +257,8 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
 
   // Create testing boxes
   // box in the center
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(3, 0, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(3, 0, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = scene->CreateVisual("UnitBox1");
   visualBox1->AddGeometry(scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -266,8 +266,8 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   root->AddChild(visualBox1);
 
   // box on the right of the first gpu rays caster
-  ignition::math::Pose3d box02Pose(ignition::math::Vector3d(0, -5, 0.5),
-                                   ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box02Pose(gz::math::Vector3d(0, -5, 0.5),
+                                   gz::math::Quaterniond::Identity);
   VisualPtr visualBox2 = scene->CreateVisual("UnitBox2");
   visualBox2->AddGeometry(scene->CreateBox());
   visualBox2->SetWorldPosition(box02Pose.Pos());
@@ -275,9 +275,9 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   root->AddChild(visualBox2);
 
   // box on the left of the rays caster 1 but out of range
-  ignition::math::Pose3d box03Pose(
-      ignition::math::Vector3d(0, maxRange + 1, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box03Pose(
+      gz::math::Vector3d(0, maxRange + 1, 0.5),
+      gz::math::Quaterniond::Identity);
   VisualPtr visualBox3 = scene->CreateVisual("UnitBox3");
   visualBox3->AddGeometry(scene->CreateBox());
   visualBox3->SetWorldPosition(box03Pose.Pos());
@@ -319,7 +319,7 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   // rays caster values received from lidar should see box01 and box02
   EXPECT_NEAR(pts_back[mid], expectedRangeAtMidPointBox1, LASER_TOL);
   EXPECT_NEAR(pts_back[0], expectedRangeAtMidPointBox2, LASER_TOL);
-  EXPECT_FLOAT_EQ(pts_back[last], ignition::math::INF_F);
+  EXPECT_FLOAT_EQ(pts_back[last], gz::math::INF_F);
 
   // Verify rays caster 2 range readings
   // listen to new gpu rays frames
@@ -349,10 +349,10 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
 
   // Move all boxes out of range
   visualBox1->SetWorldPosition(
-      ignition::math::Vector3d(maxRange + 1, 0, 0));
+      gz::math::Vector3d(maxRange + 1, 0, 0));
   visualBox1->SetWorldRotation(box01Pose.Rot());
   visualBox2->SetWorldPosition(
-      ignition::math::Vector3d(0, -(maxRange + 1), 0));
+      gz::math::Vector3d(0, -(maxRange + 1), 0));
   visualBox2->SetWorldRotation(box02Pose.Rot());
 
   gpuRays->Update();
@@ -378,7 +378,7 @@ void LidarVisualTest::RaysUnitBox(const std::string &_renderEngine)
   }
 
   for (unsigned int i = 0; i < lidarVis->HorizontalRayCount(); ++i)
-    EXPECT_FLOAT_EQ(pts[i], ignition::math::INF_F);
+    EXPECT_FLOAT_EQ(pts[i], gz::math::INF_F);
 
   for (unsigned int i = 0; i < lidarVis->HorizontalRayCount(); ++i)
     EXPECT_FLOAT_EQ(pts2[i], maxRange);
@@ -407,7 +407,7 @@ void LidarVisualTest::LaserVertical(const std::string &_renderEngine)
 
   if (_renderEngine == "optix")
   {
-    igndbg << "LidarVisual not supported yet in rendering engine: "
+    gzdbg << "LidarVisual not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -429,7 +429,7 @@ void LidarVisualTest::LaserVertical(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -440,8 +440,8 @@ void LidarVisualTest::LaserVertical(const std::string &_renderEngine)
   VisualPtr root = scene->RootVisual();
 
   // Create first ray caster
-  ignition::math::Pose3d testPose(ignition::math::Vector3d(0.25, 0, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d testPose(gz::math::Vector3d(0.25, 0, 0.5),
+      gz::math::Quaterniond::Identity);
 
   GpuRaysPtr gpuRays = scene->CreateGpuRays("vertical_gpu_rays");
   gpuRays->SetWorldPosition(testPose.Pos());
@@ -471,8 +471,8 @@ void LidarVisualTest::LaserVertical(const std::string &_renderEngine)
 
   // Create testing boxes
   // box in front of ray sensor
-  ignition::math::Pose3d box01Pose(ignition::math::Vector3d(1, 0, 0.5),
-      ignition::math::Quaterniond::Identity);
+  gz::math::Pose3d box01Pose(gz::math::Vector3d(1, 0, 0.5),
+      gz::math::Quaterniond::Identity);
   VisualPtr visualBox1 = scene->CreateVisual("VerticalTestBox1");
   visualBox1->AddGeometry(scene->CreateBox());
   visualBox1->SetWorldPosition(box01Pose.Pos());
@@ -519,16 +519,16 @@ void LidarVisualTest::LaserVertical(const std::string &_renderEngine)
 
     // check that the values in the extremes are infinity
     EXPECT_FLOAT_EQ(pts[i * hRayCount ],
-        ignition::math::INF_F);
+        gz::math::INF_F);
     EXPECT_FLOAT_EQ(pts[(i * hRayCount + (hRayCount - 1))],
-        ignition::math::INF_F);
+        gz::math::INF_F);
   }
 
   // Move box out of range
   visualBox1->SetWorldPosition(
-      ignition::math::Vector3d(maxRange + 1, 0, 0));
+      gz::math::Vector3d(maxRange + 1, 0, 0));
   visualBox1->SetWorldRotation(
-      ignition::math::Quaterniond::Identity);
+      gz::math::Quaterniond::Identity);
 
   // after a few more laser scans
   gpuRays->Update();
@@ -549,7 +549,7 @@ void LidarVisualTest::LaserVertical(const std::string &_renderEngine)
     for (unsigned int i = 0; i < lidarVis->HorizontalRayCount(); ++i)
     {
       EXPECT_FLOAT_EQ(pts[j * lidarVis->HorizontalRayCount()+ i],
-          ignition::math::INF_F);
+          gz::math::INF_F);
     }
   }
 
@@ -583,7 +583,7 @@ TEST_P(LidarVisualTest, LaserVertical)
 
 INSTANTIATE_TEST_CASE_P(LidarVisual, LidarVisualTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/render_pass.cc b/test/integration/render_pass.cc
index e7dea198c..a039b3e45 100644
--- a/test/integration/render_pass.cc
+++ b/test/integration/render_pass.cc
@@ -17,21 +17,21 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Image.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Image.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/DepthCamera.hh"
-#include "ignition/rendering/DistortionPass.hh"
-#include "ignition/rendering/GaussianNoisePass.hh"
-#include "ignition/rendering/Image.hh"
-#include "ignition/rendering/PixelFormat.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/RenderPassSystem.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/DepthCamera.hh"
+#include "gz/rendering/DistortionPass.hh"
+#include "gz/rendering/GaussianNoisePass.hh"
+#include "gz/rendering/Image.hh"
+#include "gz/rendering/PixelFormat.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/RenderPassSystem.hh"
+#include "gz/rendering/Scene.hh"
 
 #define DOUBLE_TOL 1e-6
 unsigned int g_pointCloudCounter = 0;
@@ -46,7 +46,7 @@ void OnNewRgbPointCloud(float *_scanDest, const float *_scan,
   memcpy(_scanDest, _scan, size * sizeof(f));
   g_pointCloudCounter++;
 }
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class RenderPassTest: public testing::Test,
@@ -69,7 +69,7 @@ void RenderPassTest::GaussianNoise(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -130,7 +130,7 @@ void RenderPassTest::GaussianNoise(const std::string &_renderEngine)
   }
   else
   {
-    ignwarn << "Engine '" << _renderEngine << "' does not support "
+    gzwarn << "Engine '" << _renderEngine << "' does not support "
             << "render pass  system" << std::endl;
     return;
   }
@@ -187,42 +187,42 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
   double aspectRatio_ = imgWidth/imgHeight;
 
   double unitBoxSize = 1.0;
-  ignition::math::Vector3d boxPosition(1.8, 0.0, 0.0);
+  gz::math::Vector3d boxPosition(1.8, 0.0, 0.0);
 
   // Optix is not supported
   if (_renderEngine != "ogre2")
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' doesn't support render pass for depth cameras " << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
 
   // red background
   scene->SetBackgroundColor(1.0, 0.0, 0.0);
 
   // Create an scene with a box in it
   scene->SetAmbientLight(1.0, 1.0, 1.0);
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // create blue material
-  ignition::rendering::MaterialPtr blue = scene->CreateMaterial();
+  gz::rendering::MaterialPtr blue = scene->CreateMaterial();
   blue->SetAmbient(0.0, 0.0, 1.0);
   blue->SetDiffuse(0.0, 0.0, 1.0);
   blue->SetSpecular(0.0, 0.0, 1.0);
 
   // create box visual
-  ignition::rendering::VisualPtr box = scene->CreateVisual();
+  gz::rendering::VisualPtr box = scene->CreateVisual();
   box->AddGeometry(scene->CreateBox());
   box->SetOrigin(0.0, 0.0, 0.0);
   box->SetLocalPosition(boxPosition);
@@ -238,8 +238,8 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
     auto depthCamera = scene->CreateDepthCamera("DepthCamera");
     ASSERT_NE(depthCamera, nullptr);
 
-    ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0),
-        ignition::math::Quaterniond::Identity);
+    gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0),
+        gz::math::Quaterniond::Identity);
     depthCamera->SetLocalPose(testPose);
 
     // Configure depth camera
@@ -277,7 +277,7 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
     }
     else
     {
-      ignwarn << "Engine '" << _renderEngine << "' does not support "
+      gzwarn << "Engine '" << _renderEngine << "' does not support "
               << "render pass  system" << std::endl;
       return;
     }
@@ -286,7 +286,7 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
     unsigned int pointCloudChannelCount = 4u;
     float *pointCloudData = new float[
         imgHeight * imgWidth * pointCloudChannelCount];
-    ignition::common::ConnectionPtr connection =
+    gz::common::ConnectionPtr connection =
       depthCamera->ConnectNewRgbPointCloud(
           std::bind(&::OnNewRgbPointCloud, pointCloudData,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -312,7 +312,7 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
         * (depthCamera->ImageWidth() * pointCloudChannelCount)
         - pointCloudChannelCount;
 
-    float maxVal = ignition::math::INF_D;
+    float maxVal = gz::math::INF_D;
 
     // values should be well within 4-sigma
     float noiseTol = 4.0*noiseStdDev;
@@ -387,7 +387,7 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
       // drivers are free to fill it with any value they want.
       // This should be fixed in ogre 2.2 in ign-rendering6 which forbids
       // the use of RGB format.
-      // see https://github.com/ignitionrobotics/ign-rendering/issues/315
+      // see https://github.com/gazebosim/gz-rendering/issues/315
       EXPECT_TRUE(255u == ma || 0u == ma);
       EXPECT_TRUE(255u == la || 0u == la);
       EXPECT_TRUE(255u == ra || 0u == ra);
@@ -400,7 +400,7 @@ void RenderPassTest::DepthGaussianNoise(const std::string &_renderEngine)
   }
 
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 void RenderPassTest::Distortion(const std::string &_renderEngine)
@@ -409,14 +409,14 @@ void RenderPassTest::Distortion(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
   if (_renderEngine == "ogre2")
   {
-    igndbg << "Distortion is currently not supported in OGRE2" << std::endl;
+    gzdbg << "Distortion is currently not supported in OGRE2" << std::endl;
     return;
 
   }
@@ -499,7 +499,7 @@ void RenderPassTest::Distortion(const std::string &_renderEngine)
   }
   else
   {
-    ignwarn << "Engine '" << _renderEngine << "' does not support "
+    gzwarn << "Engine '" << _renderEngine << "' does not support "
             << "render pass  system" << std::endl;
     return;
   }
@@ -565,7 +565,7 @@ TEST_P(RenderPassTest, Distortion)
 
 INSTANTIATE_TEST_CASE_P(RenderPass, RenderPassTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/scene.cc b/test/integration/scene.cc
index 79e657e3c..37326853c 100644
--- a/test/integration/scene.cc
+++ b/test/integration/scene.cc
@@ -17,16 +17,16 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class SceneTest: public testing::Test,
@@ -35,7 +35,7 @@ class SceneTest: public testing::Test,
   // Documentation inherited
   public: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 
   // Test adding and removing visuals
@@ -54,7 +54,7 @@ void SceneTest::AddRemoveVisuals(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -150,7 +150,7 @@ void SceneTest::VisualAt(const std::string &_renderEngine)
 {
   if (_renderEngine == "optix")
   {
-    igndbg << "RayQuery not supported yet in rendering engine: "
+    gzdbg << "RayQuery not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -159,7 +159,7 @@ void SceneTest::VisualAt(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -205,19 +205,19 @@ void SceneTest::VisualAt(const std::string &_renderEngine)
   camera->Update();
 
   // test get sphere object
-  ignition::math::Vector2i spherePosition(220, 307);
+  gz::math::Vector2i spherePosition(220, 307);
   VisualPtr sphere_visual = scene->VisualAt(camera, spherePosition);
   ASSERT_TRUE(sphere_visual != nullptr);
   EXPECT_EQ("sphere", sphere_visual->Name());
 
   // test get box object
-  ignition::math::Vector2i boxPosition(452, 338);
+  gz::math::Vector2i boxPosition(452, 338);
   VisualPtr box_visual = scene->VisualAt(camera, boxPosition);
   ASSERT_TRUE(box_visual != nullptr);
   EXPECT_EQ("box", box_visual->Name());
 
   // test get no object
-  ignition::math::Vector2i emptyPosition(300, 150);
+  gz::math::Vector2i emptyPosition(300, 150);
   VisualPtr empty_visual = scene->VisualAt(camera, emptyPosition);
   ASSERT_TRUE(empty_visual == nullptr);
 
@@ -241,7 +241,7 @@ TEST_P(SceneTest, VisualAt)
 // It doesn't suppot optix just yet
 INSTANTIATE_TEST_CASE_P(Scene, SceneTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/segmentation_camera.cc b/test/integration/segmentation_camera.cc
index f4bb6df06..598f211d3 100644
--- a/test/integration/segmentation_camera.cc
+++ b/test/integration/segmentation_camera.cc
@@ -17,20 +17,20 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Event.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Event.hh>
 
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/SegmentationCamera.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/SegmentationCamera.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -42,7 +42,7 @@ class SegmentationCameraTest: public testing::Test,
   // Documentation inherited
   protected: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 };
 
@@ -104,7 +104,7 @@ void BuildScene(rendering::ScenePtr scene)
   root->AddChild(box1);
 
   // create box visual of different label
-  ignition::rendering::VisualPtr box2 = scene->CreateVisual("box_mid");
+  gz::rendering::VisualPtr box2 = scene->CreateVisual("box_mid");
   box2->AddGeometry(scene->CreateBox());
   box2->SetOrigin(0.0, 0.0, 0.0);
   box2->SetLocalPosition(middlePosition);
@@ -120,20 +120,20 @@ void SegmentationCameraTest::SegmentationCameraBoxes(
   // Currently, only ogre2 supports segmentation cameras
   if (_renderEngine.compare("ogre2") != 0)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
               << "' doesn't support segmentation cameras" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
               << "' was unable to be retrieved" << std::endl;
     return;
   }
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
   ASSERT_NE(nullptr, scene);
   BuildScene(scene);
 
@@ -168,7 +168,7 @@ void SegmentationCameraTest::SegmentationCameraBoxes(
   scene->RootVisual()->AddChild(camera);
 
   // Set a callback on the  camera sensor to get a Segmentation camera frame
-  ignition::common::ConnectionPtr connection =
+  gz::common::ConnectionPtr connection =
       camera->ConnectNewSegmentationFrame(
           std::bind(OnNewSegmentationFrame,
           std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -232,14 +232,14 @@ void SegmentationCameraTest::SegmentationCameraBoxes(
   // instance count
   // the instance count for the right box is 1 and the instance count for the
   // left box is 2 because of how items are sorted when material switching:
-  // https://github.com/ignitionrobotics/ign-rendering/blob/c4e06851605bda75e2ca45a35f0e9bd86fbd7f2f/ogre2/src/Ogre2SegmentationMaterialSwitcher.cc#L171-L179
+  // https://github.com/gazebosim/gz-rendering/blob/c4e06851605bda75e2ca45a35f0e9bd86fbd7f2f/ogre2/src/Ogre2SegmentationMaterialSwitcher.cc#L171-L179
   EXPECT_EQ(1, middleCount);
   EXPECT_EQ(1, rightCount);
   EXPECT_EQ(2, leftCount);
 
   // Clean up
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 TEST_P(SegmentationCameraTest, SegmentationCameraBoxes)
@@ -248,7 +248,7 @@ TEST_P(SegmentationCameraTest, SegmentationCameraBoxes)
 }
 
 INSTANTIATE_TEST_CASE_P(SegmentationCamera, SegmentationCameraTest,
-    RENDER_ENGINE_VALUES, ignition::rendering::PrintToStringParam());
+    RENDER_ENGINE_VALUES, gz::rendering::PrintToStringParam());
 
 //////////////////////////////////////////////////
 int main(int argc, char **argv)
diff --git a/test/integration/shadows.cc b/test/integration/shadows.cc
index bf0b6fc1c..7b1253142 100644
--- a/test/integration/shadows.cc
+++ b/test/integration/shadows.cc
@@ -17,19 +17,19 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Image.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Image.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/Image.hh"
-#include "ignition/rendering/PixelFormat.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/Image.hh"
+#include "gz/rendering/PixelFormat.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class ShadowsTest: public testing::Test,
@@ -44,14 +44,14 @@ void ShadowsTest::Shadows(const std::string &_renderEngine)
 {
   // override and make sure not to look for resources in installed share dir
   std::string projectSrcPath = PROJECT_SOURCE_PATH;
-  std::string env = "IGN_RENDERING_RESOURCE_PATH=" + projectSrcPath;
+  std::string env = "GZ_RENDERING_RESOURCE_PATH=" + projectSrcPath;
   putenv(const_cast<char *>(env.c_str()));
 
   // create and populate scene
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
@@ -209,7 +209,7 @@ TEST_P(ShadowsTest, Shadows)
 
 INSTANTIATE_TEST_CASE_P(Shadows, ShadowsTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/sky.cc b/test/integration/sky.cc
index fb622a5c4..8d807fc7e 100644
--- a/test/integration/sky.cc
+++ b/test/integration/sky.cc
@@ -17,19 +17,19 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Image.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Image.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/Camera.hh"
-#include "ignition/rendering/Image.hh"
-#include "ignition/rendering/PixelFormat.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/Camera.hh"
+#include "gz/rendering/Image.hh"
+#include "gz/rendering/PixelFormat.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 class SkyTest: public testing::Test,
@@ -38,7 +38,7 @@ class SkyTest: public testing::Test,
   // Documentation inherited
   public: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 
   // Test and verify sky is created
@@ -52,14 +52,14 @@ void SkyTest::Sky(const std::string &_renderEngine)
   RenderEngine *engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
   if (_renderEngine != "ogre2")
   {
-    igndbg << "Sky not supported yet in rendering engine: "
+    gzdbg << "Sky not supported yet in rendering engine: "
             << _renderEngine << std::endl;
     return;
   }
@@ -152,7 +152,7 @@ TEST_P(SkyTest, Sky)
 
 INSTANTIATE_TEST_CASE_P(Sky, SkyTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/integration/thermal_camera.cc b/test/integration/thermal_camera.cc
index 6cefffa93..b34a827b4 100644
--- a/test/integration/thermal_camera.cc
+++ b/test/integration/thermal_camera.cc
@@ -17,20 +17,20 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Event.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Event.hh>
 
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/ParticleEmitter.hh"
-#include "ignition/rendering/PixelFormat.hh"
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/ThermalCamera.hh"
+#include "gz/rendering/ParticleEmitter.hh"
+#include "gz/rendering/PixelFormat.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/ThermalCamera.hh"
 
 #define DEPTH_TOL 1e-4
 #define DOUBLE_TOL 1e-6
@@ -71,13 +71,13 @@ class ThermalCameraTest: public testing::Test,
 
   // Path to test textures
   public: const std::string TEST_MEDIA_PATH =
-          ignition::common::joinPaths(std::string(PROJECT_SOURCE_PATH),
+          gz::common::joinPaths(std::string(PROJECT_SOURCE_PATH),
                 "test", "media", "materials", "textures");
 
   // Documentation inherited
   protected: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 };
 
@@ -90,43 +90,43 @@ void ThermalCameraTest::ThermalCameraBoxes(
   double aspectRatio = imgWidth/imgHeight;
 
   double unitBoxSize = 1.0;
-  ignition::math::Vector3d boxPosition(1.8, 0.0, 0.0);
+  gz::math::Vector3d boxPosition(1.8, 0.0, 0.0);
 
   // Optix is not supported
   if (_renderEngine.compare("optix") == 0)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' doesn't support thermal cameras" << std::endl;
     return;
   }
   // Only ogre2 supports heat signatures
   else if (_useHeatSignature && (_renderEngine.compare("ogre2") != 0))
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' doesn't support heat signatures" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
 
   // red background
   scene->SetBackgroundColor(1.0, 0.0, 0.0);
 
   // Create an scene with a box in it
   scene->SetAmbientLight(1.0, 1.0, 1.0);
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // create box visual
-  ignition::rendering::VisualPtr box = scene->CreateVisual();
+  gz::rendering::VisualPtr box = scene->CreateVisual();
   box->AddGeometry(scene->CreateBox());
   box->SetOrigin(0.0, 0.0, 0.0);
   box->SetLocalPosition(boxPosition);
@@ -139,7 +139,7 @@ void ThermalCameraTest::ThermalCameraBoxes(
   if (_useHeatSignature)
   {
     std::string textureName =
-      ignition::common::joinPaths(TEST_MEDIA_PATH, "gray_texture.png");
+      gz::common::joinPaths(TEST_MEDIA_PATH, "gray_texture.png");
     box->SetUserData("temperature", textureName);
     box->SetUserData("minTemp", 100.0f);
     box->SetUserData("maxTemp", 200.0f);
@@ -159,8 +159,8 @@ void ThermalCameraTest::ThermalCameraBoxes(
     auto thermalCamera = scene->CreateThermalCamera("ThermalCamera");
     ASSERT_NE(thermalCamera, nullptr);
 
-    ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0),
-        ignition::math::Quaterniond::Identity);
+    gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0),
+        gz::math::Quaterniond::Identity);
     thermalCamera->SetLocalPose(testPose);
 
     // Configure thermal camera
@@ -196,7 +196,7 @@ void ThermalCameraTest::ThermalCameraBoxes(
 
     // Set a callback on the  camera sensor to get a thermal camera frame
     uint16_t *thermalData = new uint16_t[imgHeight * imgWidth];
-    ignition::common::ConnectionPtr connection =
+    gz::common::ConnectionPtr connection =
       thermalCamera->ConnectNewThermalFrame(
           std::bind(&::OnNewThermalFrame, thermalData,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -225,7 +225,7 @@ void ThermalCameraTest::ThermalCameraBoxes(
 
     // move box in front of near clip plane and verify the thermal
     // image returns all box temperature values
-    ignition::math::Vector3d boxPositionNear(
+    gz::math::Vector3d boxPositionNear(
         unitBoxSize * 0.5 + nearDist * 0.5, 0.0, 0.0);
     box->SetLocalPosition(boxPositionNear);
     thermalCamera->Update();
@@ -237,7 +237,7 @@ void ThermalCameraTest::ThermalCameraBoxes(
       {
         float temp = thermalData[step + j] * linearResolution;
 #ifndef __APPLE__
-        // https://github.com/ignitionrobotics/ign-rendering/issues/253
+        // https://github.com/gazebosim/gz-rendering/issues/253
         EXPECT_NEAR(boxTemp, temp, boxTempRange);
 #endif
       }
@@ -245,7 +245,7 @@ void ThermalCameraTest::ThermalCameraBoxes(
 
     // move box beyond far clip plane and verify the thermal
     // image returns all ambient temperature values
-    ignition::math::Vector3d boxPositionFar(
+    gz::math::Vector3d boxPositionFar(
         unitBoxSize * 0.5 + farDist * 1.5, 0.0, 0.0);
     box->SetLocalPosition(boxPositionFar);
     thermalCamera->Update();
@@ -266,7 +266,7 @@ void ThermalCameraTest::ThermalCameraBoxes(
   }
 
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 //////////////////////////////////////////////////
@@ -278,36 +278,36 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
   double aspectRatio = imgWidth / imgHeight;
 
   double unitBoxSize = 1.0;
-  ignition::math::Vector3d boxPosition(1.8, 0.0, 0.0);
+  gz::math::Vector3d boxPosition(1.8, 0.0, 0.0);
 
   // Only ogre2 supports 8 bit image format
   if (_renderEngine.compare("ogre2") != 0)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' doesn't support 8 bit thermal cameras" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
 
   // red background
   scene->SetBackgroundColor(1.0, 0.0, 0.0);
 
   // Create an scene with a box in it
   scene->SetAmbientLight(1.0, 1.0, 1.0);
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // create box visual
-  ignition::rendering::VisualPtr box = scene->CreateVisual();
+  gz::rendering::VisualPtr box = scene->CreateVisual();
   box->AddGeometry(scene->CreateBox());
   box->SetOrigin(0.0, 0.0, 0.0);
   box->SetLocalPosition(boxPosition);
@@ -335,8 +335,8 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
     auto thermalCamera = scene->CreateThermalCamera("ThermalCamera");
     ASSERT_NE(thermalCamera, nullptr);
 
-    ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0),
-        ignition::math::Quaterniond::Identity);
+    gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0),
+        gz::math::Quaterniond::Identity);
     thermalCamera->SetLocalPose(testPose);
 
     // Configure thermal camera
@@ -356,8 +356,8 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
     EXPECT_NEAR(thermalCamera->HFOV().Radian(), hfov, DOUBLE_TOL);
 
     // set bit depth
-    thermalCamera->SetImageFormat(ignition::rendering::PF_L8);
-    EXPECT_EQ(ignition::rendering::PF_L8, thermalCamera->ImageFormat());
+    thermalCamera->SetImageFormat(gz::rendering::PF_L8);
+    EXPECT_EQ(gz::rendering::PF_L8, thermalCamera->ImageFormat());
 
     // set min max temp
     thermalCamera->SetMinTemperature(minTemp);
@@ -387,7 +387,7 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
     // todo(anyone) change this to uint8_t when thermal cameras supports a
     // ConnectNewThermalFrame event that provides this format
     uint16_t *thermalData = new uint16_t[imgHeight * imgWidth];
-    ignition::common::ConnectionPtr connection =
+    gz::common::ConnectionPtr connection =
       thermalCamera->ConnectNewThermalFrame(
           std::bind(&::OnNewThermalFrame, thermalData,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -416,7 +416,7 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
 
     // move box in front of near clip plane and verify the thermal
     // image returns all box temperature values
-    ignition::math::Vector3d boxPositionNear(
+    gz::math::Vector3d boxPositionNear(
         unitBoxSize * 0.5 + nearDist * 0.5, 0.0, 0.0);
     box->SetLocalPosition(boxPositionNear);
     thermalCamera->Update();
@@ -433,7 +433,7 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
 
     // move box beyond far clip plane and verify the thermal
     // image returns all ambient temperature values
-    ignition::math::Vector3d boxPositionFar(
+    gz::math::Vector3d boxPositionFar(
         unitBoxSize * 0.5 + farDist * 1.5, 0.0, 0.0);
     box->SetLocalPosition(boxPositionFar);
     thermalCamera->Update();
@@ -454,7 +454,7 @@ void ThermalCameraTest::ThermalCameraBoxes8Bit(
   }
 
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 //////////////////////////////////////////////////
@@ -466,36 +466,36 @@ void ThermalCameraTest::ThermalCameraParticles(
   double aspectRatio = imgWidth / imgHeight;
 
   double unitBoxSize = 1.0;
-  ignition::math::Vector3d boxPosition(1.8, 0.0, 0.0);
+  gz::math::Vector3d boxPosition(1.8, 0.0, 0.0);
 
   // Only ogre2 supports 8 bit image format
   if (_renderEngine.compare("ogre2") != 0)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
            << "' doesn't support 8 bit thermal cameras" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine
+    gzdbg << "Engine '" << _renderEngine
               << "' is not supported" << std::endl;
     return;
   }
 
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
 
   // red background
   scene->SetBackgroundColor(1.0, 0.0, 0.0);
 
   // Create an scene with a box in it
   scene->SetAmbientLight(1.0, 1.0, 1.0);
-  ignition::rendering::VisualPtr root = scene->RootVisual();
+  gz::rendering::VisualPtr root = scene->RootVisual();
 
   // create box visual
-  ignition::rendering::VisualPtr box = scene->CreateVisual();
+  gz::rendering::VisualPtr box = scene->CreateVisual();
   box->AddGeometry(scene->CreateBox());
   box->SetOrigin(0.0, 0.0, 0.0);
   box->SetLocalPosition(boxPosition);
@@ -509,15 +509,15 @@ void ThermalCameraTest::ThermalCameraParticles(
   root->AddChild(box);
 
   // create particle emitter between camera and box
-  ignition::rendering::ParticleEmitterPtr emitter =
+  gz::rendering::ParticleEmitterPtr emitter =
       scene->CreateParticleEmitter();
   emitter->SetLocalPosition({0.5, 0, 0});
   emitter->SetRate(10);
   emitter->SetParticleSize({1, 1, 1});
   emitter->SetLifetime(2);
   emitter->SetVelocityRange(0.1, 0.5);
-  emitter->SetColorRange(ignition::math::Color::Red,
-      ignition::math::Color::Black);
+  emitter->SetColorRange(gz::math::Color::Red,
+      gz::math::Color::Black);
   emitter->SetScaleRate(1);
   emitter->SetEmitting(true);
 
@@ -537,8 +537,8 @@ void ThermalCameraTest::ThermalCameraParticles(
     auto thermalCamera = scene->CreateThermalCamera("ThermalCamera");
     ASSERT_NE(thermalCamera, nullptr);
 
-    ignition::math::Pose3d testPose(ignition::math::Vector3d(0, 0, 0),
-        ignition::math::Quaterniond::Identity);
+    gz::math::Pose3d testPose(gz::math::Vector3d(0, 0, 0),
+        gz::math::Quaterniond::Identity);
     thermalCamera->SetLocalPose(testPose);
 
     // Configure thermal camera
@@ -558,8 +558,8 @@ void ThermalCameraTest::ThermalCameraParticles(
     EXPECT_DOUBLE_EQ(thermalCamera->HFOV().Radian(), hfov);
 
     // set bit depth
-    thermalCamera->SetImageFormat(ignition::rendering::PF_L8);
-    EXPECT_EQ(ignition::rendering::PF_L8, thermalCamera->ImageFormat());
+    thermalCamera->SetImageFormat(gz::rendering::PF_L8);
+    EXPECT_EQ(gz::rendering::PF_L8, thermalCamera->ImageFormat());
 
     // set min max temp
     thermalCamera->SetMinTemperature(minTemp);
@@ -587,7 +587,7 @@ void ThermalCameraTest::ThermalCameraParticles(
     // todo(anyone) change this to uint8_t when thermal cameras supports a
     // ConnectNewThermalFrame event that provides this format
     uint16_t *thermalData = new uint16_t[imgHeight * imgWidth];
-    ignition::common::ConnectionPtr connection =
+    gz::common::ConnectionPtr connection =
       thermalCamera->ConnectNewThermalFrame(
           std::bind(&::OnNewThermalFrame, thermalData,
             std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -625,7 +625,7 @@ void ThermalCameraTest::ThermalCameraParticles(
   }
 
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 TEST_P(ThermalCameraTest, ThermalCameraBoxesUniformTemp)
@@ -649,7 +649,7 @@ TEST_P(ThermalCameraTest, ThermalCameraParticles)
 }
 
 INSTANTIATE_TEST_CASE_P(ThermalCamera, ThermalCameraTest,
-    RENDER_ENGINE_VALUES, ignition::rendering::PrintToStringParam());
+    RENDER_ENGINE_VALUES, gz::rendering::PrintToStringParam());
 
 //////////////////////////////////////////////////
 int main(int argc, char **argv)
diff --git a/test/integration/wide_angle_camera.cc b/test/integration/wide_angle_camera.cc
index be8095f4c..c7a3199f8 100644
--- a/test/integration/wide_angle_camera.cc
+++ b/test/integration/wide_angle_camera.cc
@@ -17,20 +17,20 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
-#include <ignition/common/Filesystem.hh>
-#include <ignition/common/Event.hh>
+#include <gz/common/Console.hh>
+#include <gz/common/Filesystem.hh>
+#include <gz/common/Event.hh>
 
-#include <ignition/math/Color.hh>
+#include <gz/math/Color.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
-#include "ignition/rendering/WideAngleCamera.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
+#include "gz/rendering/WideAngleCamera.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 //////////////////////////////////////////////////
@@ -46,7 +46,7 @@ class WideAngleCameraTest: public testing::Test,
   // Documentation inherited
   protected: void SetUp() override
   {
-    ignition::common::Console::SetVerbosity(4);
+    gz::common::Console::SetVerbosity(4);
   }
 };
 
@@ -85,19 +85,19 @@ void WideAngleCameraTest::WideAngleCamera(
   // Currently, only ogre supports wide angle cameras
   if (_renderEngine.compare("ogre") != 0)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
            << "' doesn't support wide angle cameras" << std::endl;
     return;
   }
 
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
            << "' was unable to be retrieved" << std::endl;
     return;
   }
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
   ASSERT_NE(nullptr, scene);
   scene->SetAmbientLight(1.0, 1.0, 1.0);
   scene->SetBackgroundColor(0.2, 0.2, 0.2);
@@ -157,7 +157,7 @@ void WideAngleCameraTest::WideAngleCamera(
   unsigned char *dataRegular = imageRegular.Data<unsigned char>();
 
   // Set a callback on the  camera sensor to get a wide angle camera frame
-  ignition::common::ConnectionPtr connection =
+  gz::common::ConnectionPtr connection =
       camera->ConnectNewWideAngleFrame(
           std::bind(OnNewWideAngleFrame,
           std::placeholders::_1, std::placeholders::_2, std::placeholders::_3,
@@ -227,7 +227,7 @@ void WideAngleCameraTest::WideAngleCamera(
 
   // Clean up
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 //////////////////////////////////////////////////
@@ -236,20 +236,20 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   // Currently, only ogre supports wideAngle cameras
   if (_renderEngine.compare("ogre") != 0)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
            << "' doesn't support wide angle cameras" << std::endl;
     return;
   }
 
   // Setup ign-rendering with an empty scene
-  auto *engine = ignition::rendering::engine(_renderEngine);
+  auto *engine = gz::rendering::engine(_renderEngine);
   if (!engine)
   {
-    ignerr << "Engine '" << _renderEngine
+    gzerr << "Engine '" << _renderEngine
               << "' was unable to be retrieved" << std::endl;
     return;
   }
-  ignition::rendering::ScenePtr scene = engine->CreateScene("scene");
+  gz::rendering::ScenePtr scene = engine->CreateScene("scene");
   ASSERT_NE(nullptr, scene);
   scene->SetAmbientLight(1.0, 1.0, 1.0);
   scene->SetBackgroundColor(0.2, 0.2, 0.2);
@@ -279,7 +279,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   camera->Update();
 
   // point directly in front of camera
-  auto worldPoint = ignition::math::Vector3d::UnitX;
+  auto worldPoint = gz::math::Vector3d::UnitX;
   auto screenPt = camera->Project3d(worldPoint);
   EXPECT_FLOAT_EQ(camera->ImageWidth() * 0.5, screenPt.X());
   EXPECT_FLOAT_EQ(camera->ImageHeight() * 0.5, screenPt.Y());
@@ -287,14 +287,14 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point behind camera
-  worldPoint = -ignition::math::Vector3d::UnitX;
+  worldPoint = -gz::math::Vector3d::UnitX;
   screenPt = camera->Project3d(worldPoint);
   // z is distance of point from image center
   // in this case it'll be outside of image so greater than 1.0
   EXPECT_GT(screenPt.Z(), 1.0);
 
   // point at right side of camera image
-  worldPoint = ignition::math::Vector3d(1, -0.5, 0.0);
+  worldPoint = gz::math::Vector3d(1, -0.5, 0.0);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_GT(screenPt.X(), camera->ImageWidth() * 0.5);
   EXPECT_FLOAT_EQ(camera->ImageHeight() * 0.5, screenPt.Y());
@@ -302,7 +302,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at left side of camera image
-  worldPoint = ignition::math::Vector3d(1, 0.5, 0.0);
+  worldPoint = gz::math::Vector3d(1, 0.5, 0.0);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_LT(screenPt.X(), camera->ImageWidth() * 0.5);
   EXPECT_FLOAT_EQ(camera->ImageHeight() * 0.5, screenPt.Y());
@@ -310,7 +310,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at top half of camera image
-  worldPoint = ignition::math::Vector3d(1, 0.0, 0.5);
+  worldPoint = gz::math::Vector3d(1, 0.0, 0.5);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_FLOAT_EQ(camera->ImageWidth() * 0.5, screenPt.X());
   EXPECT_LT(screenPt.Y(), camera->ImageHeight() * 0.5);
@@ -318,7 +318,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at bottom half of camera image
-  worldPoint = ignition::math::Vector3d(1, 0.0, -0.5);
+  worldPoint = gz::math::Vector3d(1, 0.0, -0.5);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_FLOAT_EQ(camera->ImageWidth() * 0.5, screenPt.X());
   EXPECT_GT(screenPt.Y(), camera->ImageHeight() * 0.5);
@@ -326,7 +326,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at top left quadrant of camera image
-  worldPoint = ignition::math::Vector3d(1, 0.5, 0.5);
+  worldPoint = gz::math::Vector3d(1, 0.5, 0.5);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_LT(screenPt.X(), camera->ImageWidth() * 0.5);
   EXPECT_LT(screenPt.Y(), camera->ImageHeight() * 0.5);
@@ -334,7 +334,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at top right quadrant of camera image
-  worldPoint = ignition::math::Vector3d(1, -0.5, 0.5);
+  worldPoint = gz::math::Vector3d(1, -0.5, 0.5);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_GT(screenPt.X(), camera->ImageWidth() * 0.5);
   EXPECT_LT(screenPt.Y(), camera->ImageHeight() * 0.5);
@@ -342,7 +342,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at bottom left quadrant of camera image
-  worldPoint = ignition::math::Vector3d(1, 0.5, -0.5);
+  worldPoint = gz::math::Vector3d(1, 0.5, -0.5);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_LT(screenPt.X(), camera->ImageWidth() * 0.5);
   EXPECT_GT(screenPt.Y(), camera->ImageHeight() * 0.5);
@@ -350,7 +350,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
   EXPECT_LT(screenPt.Z(), 1.0);
 
   // point at bottom right quadrant of camera image
-  worldPoint = ignition::math::Vector3d(1, -0.5, -0.5);
+  worldPoint = gz::math::Vector3d(1, -0.5, -0.5);
   screenPt = camera->Project3d(worldPoint);
   EXPECT_GT(screenPt.X(), camera->ImageWidth() * 0.5);
   EXPECT_GT(screenPt.Y(), camera->ImageHeight() * 0.5);
@@ -359,7 +359,7 @@ void WideAngleCameraTest::Projection(const std::string &_renderEngine)
 
   // Clean up
   engine->DestroyScene(scene);
-  ignition::rendering::unloadEngine(engine->Name());
+  gz::rendering::unloadEngine(engine->Name());
 }
 
 TEST_P(WideAngleCameraTest, WideAngleCamera)
@@ -373,7 +373,7 @@ TEST_P(WideAngleCameraTest, Projection)
 }
 
 INSTANTIATE_TEST_CASE_P(WideAngleCamera, WideAngleCameraTest,
-    RENDER_ENGINE_VALUES, ignition::rendering::PrintToStringParam());
+    RENDER_ENGINE_VALUES, gz::rendering::PrintToStringParam());
 
 //////////////////////////////////////////////////
 int main(int argc, char **argv)
diff --git a/test/performance/scene_factory.cc b/test/performance/scene_factory.cc
index e5a318a04..be05b03c5 100644
--- a/test/performance/scene_factory.cc
+++ b/test/performance/scene_factory.cc
@@ -22,15 +22,15 @@
 
 #include <gtest/gtest.h>
 
-#include <ignition/common/Console.hh>
+#include <gz/common/Console.hh>
 
 #include "test_config.h"  // NOLINT(build/include)
 
-#include "ignition/rendering/RenderEngine.hh"
-#include "ignition/rendering/RenderingIface.hh"
-#include "ignition/rendering/Scene.hh"
+#include "gz/rendering/RenderEngine.hh"
+#include "gz/rendering/RenderingIface.hh"
+#include "gz/rendering/Scene.hh"
 
-using namespace ignition;
+using namespace gz;
 using namespace rendering;
 
 
@@ -73,13 +73,13 @@ void getMemInfo(double &_resident, double &_share)
                                 (task_info_t)&t_info,
                                 &t_info_count))
   {
-    ignerr << "failure calling task_info\n";
+    gzerr << "failure calling task_info\n";
     return;
   }
   _resident = static_cast<double>(t_info.resident_size/1024);
   _share = static_cast<double>(t_info.virtual_size/1024);
 #else
-  ignerr << "Unsupported architecture\n";
+  gzerr << "Unsupported architecture\n";
   return;
 #endif
 }
@@ -91,7 +91,7 @@ void checkMemLeak(const std::string &_renderEngine,
   auto engine = rendering::engine(_renderEngine);
   if (!engine)
   {
-    igndbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
+    gzdbg << "Engine '" << _renderEngine << "' is not supported" << std::endl;
     return;
   }
 
@@ -119,9 +119,9 @@ void checkMemLeak(const std::string &_renderEngine,
   double resPercentChange = (residentEnd - residentStart) / residentStart;
   double sharePercentChange = (shareEnd - shareStart) / shareStart;
 
-  igndbg << "ResPercentChange[" << resPercentChange << "] "
+  gzdbg << "ResPercentChange[" << resPercentChange << "] "
     << "ResMaxPercentChange[" << resMaxPercentChange << "]" << std::endl;
-  igndbg << "SharePercentChange[" << sharePercentChange << "] "
+  gzdbg << "SharePercentChange[" << sharePercentChange << "] "
     << "ShareMaxPercentChange[" << shareMaxPercentChange << "]" << std::endl;
 
   EXPECT_LT(resPercentChange, resMaxPercentChange);
@@ -192,7 +192,7 @@ TEST_P(SceneFactoryTest, VisualMemoryLeak)
 
 INSTANTIATE_TEST_CASE_P(SceneFactory, SceneFactoryTest,
     RENDER_ENGINE_VALUES,
-    ignition::rendering::PrintToStringParam());
+    gz::rendering::PrintToStringParam());
 
 int main(int argc, char **argv)
 {
diff --git a/test/test_config.h.in b/test/test_config.h.in
index a8a651cd7..1aeceafff 100644
--- a/test/test_config.h.in
+++ b/test/test_config.h.in
@@ -1,13 +1,13 @@
-#ifndef IGNITION_RENDERING_TEST_CONFIG_HH_
-#define IGNITION_RENDERING_TEST_CONFIG_HH_
+#ifndef GZ_RENDERING_TEST_CONFIG_HH_
+#define GZ_RENDERING_TEST_CONFIG_HH_
 
 #define PROJECT_SOURCE_PATH "${PROJECT_SOURCE_DIR}"
 #define PROJECT_BUILD_PATH "${PROJECT_BINARY_DIR}"
-#define IGN_RENDERING_TEST_PLUGIN_PATH "${CMAKE_BINARY_DIR}/lib"
+#define GZ_RENDERING_TEST_PLUGIN_PATH "${CMAKE_BINARY_DIR}/lib"
 
 /// \brief Helper macro to instantiate gtest for different engines
 #define RENDER_ENGINE_VALUES ::testing::ValuesIn(\
-    ignition::rendering::TestValues())
+    gz::rendering::TestValues())
 
 /// \todo(anyone) re-enable ogre2 test once ogre 2.2 works on macOS
 #ifdef __APPLE__
@@ -17,9 +17,9 @@ static const std::vector<const char *> kRenderEngineTestValues{"ogre2", "optix"}
 #endif
 
 #include <vector>
-#include <ignition/common/Util.hh>
+#include <gz/common/Util.hh>
 
-namespace ignition
+namespace gz
 {
   namespace rendering
   {
diff --git a/tutorials/01_intro.md b/tutorials/01_intro.md
index df75d44cf..209b81e2e 100644
--- a/tutorials/01_intro.md
+++ b/tutorials/01_intro.md
@@ -2,18 +2,18 @@
 
 Next Tutorial: \ref installation
 
-## What is Ignition Rendering?
+## What is Gazebo Rendering?
 
 Ignition Rendering is an open source library that provides an abstraction layer
 to multiple rendering engines. The goal is to provide a set of unified C++
 rendering APIs that are rendering-engine-agnostic. For instance, a scene created
-through the Ignition Rendering API could be rendered using an OpenGL based
+through the Gazebo Rendering API could be rendered using an OpenGL based
 rendering library or through a ray tracer. You have the option to choose which
 rendering engine to use at run time.
 
-Ignition Rendering has a plugin architecture. Each rendering engine is
-integrated in the form of an Ignition Rendering plugin. In a nutshell, a plugin
-is essentially an interface to the underlying engine. Ignition Rendering exposes
+Gazebo Rendering has a plugin architecture. Each rendering engine is
+integrated in the form of a Gazebo Rendering plugin. In a nutshell, a plugin
+is essentially an interface to the underlying engine. Gazebo Rendering exposes
 a set of abstract public API interfaces and the engine plugins provide the
 implementation. So when a user specifies a particular rendering engine to use,
 the relevant plugin will be loaded and all rendering calls will be made through
diff --git a/tutorials/02_install.md b/tutorials/02_install.md
index 9deba4e35..85cd2ef46 100644
--- a/tutorials/02_install.md
+++ b/tutorials/02_install.md
@@ -1,7 +1,7 @@
 \page installation Installation
 
-These instructions are for installing only Ignition Rendering.
-If you're interested in using all the Ignition libraries, check out this [Ignition installation](https://ignitionrobotics.org/docs/latest/install).
+These instructions are for installing only Gazebo Rendering.
+If you're interested in using all the Ignition libraries, check out this [Ignition installation](https://gazebosim.org/docs/latest/install).
 
 We recommend following the Binary Install instructions to get up and running as quickly and painlessly as possible.
 
@@ -65,7 +65,7 @@ sudo apt install -y \
 
 ### Supported Rendering Engines
 
-Ignition Rendering will look for rendering libraries installed in the system and
+Gazebo Rendering will look for rendering libraries installed in the system and
 build the relevant plugins if dependencies are found.
 
 **OGRE 1.x**
@@ -115,7 +115,7 @@ sdk 4.0.2, comment out lines 167-206).
 1. Clone the repository
   ```
   # Optionally, append `-b ign-rendering#` (replace # with a number) to check out a specific version
-  git clone http://github.com/ignitionrobotics/ign-rendering
+  git clone http://github.com/gazebosim/gz-rendering
   ```
 
 2. Configure and build
@@ -139,7 +139,7 @@ On Windows, only OGRE 1 is currently supported.
 
 ## Prerequisites
 
-First, follow the [ign-cmake](https://github.com/ignitionrobotics/ign-cmake) tutorial for installing Conda, Visual Studio, CMake, and other prerequisites, and also for creating a Conda environment.
+First, follow the [ign-cmake](https://github.com/gazebosim/gz-cmake) tutorial for installing Conda, Visual Studio, CMake, and other prerequisites, and also for creating a Conda environment.
 
 Navigate to ``condabin`` if necessary to use the ``conda`` command (i.e., if Conda is not in your `PATH` environment variable. You can find the location of ``condabin`` in Anaconda Prompt, ``where conda``).
 
@@ -177,7 +177,7 @@ This assumes you have created and activated a Conda environment while installing
 3. Navigate to where you would like to build the library, and clone the repository.
   ```
   # Optionally, append `-b ign-rendering#` (replace # with a number) to check out a specific version
-  git clone https://github.com/ignitionrobotics/ign-rendering.git
+  git clone https://github.com/gazebosim/gz-rendering.git
   ```
 
 4. Configure and build
@@ -204,7 +204,7 @@ On macOS, add OSRF packages:
   brew tap osrf/simulation
   ```
 
-Install Ignition Rendering:
+Install Gazebo Rendering:
   ```
   brew install ignition-rendering<#>
   ```
@@ -216,7 +216,7 @@ which version you need.
 
 1. Clone the repository
   ```
-  git clone https://github.com/ignitionrobotics/ign-rendering -b ign-rendering<#>
+  git clone https://github.com/gazebosim/gz-rendering -b ign-rendering<#>
   ```
   Be sure to replace `<#>` with a number value, such as 5 or 6, depending on
   which version you need.
diff --git a/tutorials/03_rendering_plugins.md b/tutorials/03_rendering_plugins.md
index 74571add2..a44760126 100644
--- a/tutorials/03_rendering_plugins.md
+++ b/tutorials/03_rendering_plugins.md
@@ -1,32 +1,32 @@
 \page renderingplugin Understanding the Rendering Plugin
 
-This is an introduction to different rendering engines and how they are integrated into the Ignition Rendering library.
+This is an introduction to different rendering engines and how they are integrated into the Gazebo Rendering library.
 
-## Ignition Rendering
+## Gazebo Rendering
 
-The \ref ignition::rendering "Ignition Rendering" library integrates external rendering engines into the Ignition Simulation eco-system.
+The \ref gz::rendering "Gazebo Rendering" library integrates external rendering engines into the Gazebo Simulation eco-system.
 It allows users to select from multiple supported rendering engines based on their simulation needs.
 Its plugin interface loads rendering engines at runtime.
 It is also possible to integrate your own selected rendering engine by writing a compatible plugin interface.
 
 #### How to Write Your Own Rendering Engine Plugin
 
-A mocked example of a custom rendering engine plugin can be found [here](https://github.com/ignitionrobotics/ign-rendering/tree/main/examples/hello_world_plugin).  In order
+A mocked example of a custom rendering engine plugin can be found [here](https://github.com/gazebosim/gz-rendering/tree/main/examples/hello_world_plugin).  In order
 to make your own custom rendering engine, this example is a good starting point.  There are a few key things which will need to be done in order for a custom rendering engine to function:
 
- * A singleton Render Engine class which implements the pure virtual functions in [`ignition::rendering::BaseRenderEngine`](https://github.com/ignitionrobotics/ign-rendering/blob/main/include/ignition/rendering/base/BaseRenderEngine.hh).
- * A plugin class which implements the pure virtual functions in [`ignition::rendering::RenderEnginePlugin`](https://github.com/ignitionrobotics/ign-rendering/blob/main/include/ignition/rendering/RenderEnginePlugin.hh)
- * Registering the plugin, this line can be seen at the bottom of the [`HelloWorldPlugin`](https://github.com/ignitionrobotics/ign-rendering/tree/main/examples/hello_world_plugin/HelloWorldPlugin.cc) example
+ * A singleton Render Engine class which implements the pure virtual functions in [`gz::rendering::BaseRenderEngine`](https://github.com/gazebosim/gz-rendering/blob/main/include/ignition/rendering/base/BaseRenderEngine.hh).
+ * A plugin class which implements the pure virtual functions in [`gz::rendering::RenderEnginePlugin`](https://github.com/gazebosim/gz-rendering/blob/main/include/ignition/rendering/RenderEnginePlugin.hh)
+ * Registering the plugin, this line can be seen at the bottom of the [`HelloWorldPlugin`](https://github.com/gazebosim/gz-rendering/tree/main/examples/hello_world_plugin/HelloWorldPlugin.cc) example
 
-Finally, for your custom rendering engine to actually have any functionality and at minimum, display something in a window, you will need to implement your own `Scene` and `Camera` classes, which inherit from and implement the pure virtual functions of [`ignition::rendering::Scene`](https://github.com/ignitionrobotics/ign-rendering/blob/main/include/ignition/rendering/Scene.hh) and  [`ignition::rendering::Camera`](https://github.com/ignitionrobotics/ign-rendering/blob/main/include/ignition/rendering/Camera.hh), respectively.  The mocked example simply returns `nullptr` for its `CreateSceneImpl(...)` function, so it may be useful to look at the current `Scene` implementations for the other rendering engines within `ignition::rendering` such as [`OGRE`](https://github.com/ignitionrobotics/ign-rendering/blob/main/ogre/src/OgreScene.cc) or [`OGRE2`](https://github.com/ignitionrobotics/ign-rendering/blob/main/ogre2/src/Ogre2Scene.cc).  Likewise, it may be helpful to look at the `Camera` implementations from [`OGRE`](https://github.com/ignitionrobotics/ign-rendering/blob/main/ogre/src/OgreCamera.cc) and [`OGRE2`](https://github.com/ignitionrobotics/ign-rendering/blob/main/ogre2/src/Ogre2Camera.cc)
+Finally, for your custom rendering engine to actually have any functionality and at minimum, display something in a window, you will need to implement your own `Scene` and `Camera` classes, which inherit from and implement the pure virtual functions of [`gz::rendering::Scene`](https://github.com/gazebosim/gz-rendering/blob/main/include/ignition/rendering/Scene.hh) and  [`gz::rendering::Camera`](https://github.com/gazebosim/gz-rendering/blob/main/include/ignition/rendering/Camera.hh), respectively.  The mocked example simply returns `nullptr` for its `CreateSceneImpl(...)` function, so it may be useful to look at the current `Scene` implementations for the other rendering engines within `gz::rendering` such as [`OGRE`](https://github.com/gazebosim/gz-rendering/blob/main/ogre/src/OgreScene.cc) or [`OGRE2`](https://github.com/gazebosim/gz-rendering/blob/main/ogre2/src/Ogre2Scene.cc).  Likewise, it may be helpful to look at the `Camera` implementations from [`OGRE`](https://github.com/gazebosim/gz-rendering/blob/main/ogre/src/OgreCamera.cc) and [`OGRE2`](https://github.com/gazebosim/gz-rendering/blob/main/ogre2/src/Ogre2Camera.cc)
 
-#### Building and Running Your Rendering Engine Plugin with Ignition Gazebo
+#### Building and Running Your Rendering Engine Plugin with Gazebo
 
-Once you have your own rendering plugin written, you can build it similarly to how the example is built.  It may be helpful to look at the [`CMakeLists.txt`](https://github.com/ignitionrobotics/ign-rendering/tree/main/examples/hello_world_plugin) from the example as it contains the boilerplate code needed to get a custom rendering engine plugin built.
+Once you have your own rendering plugin written, you can build it similarly to how the example is built.  It may be helpful to look at the [`CMakeLists.txt`](https://github.com/gazebosim/gz-rendering/tree/main/examples/hello_world_plugin) from the example as it contains the boilerplate code needed to get a custom rendering engine plugin built.
 
 After you have your plugin built, you will need to set the `IGN_GAZEBO_RENDER_ENGINE_PATH` environment variable to the path in which your built shared library resides.  Note that you will need to do this for every command line instance unless you add the line to your startup shell script (`.bashrc`, `.zshrc`, etc.).
 
-From here, you should be able to reference your rendering plugin within Ignition Gazebo by the name of the generated shared library file (without the `lib` prefix or the file extension, i.e., libHelloWorldPlugin.so -> HelloWorldPlugin).
+From here, you should be able to reference your rendering plugin within Gazebo by the name of the generated shared library file (without the `lib` prefix or the file extension, i.e., libHelloWorldPlugin.so -> HelloWorldPlugin).
 
 \note You can use the `--render-engine`, `--render-engine-server`, and `--render-engine-gui` flags to specify any supported or custom rendering engine at runtime, this flag will override any other pre-existing rendering engine specifications (such as in an `.sdf` file).  The command line call would look something like:
 
diff --git a/tutorials/04_lightmap.md b/tutorials/04_lightmap.md
index e298cd4ee..e35e152b1 100644
--- a/tutorials/04_lightmap.md
+++ b/tutorials/04_lightmap.md
@@ -70,7 +70,7 @@ Model with baked in lighting (Blender Viewport Shading turned on):
 
 ### Step 6: Test/Export
 
-Light maps are great for working with bigger scenes. With baked-in lighting, complex meshes can show realistic lighting without using heavy computation (the [Depot](https://app.ignitionrobotics.org/OpenRobotics/fuel/models/Depot) model below is a good example of complex scene with a baked light map).
+Light maps are great for working with bigger scenes. With baked-in lighting, complex meshes can show realistic lighting without using heavy computation (the [Depot](https://app.gazebosim.org/OpenRobotics/fuel/models/Depot) model below is a good example of complex scene with a baked light map).
 
 To export light map image go to `UV editor` > `Image` > `Save as`
 
@@ -84,10 +84,10 @@ Light map baking applied to a more complex scene:
 
 When baking we have the option to either bake in all the lighting, both indirect and direct, or just the indirect lighting, also known as global illumination or bounced lighting, and use real time lights in Ignition for the direct lighting and shadows. With the latter method we get sharper lighting and shadow detail as well as more accurate lighting on our dynamic objects however performance will be impacted by having more real time lights. Even with all the lighting baked it’s still a good idea to have one real time light such as a large point light or directional light works particularly well in order to enhance the effects of the physically based materials.
 
-Lightmaps can be applied to a mesh in Ignition the same way as other texture maps. Create an `ignition::rendering::Material` and specify a light map texture by calling
-[SetLightMap](https://ignitionrobotics.org/api/rendering/5.0/classignition_1_1rendering_1_1Material.html#addc6eb6206e0a17ab82aeaea543e8c71). Recall that when creating the light map UV texture in Step 2, we typically use a secondary UV set for light maps. Make sure to specify the index of the light map UV set as the second argument to this function.
+Lightmaps can be applied to a mesh in Ignition the same way as other texture maps. Create an `gz::rendering::Material` and specify a light map texture by calling
+[SetLightMap](https://gazebosim.org/api/rendering/5.0/classignition_1_1rendering_1_1Material.html#addc6eb6206e0a17ab82aeaea543e8c71). Recall that when creating the light map UV texture in Step 2, we typically use a secondary UV set for light maps. Make sure to specify the index of the light map UV set as the second argument to this function.
 
-There are existing example models on Ignition Fuel that use light maps. The [Depot](https://app.ignitionrobotics.org/OpenRobotics/fuel/models/Depot) model mentioned earlier is one such example, and another one is the [Indoor Lightmap](https://app.ignitionrobotics.org/OpenRobotics/fuel/models/Indoor%20light map) model. To see the Indoor Lightmap model with [Ignition Gazebo](https://ignitionrobotics.org/docs/all/getstarted), you can run the following command (requires Ignition Edifice or above):
+There are existing example models on Gazebo Fuel that use light maps. The [Depot](https://app.gazebosim.org/OpenRobotics/fuel/models/Depot) model mentioned earlier is one such example, and another one is the [Indoor Lightmap](https://app.gazebosim.org/OpenRobotics/fuel/models/Indoor%20light map) model. To see the Indoor Lightmap model with [Gazebo](https://gazebosim.org/docs/all/getstarted), you can run the following command (requires Gazebo Edifice or above):
 
 ```
 ign gazebo -v lightmap.sdf
diff --git a/tutorials/10_actor_animation_tutorial.md b/tutorials/10_actor_animation_tutorial.md
index d1d1e76ed..5835daee4 100644
--- a/tutorials/10_actor_animation_tutorial.md
+++ b/tutorials/10_actor_animation_tutorial.md
@@ -1,13 +1,13 @@
 \page actor_animation Actor animation tutorial
 
-This tutorial will show you how to use the Ignition Rendering library to create an actor animation.
+This tutorial will show you how to use the Gazebo Rendering library to create an actor animation.
 
 ## Compile and run the example
 
 Clone the source code, Create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/actor_animation
 mkdir build
 cd build
diff --git a/tutorials/11_gazebo_scene_viewer_tutorial.md b/tutorials/11_gazebo_scene_viewer_tutorial.md
index 1b19324b6..d5269c1d6 100644
--- a/tutorials/11_gazebo_scene_viewer_tutorial.md
+++ b/tutorials/11_gazebo_scene_viewer_tutorial.md
@@ -1,13 +1,13 @@
 \page gazebo_scene_viewer Gazebo scene viewer
 
-The Gazebo scene viewer examples allow us to visualize Gazebo simulation using the Ignition Rendering library.
+The Gazebo scene viewer examples allow us to visualize Gazebo simulation using the Gazebo Rendering library.
 
 ## Compile and run the example
 
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/gazebo_scene_viewer
 mkdir build
 cd build
diff --git a/tutorials/12_mesh_viewer_tutorial.md b/tutorials/12_mesh_viewer_tutorial.md
index 65f1f3f98..32f76c798 100644
--- a/tutorials/12_mesh_viewer_tutorial.md
+++ b/tutorials/12_mesh_viewer_tutorial.md
@@ -5,7 +5,7 @@
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/mesh_viewer
 mkdir build
 cd build
diff --git a/tutorials/13_custom_scene_viewer.md b/tutorials/13_custom_scene_viewer.md
index 9b7fc8cdf..594af1c10 100644
--- a/tutorials/13_custom_scene_viewer.md
+++ b/tutorials/13_custom_scene_viewer.md
@@ -7,7 +7,7 @@ When the application starts you will see a blank window.
 When you click the `+` or `-` keys you can change the scene.
 By pressing the `Tab` button you will advance to the next render engine.
 
-You may see the render engine title in the window change to Optix if you have compiled your Ignition Rendering library with OptiX (otherwise you can only use Ogre).
+You may see the render engine title in the window change to Optix if you have compiled your Gazebo Rendering library with OptiX (otherwise you can only use Ogre).
 The frame rate may also change based on your computer's capabilities.
 
 The following scenes have more primitive objects such as cones or cilinders. Again, you can see the scene with different render engines pressing `Tab`.
@@ -26,7 +26,7 @@ There are some scenes demonstrating reflective materials and mutiple point light
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/custom_scene_viewer
 mkdir build
 cd build
diff --git a/tutorials/14_camera_tracking_tutorial.md b/tutorials/14_camera_tracking_tutorial.md
index 198abfbd5..9901a92dc 100644
--- a/tutorials/14_camera_tracking_tutorial.md
+++ b/tutorials/14_camera_tracking_tutorial.md
@@ -7,7 +7,7 @@ This example shows a camera tracking a moving target. You can use the keyboard t
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/camera_tracking
 mkdir build
 cd build
@@ -61,10 +61,10 @@ You'll see:
 
 There are two main functions in the `Camera` class that allow us to track and follow the object:
 
-[SetTrackTarget](https://ignitionrobotics.org/api/rendering/4.0/classignition_1_1rendering_1_1Camera.html#a492d6ad21711d6050ccda1a96676f8fe): Set a node for camera to track. The camera will automatically change its orientation to face the target being tracked. If a null node is specified, tracking is disabled. In contrast to `SetFollowTarget` the camera does not change its position when tracking is enabled.
+[SetTrackTarget](https://gazebosim.org/api/rendering/4.0/classignition_1_1rendering_1_1Camera.html#a492d6ad21711d6050ccda1a96676f8fe): Set a node for camera to track. The camera will automatically change its orientation to face the target being tracked. If a null node is specified, tracking is disabled. In contrast to `SetFollowTarget` the camera does not change its position when tracking is enabled.
 
 \snippet examples/camera_tracking/GlutWindow.cc camera track
 
-[SetFollowTarget](https://ignitionrobotics.org/api/rendering/4.0/classignition_1_1rendering_1_1Camera.html#ae5dac859964f1c47eba4d46d6d3ef9f9): Set a node for camera to follow. The camera will automatically update its position to keep itself at the specified offset distance from the target being followed. If a null node is specified, camera follow is disabled. In contrast to `SetTrackTarget`, the camera does not change its orientation when following is enabled.
+[SetFollowTarget](https://gazebosim.org/api/rendering/4.0/classignition_1_1rendering_1_1Camera.html#ae5dac859964f1c47eba4d46d6d3ef9f9): Set a node for camera to follow. The camera will automatically update its position to keep itself at the specified offset distance from the target being followed. If a null node is specified, camera follow is disabled. In contrast to `SetTrackTarget`, the camera does not change its orientation when following is enabled.
 
 \snippet examples/camera_tracking/GlutWindow.cc camera follow
diff --git a/tutorials/15_custom_shaders_tutorial.md b/tutorials/15_custom_shaders_tutorial.md
index 5a369056c..2c192d6ff 100644
--- a/tutorials/15_custom_shaders_tutorial.md
+++ b/tutorials/15_custom_shaders_tutorial.md
@@ -7,7 +7,7 @@ This example shows how use custom shaders in ign-rendering to change the appeara
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/custom_shaders
 mkdir build
 cd build
diff --git a/tutorials/17_render_pass_tutorial.md b/tutorials/17_render_pass_tutorial.md
index fb0185fbd..b9b4cbd92 100644
--- a/tutorials/17_render_pass_tutorial.md
+++ b/tutorials/17_render_pass_tutorial.md
@@ -7,7 +7,7 @@ This example demonstrates the use of the render pass system for adding Gaussian
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/render_pass
 mkdir build
 cd build
diff --git a/tutorials/18_simple_demo_tutorial.md b/tutorials/18_simple_demo_tutorial.md
index 11b54a9fb..e665a67e5 100644
--- a/tutorials/18_simple_demo_tutorial.md
+++ b/tutorials/18_simple_demo_tutorial.md
@@ -7,7 +7,7 @@ This example shows how move the camera automatically.
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/simple_demo
 mkdir build
 cd build
diff --git a/tutorials/19_text_geom_tutorial.md b/tutorials/19_text_geom_tutorial.md
index 25166c8fb..a2d48e582 100644
--- a/tutorials/19_text_geom_tutorial.md
+++ b/tutorials/19_text_geom_tutorial.md
@@ -7,7 +7,7 @@ This example shows how to include text in the scene.
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/text_geom
 mkdir build
 cd build
diff --git a/tutorials/20_particles_tutorial.md b/tutorials/20_particles_tutorial.md
index 42dc9a506..88c32f556 100644
--- a/tutorials/20_particles_tutorial.md
+++ b/tutorials/20_particles_tutorial.md
@@ -7,7 +7,7 @@ This example shows how to include a particle emitter in the scene.
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/particles_demo
 mkdir build
 cd build
diff --git a/tutorials/21_heightmap.md b/tutorials/21_heightmap.md
index ee9adef14..1723ebeff 100644
--- a/tutorials/21_heightmap.md
+++ b/tutorials/21_heightmap.md
@@ -9,7 +9,7 @@ It loads 2 different heightmaps (image and Digital Elevation Model (DEM)) with d
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/heightmap
 mkdir build
 cd build
diff --git a/tutorials/21_render_order.md b/tutorials/21_render_order.md
index c6a37daf3..f0d208bd3 100644
--- a/tutorials/21_render_order.md
+++ b/tutorials/21_render_order.md
@@ -37,7 +37,7 @@ a float value:
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/simple_demo
 mkdir build
 cd build
diff --git a/tutorials/22_environment_map.md b/tutorials/22_environment_map.md
index 5270a8cb2..ee6d68318 100644
--- a/tutorials/22_environment_map.md
+++ b/tutorials/22_environment_map.md
@@ -49,7 +49,7 @@ The cube map accepted by the ogre2 render engine needs to be in a specific
 format. You can use the `gimp-dds` plugin to create the texture.
 
 Let's take a look at the sky cube map in gimp. Open `gimp` and import the
-[sky_lowres.dds](https://github.com/ignitionrobotics/ign-rendering/blob/main/examples/ogre2_demo/media/skybox_lowres.dds?raw=true)
+[sky_lowres.dds](https://github.com/gazebosim/gz-rendering/blob/main/examples/ogre2_demo/media/skybox_lowres.dds?raw=true)
 file. Look at the `Layers` windows (`Windows` > `Dockable Dialogs` > `Layers`)
 to see that each face of the cube map is in its own individual layer.
 
diff --git a/tutorials/23_depth_camera_tutorial.md b/tutorials/23_depth_camera_tutorial.md
index 33b12063f..d690d8219 100644
--- a/tutorials/23_depth_camera_tutorial.md
+++ b/tutorials/23_depth_camera_tutorial.md
@@ -7,7 +7,7 @@ This example shows how to use the depth camera.
 Clone the source code, create a build directory and use `cmake` and `make` to compile the code:
 
 ```{.sh}
-git clone https://github.com/ignitionrobotics/ign-rendering
+git clone https://github.com/gazebosim/gz-rendering
 cd ign-rendering/examples/simple_demo
 mkdir build
 cd build
@@ -63,7 +63,7 @@ depth camera to a memory reserved in a globally scoped `Image`.
 
 \snippet examples/depth_camera/GlutWindow.cc convert depth to image
 
-The other option is the [ConnectNewRgbPointCloud](https://github.com/ignitionrobotics/ign-rendering/blob/ign-rendering7/include/ignition/rendering/DepthCamera.hh#L58) call that receives colored point cloud data on callback.
+The other option is the [ConnectNewRgbPointCloud](https://github.com/gazebosim/gz-rendering/blob/ign-rendering7/include/ignition/rendering/DepthCamera.hh#L58) call that receives colored point cloud data on callback.
 
 The reason for setting the camera image format to `PixelFormat::PF_FLOAT32_RGBA`
 is to ensure that when the `Image` is created it reserves a buffer of the
